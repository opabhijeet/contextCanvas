(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@liveblocks_react_dist_09766e._.js", {

"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/contexts.ts
__turbopack_esm__({
    "ClientContext": (()=>ClientContext),
    "LiveblocksProvider": (()=>LiveblocksProvider),
    "RoomContext": (()=>RoomContext),
    "_RoomProvider": (()=>_RoomProvider),
    "_useAddReaction": (()=>_useAddReaction),
    "_useBroadcastEvent": (()=>_useBroadcastEvent),
    "_useCreateThread": (()=>_useCreateThread),
    "_useDeleteThread": (()=>_useDeleteThread),
    "_useEditThreadMetadata": (()=>_useEditThreadMetadata),
    "_useEventListener": (()=>_useEventListener),
    "_useHistoryVersions": (()=>_useHistoryVersions),
    "_useHistoryVersionsSuspense": (()=>_useHistoryVersionsSuspense),
    "_useInboxNotificationThread": (()=>_useInboxNotificationThread),
    "_useIsInsideRoom": (()=>_useIsInsideRoom),
    "_useMutation": (()=>_useMutation),
    "_useMyPresence": (()=>_useMyPresence),
    "_useOther": (()=>_useOther),
    "_useOtherSuspense": (()=>_useOtherSuspense),
    "_useOthers": (()=>_useOthers),
    "_useOthersListener": (()=>_useOthersListener),
    "_useOthersMapped": (()=>_useOthersMapped),
    "_useOthersMappedSuspense": (()=>_useOthersMappedSuspense),
    "_useOthersSuspense": (()=>_useOthersSuspense),
    "_useRoom": (()=>_useRoom),
    "_useRoomNotificationSettings": (()=>_useRoomNotificationSettings),
    "_useRoomNotificationSettingsSuspense": (()=>_useRoomNotificationSettingsSuspense),
    "_useSelf": (()=>_useSelf),
    "_useSelfSuspense": (()=>_useSelfSuspense),
    "_useStorage": (()=>_useStorage),
    "_useStorageRoot": (()=>_useStorageRoot),
    "_useStorageSuspense": (()=>_useStorageSuspense),
    "_useThreads": (()=>_useThreads),
    "_useThreadsSuspense": (()=>_useThreadsSuspense),
    "_useUpdateMyPresence": (()=>_useUpdateMyPresence),
    "_useUser": (()=>_useUser),
    "_useUserSuspense": (()=>_useUserSuspense),
    "_useUserThreadsSuspense_experimental": (()=>_useUserThreadsSuspense_experimental),
    "_useUserThreads_experimental": (()=>_useUserThreads_experimental),
    "createLiveblocksContext": (()=>createLiveblocksContext),
    "createRoomContext": (()=>createRoomContext),
    "getUmbrellaStoreForClient": (()=>getUmbrellaStoreForClient),
    "useAddRoomCommentReaction": (()=>useAddRoomCommentReaction),
    "useAttachmentUrl": (()=>useAttachmentUrl),
    "useAttachmentUrlSuspense": (()=>useAttachmentUrlSuspense),
    "useBatch": (()=>useBatch),
    "useCanRedo": (()=>useCanRedo),
    "useCanUndo": (()=>useCanUndo),
    "useClient": (()=>useClient),
    "useClientOrNull": (()=>useClientOrNull),
    "useCreateComment": (()=>useCreateComment),
    "useCreateRoomComment": (()=>useCreateRoomComment),
    "useCreateRoomThread": (()=>useCreateRoomThread),
    "useCreateTextMention": (()=>useCreateTextMention),
    "useDeleteAllInboxNotifications": (()=>useDeleteAllInboxNotifications),
    "useDeleteComment": (()=>useDeleteComment),
    "useDeleteInboxNotification": (()=>useDeleteInboxNotification),
    "useDeleteRoomComment": (()=>useDeleteRoomComment),
    "useDeleteRoomThread": (()=>useDeleteRoomThread),
    "useDeleteTextMention": (()=>useDeleteTextMention),
    "useEditComment": (()=>useEditComment),
    "useEditRoomComment": (()=>useEditRoomComment),
    "useEditRoomThreadMetadata": (()=>useEditRoomThreadMetadata),
    "useErrorListener": (()=>useErrorListener),
    "useHistory": (()=>useHistory),
    "useHistoryVersionData": (()=>useHistoryVersionData),
    "useInboxNotifications": (()=>useInboxNotifications),
    "useInboxNotificationsSuspense": (()=>useInboxNotificationsSuspense),
    "useLostConnectionListener": (()=>useLostConnectionListener),
    "useMarkAllInboxNotificationsAsRead": (()=>useMarkAllInboxNotificationsAsRead),
    "useMarkInboxNotificationAsRead": (()=>useMarkInboxNotificationAsRead),
    "useMarkRoomThreadAsRead": (()=>useMarkRoomThreadAsRead),
    "useMarkRoomThreadAsResolved": (()=>useMarkRoomThreadAsResolved),
    "useMarkRoomThreadAsUnresolved": (()=>useMarkRoomThreadAsUnresolved),
    "useMarkThreadAsRead": (()=>useMarkThreadAsRead),
    "useMarkThreadAsResolved": (()=>useMarkThreadAsResolved),
    "useMarkThreadAsUnresolved": (()=>useMarkThreadAsUnresolved),
    "useMentionSuggestionsCache": (()=>useMentionSuggestionsCache),
    "useOthersConnectionIds": (()=>useOthersConnectionIds),
    "useOthersConnectionIdsSuspense": (()=>useOthersConnectionIdsSuspense),
    "useRedo": (()=>useRedo),
    "useRemoveReaction": (()=>useRemoveReaction),
    "useRemoveRoomCommentReaction": (()=>useRemoveRoomCommentReaction),
    "useReportTextEditor": (()=>useReportTextEditor),
    "useResolveMentionSuggestions": (()=>useResolveMentionSuggestions),
    "useRoomAttachmentUrl": (()=>useRoomAttachmentUrl),
    "useRoomInfo": (()=>useRoomInfo),
    "useRoomInfoSuspense": (()=>useRoomInfoSuspense),
    "useRoomOrNull": (()=>useRoomOrNull),
    "useRoomPermissions": (()=>useRoomPermissions),
    "useSignal": (()=>useSignal),
    "useStatus": (()=>useStatus),
    "useStorageStatus": (()=>useStorageStatus),
    "useStorageStatusSuspense": (()=>useStorageStatusSuspense),
    "useSyncExternalStoreWithSelector": (()=>useSyncExternalStoreWithSelector),
    "useSyncStatus": (()=>useSyncStatus),
    "useThreadSubscription": (()=>useThreadSubscription),
    "useUndo": (()=>useUndo),
    "useUnreadInboxNotificationsCount": (()=>useUnreadInboxNotificationsCount),
    "useUnreadInboxNotificationsCountSuspense": (()=>useUnreadInboxNotificationsCountSuspense),
    "useUpdateRoomNotificationSettings": (()=>useUpdateRoomNotificationSettings),
    "useYjsProvider": (()=>useYjsProvider)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
// src/liveblocks.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
// src/lib/shallow2.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/core/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
;
var RoomContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
function useRoomOrNull() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(RoomContext);
}
function useIsInsideRoom() {
    const room = useRoomOrNull();
    return room !== null;
}
;
function is(x, y) {
    return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    const instRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    let inst;
    if (instRef.current === null) {
        inst = {
            hasValue: false,
            value: null
        };
        instRef.current = inst;
    } else {
        inst = instRef.current;
    }
    const [getSelection, getServerSelection] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useSyncExternalStoreWithSelector.useMemo": ()=>{
            let hasMemo = false;
            let memoizedSnapshot;
            let memoizedSelection;
            const memoizedSelector = {
                "useSyncExternalStoreWithSelector.useMemo.memoizedSelector": (nextSnapshot)=>{
                    if (!hasMemo) {
                        hasMemo = true;
                        memoizedSnapshot = nextSnapshot;
                        const nextSelection2 = selector(nextSnapshot);
                        if (isEqual !== void 0) {
                            if (inst.hasValue) {
                                const currentSelection = inst.value;
                                if (isEqual(currentSelection, nextSelection2)) {
                                    memoizedSelection = currentSelection;
                                    return currentSelection;
                                }
                            }
                        }
                        memoizedSelection = nextSelection2;
                        return nextSelection2;
                    }
                    const prevSnapshot = memoizedSnapshot;
                    const prevSelection = memoizedSelection;
                    if (is(prevSnapshot, nextSnapshot)) {
                        return prevSelection;
                    }
                    const nextSelection = selector(nextSnapshot);
                    if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                        memoizedSnapshot = nextSnapshot;
                        return prevSelection;
                    }
                    memoizedSnapshot = nextSnapshot;
                    memoizedSelection = nextSelection;
                    return nextSelection;
                }
            }["useSyncExternalStoreWithSelector.useMemo.memoizedSelector"];
            const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            const getSnapshotWithSelector = {
                "useSyncExternalStoreWithSelector.useMemo.getSnapshotWithSelector": ()=>memoizedSelector(getSnapshot())
            }["useSyncExternalStoreWithSelector.useMemo.getSnapshotWithSelector"];
            const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : ({
                "useSyncExternalStoreWithSelector.useMemo": ()=>memoizedSelector(maybeGetServerSnapshot())
            })["useSyncExternalStoreWithSelector.useMemo"];
            return [
                getSnapshotWithSelector,
                getServerSnapshotWithSelector
            ];
        }
    }["useSyncExternalStoreWithSelector.useMemo"], [
        getSnapshot,
        getServerSnapshot,
        selector,
        isEqual
    ]);
    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSelection, getServerSelection);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncExternalStoreWithSelector.useEffect": ()=>{
            inst.hasValue = true;
            inst.value = value;
        }
    }["useSyncExternalStoreWithSelector.useEffect"], [
        value
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(value);
    return value;
}
// src/use-signal.ts
var identity = (value)=>value;
function useSignal(signal, selector, isEqual) {
    return useSyncExternalStoreWithSelector(signal.subscribe, signal.get, signal.get, selector ?? identity, isEqual);
}
;
;
// src/config.ts
var SECONDS = 1e3;
var MINUTES = 60 * SECONDS;
var config = {
    SMOOTH_DELAY: 1 * SECONDS,
    NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,
    NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,
    ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,
    ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,
    USER_THREADS_POLL_INTERVAL: 1 * MINUTES,
    USER_THREADS_MAX_STALE_TIME: 5 * SECONDS,
    HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,
    HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,
    NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,
    NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS
};
// src/lib/AsyncResult.ts
var ASYNC_LOADING = Object.freeze({
    isLoading: true
});
var ASYNC_ERR = (error)=>Object.freeze({
        isLoading: false,
        error
    });
function ASYNC_OK(fieldOrData, data) {
    if (arguments.length === 1) {
        return Object.freeze({
            isLoading: false,
            data: fieldOrData
        });
    } else {
        return Object.freeze({
            isLoading: false,
            [fieldOrData]: data
        });
    }
}
// src/lib/itertools.ts
function find(it, predicate) {
    for (const item of it){
        if (predicate(item)) return item;
    }
    return void 0;
}
function count(it, predicate) {
    let total = 0;
    for (const item of it){
        if (predicate(item)) total++;
    }
    return total;
}
// src/lib/ssr.ts
function ensureNotServerSide() {
    if (typeof window === "undefined") {
        throw new Error("You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense");
    }
}
;
;
function useLatest(value) {
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(value);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useLatest.useEffect2": ()=>{
            ref.current = value;
        }
    }["useLatest.useEffect2"], [
        value
    ]);
    return ref;
}
// src/lib/use-initial.ts
var noop = (state)=>state;
function useInitial(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])(noop, value)[0];
}
function useInitialUnlessFunction(latestValue) {
    const frozenValue = useInitial(latestValue);
    if (typeof frozenValue === "function") {
        const ref = useLatest(latestValue);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "useInitialUnlessFunction.useCallback": (...args)=>ref.current(...args)
        }["useInitialUnlessFunction.useCallback"], [
            ref
        ]);
    } else {
        return frozenValue;
    }
}
// src/lib/use-polyfill.ts
var use = // React.use ||
(promise)=>{
    if (promise.status === "pending") {
        throw promise;
    } else if (promise.status === "fulfilled") {
        return promise.value;
    } else if (promise.status === "rejected") {
        throw promise.reason;
    } else {
        promise.status = "pending";
        promise.then((v)=>{
            promise.status = "fulfilled";
            promise.value = v;
        }, (e)=>{
            promise.status = "rejected";
            promise.reason = e;
        });
        throw promise;
    }
};
;
// src/lib/autobind.ts
function autobind(self) {
    const seen = /* @__PURE__ */ new Set();
    seen.add("constructor");
    let obj = self.constructor.prototype;
    do {
        for (const key of Reflect.ownKeys(obj)){
            if (seen.has(key)) continue;
            const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
            if (typeof descriptor?.value === "function") {
                seen.add(key);
                self[key] = self[key].bind(self);
            }
        }
    }while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype)
}
;
function shallow2(a, b) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(a) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(b)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"])(a, b);
    }
    const keysA = Object.keys(a);
    if (keysA.length !== Object.keys(b).length) {
        return false;
    }
    return keysA.every((key)=>Object.prototype.hasOwnProperty.call(b, key) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"])(a[key], b[key]));
}
;
;
function makeThreadsFilter(query) {
    return (thread)=>matchesQuery(thread, query) && matchesMetadata(thread, query);
}
function matchesQuery(thread, q) {
    return q.resolved === void 0 || thread.resolved === q.resolved;
}
function matchesMetadata(thread, q) {
    const metadata = thread.metadata;
    return q.metadata === void 0 || Object.entries(q.metadata).every(([key, op])=>// Ignore explicit-undefined filters
        // Boolean logic: op? => value matches the operator
        op === void 0 || matchesOperator(metadata[key], op));
}
function matchesOperator(value, op) {
    if (op === null) {
        return value === void 0;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStartsWithOperator"])(op)) {
        return typeof value === "string" && value.startsWith(op.startsWith);
    } else {
        return value === op;
    }
}
// src/ThreadDB.ts
function sanitizeThread(thread) {
    if (thread.deletedAt) {
        if (thread.comments.length > 0) {
            return {
                ...thread,
                comments: []
            };
        }
    }
    const hasComment = thread.comments.some((c)=>!c.deletedAt);
    if (!hasComment) {
        return {
            ...thread,
            deletedAt: /* @__PURE__ */ new Date(),
            comments: []
        };
    }
    return thread;
}
var ThreadDB = class _ThreadDB {
    #byId;
    #asc;
    #desc;
    // This signal will be notified on every mutation
    signal;
    constructor(){
        this.#asc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SortedList"].from([], (t1, t2)=>{
            const d1 = t1.createdAt;
            const d2 = t2.createdAt;
            return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;
        });
        this.#desc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SortedList"].from([], (t1, t2)=>{
            const d2 = t2.updatedAt;
            const d1 = t1.updatedAt;
            return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;
        });
        this.#byId = /* @__PURE__ */ new Map();
        this.signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](this);
    }
    //
    // Public APIs
    //
    clone() {
        const newPool = new _ThreadDB();
        newPool.#byId = new Map(this.#byId);
        newPool.#asc = this.#asc.clone();
        newPool.#desc = this.#desc.clone();
        return newPool;
    }
    /** Returns an existing thread by ID. Will never return a deleted thread. */ get(threadId) {
        const thread = this.getEvenIfDeleted(threadId);
        return thread?.deletedAt ? void 0 : thread;
    }
    /** Returns the (possibly deleted) thread by ID. */ getEvenIfDeleted(threadId) {
        return this.#byId.get(threadId);
    }
    /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */ upsert(thread) {
        this.signal.mutate(()=>{
            thread = sanitizeThread(thread);
            const id = thread.id;
            const toRemove = this.#byId.get(id);
            if (toRemove) {
                if (toRemove.deletedAt) return false;
                this.#asc.remove(toRemove);
                this.#desc.remove(toRemove);
            }
            if (!thread.deletedAt) {
                this.#asc.add(thread);
                this.#desc.add(thread);
            }
            this.#byId.set(id, thread);
            return true;
        });
    }
    /** Like .upsert(), except it won't update if a thread by this ID already exists. */ // TODO Consider renaming this to just .upsert(). I'm not sure if we really
    // TODO need the raw .upsert(). Would be nice if this behavior was the default.
    upsertIfNewer(thread) {
        const existing = this.get(thread.id);
        if (!existing || thread.updatedAt >= existing.updatedAt) {
            this.upsert(thread);
        }
    }
    applyDelta(newThreads, deletedThreads) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            for (const thread of newThreads){
                this.upsertIfNewer(thread);
            }
            for (const { id, deletedAt } of deletedThreads){
                const existing = this.getEvenIfDeleted(id);
                if (!existing) continue;
                this.delete(id, deletedAt);
            }
        });
    }
    /**
   * Marks a thread as deleted. It will no longer pop up in .findMany()
   * queries, but it can still be accessed via `.getEvenIfDeleted()`.
   */ delete(threadId, deletedAt) {
        const existing = this.#byId.get(threadId);
        if (existing && !existing.deletedAt) {
            this.upsert({
                ...existing,
                deletedAt,
                updatedAt: deletedAt
            });
        }
    }
    /**
   * Returns all threads matching a given roomId and query. If roomId is not
   * specified, it will return all threads matching the query, across all
   * rooms.
   *
   * Returns the results in the requested order. Please note:
   *   'asc'  means by createdAt ASC
   *   'desc' means by updatedAt DESC
   *
   * Will never return deleted threads in the result.
   */ findMany(roomId, query, direction) {
        const index = direction === "desc" ? this.#desc : this.#asc;
        const crit = [];
        if (roomId !== void 0) {
            crit.push((t)=>t.roomId === roomId);
        }
        crit.push(makeThreadsFilter(query));
        return Array.from(index.filter((t)=>crit.every((pred)=>pred(t))));
    }
};
// src/umbrella-store.ts
function makeRoomThreadsQueryKey(roomId, query) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
        roomId,
        query ?? {}
    ]);
}
function makeUserThreadsQueryKey(query) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(query ?? {});
}
function usify(promise) {
    if ("status" in promise) {
        return promise;
    }
    const usable = promise;
    usable.status = "pending";
    usable.then((value)=>{
        usable.status = "fulfilled";
        usable.value = value;
    }, (err)=>{
        usable.status = "rejected";
        usable.reason = err;
    });
    return usable;
}
var noop2 = Promise.resolve();
var PaginatedResource = class {
    #signal;
    signal;
    #fetchPage;
    #pendingFetchMore;
    constructor(fetchPage){
        this.#signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"](ASYNC_LOADING);
        this.#fetchPage = fetchPage;
        this.#pendingFetchMore = null;
        this.signal = this.#signal.asReadonly();
        autobind(this);
    }
    get() {
        return this.#signal.get();
    }
    #patch(patch) {
        const state = this.#signal.get();
        if (state.data === void 0) return;
        this.#signal.set(ASYNC_OK({
            ...state.data,
            ...patch
        }));
    }
    async #fetchMore() {
        const state = this.#signal.get();
        if (!state.data?.cursor || state.data.isFetchingMore) {
            return;
        }
        this.#patch({
            isFetchingMore: true
        });
        try {
            const nextCursor = await this.#fetchPage(state.data.cursor);
            this.#patch({
                cursor: nextCursor,
                hasFetchedAll: nextCursor === null,
                fetchMoreError: void 0,
                isFetchingMore: false
            });
        } catch (err) {
            this.#patch({
                isFetchingMore: false,
                fetchMoreError: err
            });
        }
    }
    fetchMore() {
        const state = this.#signal.get();
        if (!state.data?.cursor) return noop2;
        if (!this.#pendingFetchMore) {
            this.#pendingFetchMore = this.#fetchMore().finally(()=>{
                this.#pendingFetchMore = null;
            });
        }
        return this.#pendingFetchMore;
    }
    #cachedPromise = null;
    waitUntilLoaded() {
        if (this.#cachedPromise) {
            return this.#cachedPromise;
        }
        const initialPageFetch$ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["autoRetry"])(()=>this.#fetchPage(/* cursor */ void 0), 5, [
            5e3,
            5e3,
            1e4,
            15e3
        ]);
        const promise = usify(initialPageFetch$);
        promise.then((cursor)=>{
            this.#signal.set(ASYNC_OK({
                cursor,
                hasFetchedAll: cursor === null,
                isFetchingMore: false,
                fetchMoreError: void 0,
                fetchMore: this.fetchMore
            }));
        }, (err)=>{
            this.#signal.set(ASYNC_ERR(err));
            setTimeout(()=>{
                this.#cachedPromise = null;
                this.#signal.set(ASYNC_LOADING);
            }, 5e3);
        });
        this.#cachedPromise = promise;
        return this.#cachedPromise;
    }
};
var SinglePageResource = class {
    #signal;
    signal;
    #fetchPage;
    constructor(fetchPage){
        this.#signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"](ASYNC_LOADING);
        this.signal = this.#signal.asReadonly();
        this.#fetchPage = fetchPage;
        autobind(this);
    }
    get() {
        return this.#signal.get();
    }
    #cachedPromise = null;
    waitUntilLoaded() {
        if (this.#cachedPromise) {
            return this.#cachedPromise;
        }
        const initialFetcher$ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["autoRetry"])(()=>this.#fetchPage(), 5, [
            5e3,
            5e3,
            1e4,
            15e3
        ]);
        const promise = usify(initialFetcher$);
        promise.then(()=>{
            this.#signal.set(ASYNC_OK(void 0));
        }, (err)=>{
            this.#signal.set(ASYNC_ERR(err));
            setTimeout(()=>{
                this.#cachedPromise = null;
                this.#signal.set(ASYNC_LOADING);
            }, 5e3);
        });
        this.#cachedPromise = promise;
        return promise;
    }
};
function createStore_forNotifications() {
    const signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](/* @__PURE__ */ new Map());
    function markRead(notificationId, readAt) {
        signal.mutate((lut)=>{
            const existing = lut.get(notificationId);
            if (!existing) {
                return false;
            }
            lut.set(notificationId, {
                ...existing,
                readAt
            });
            return true;
        });
    }
    function markAllRead(readAt) {
        signal.mutate((lut)=>{
            for (const n of lut.values()){
                n.readAt = readAt;
            }
        });
    }
    function deleteOne(inboxNotificationId) {
        signal.mutate((lut)=>lut.delete(inboxNotificationId));
    }
    function clear() {
        signal.mutate((lut)=>lut.clear());
    }
    function applyDelta(newNotifications, deletedNotifications) {
        signal.mutate((lut)=>{
            let mutated = false;
            for (const n of newNotifications){
                const existing = lut.get(n.id);
                if (existing) {
                    const result = compareInboxNotifications(existing, n);
                    if (result === 1) continue;
                }
                lut.set(n.id, n);
                mutated = true;
            }
            for (const n of deletedNotifications){
                lut.delete(n.id);
                mutated = true;
            }
            return mutated;
        });
    }
    function updateAssociatedNotification(newComment) {
        signal.mutate((lut)=>{
            const existing = find(lut.values(), (notification)=>notification.kind === "thread" && notification.threadId === newComment.threadId);
            if (!existing) return false;
            lut.set(existing.id, {
                ...existing,
                notifiedAt: newComment.createdAt,
                readAt: newComment.createdAt
            });
            return true;
        });
    }
    function upsert(notification) {
        signal.mutate((lut)=>{
            lut.set(notification.id, notification);
        });
    }
    return {
        signal: signal.asReadonly(),
        // Mutations
        markAllRead,
        markRead,
        delete: deleteOne,
        applyDelta,
        clear,
        updateAssociatedNotification,
        upsert
    };
}
function createStore_forRoomNotificationSettings(updates) {
    const baseSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](/* @__PURE__ */ new Map());
    function update(roomId, settings) {
        baseSignal.mutate((lut)=>{
            lut.set(roomId, settings);
        });
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(baseSignal, updates, (base, updates2)=>applyOptimisticUpdates_forSettings(base, updates2)),
        // Mutations
        update
    };
}
function createStore_forHistoryVersions() {
    const baseSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"](()=>/* @__PURE__ */ new Map()));
    function update(roomId, versions) {
        baseSignal.mutate((lut)=>{
            const versionsById = lut.getOrCreate(roomId);
            for (const version of versions){
                versionsById.set(version.id, version);
            }
        });
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(baseSignal, (hv)=>Object.fromEntries([
                ...hv
            ].map(([roomId, versions])=>[
                    roomId,
                    Object.fromEntries(versions)
                ]))),
        // Mutations
        update
    };
}
function createStore_forPermissionHints() {
    const signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"](()=>/* @__PURE__ */ new Set()));
    function update(newHints) {
        signal.mutate((lut)=>{
            for (const [roomId, newPermissions] of Object.entries(newHints)){
                const existing = lut.getOrCreate(roomId);
                for (const permission of newPermissions){
                    existing.add(permission);
                }
            }
        });
    }
    return {
        signal: signal.asReadonly(),
        // Mutations
        update
    };
}
function createStore_forOptimistic(client) {
    const signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"]([]);
    const syncSource = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].createSyncSource();
    signal.subscribe(()=>syncSource.setSyncStatus(signal.get().length > 0 ? "synchronizing" : "synchronized"));
    function add(optimisticUpdate) {
        const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nanoid"])();
        const newUpdate = {
            ...optimisticUpdate,
            id
        };
        signal.set((state)=>[
                ...state,
                newUpdate
            ]);
        return id;
    }
    function remove(optimisticId) {
        signal.set((state)=>state.filter((ou)=>ou.id !== optimisticId));
    }
    return {
        signal: signal.asReadonly(),
        // Mutations
        add,
        remove
    };
}
var UmbrellaStore = class {
    #client;
    //
    // Internally, the UmbrellaStore keeps track of a few source signals that can
    // be set and mutated individually. When any of those are mutated then the
    // clean "external state" is recomputed.
    //
    //   Mutate inputs...                                             ...observe clean/consistent output!
    //
    //            .-> Base ThreadDB ---------+                 +----> Clean threads by ID       (Part 1)
    //           /                           |                 |
    //   mutate ----> Base Notifications --+ |                 | +--> Clean notifications       (Part 1)
    //          \                          | |                 | |    & notifications by ID
    //         | \                         | |      Apply      | |
    //         |   `-> OptimisticUpdates --+--+--> Optimistic --+-+--> Notification Settings    (Part 2)
    //          \                          |        Updates       |
    //           `------- etc etc ---------+                      +--> History Versions         (Part 3)
    //                       ^
    //                       |
    //                       |                        ^                  ^
    //                    Signal                      |                  |
    //                      or                   DerivedSignal      DerivedSignals
    //                  MutableSignal
    //
    //
    // Input signals.
    // (Can be mutated directly.)
    //
    // XXX_vincent Now that we have createStore_forX, we should probably also change
    // `threads` to this pattern, ie create a createStore_forThreads helper as
    // well. It almost works like that already anyway!
    threads;
    // Exposes its signal under `.signal` prop
    notifications;
    roomNotificationSettings;
    // prettier-ignore
    historyVersions;
    permissionHints;
    optimisticUpdates;
    //
    // Output signals.
    // (Readonly, clean, consistent. With optimistic updates applied.)
    //
    // Note that the output of threadifications signal is the same as the ones for
    // threads and notifications separately, but the threadifications signal will
    // be updated whenever either of them change.
    //
    outputs;
    // Notifications
    #notificationsLastRequestedAt = null;
    // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.
    #notificationsPaginationState;
    // Room Threads
    #roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
    // User Threads
    #userThreadsLastRequestedAt = null;
    // Room versions
    #roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
    constructor(client){
        this.#client = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].as();
        this.optimisticUpdates = createStore_forOptimistic(this.#client);
        this.permissionHints = createStore_forPermissionHints();
        this.#notificationsPaginationState = new PaginatedResource(async (cursor)=>{
            const result = await this.#client.getInboxNotifications({
                cursor
            });
            this.updateThreadifications(result.threads, result.inboxNotifications);
            if (this.#notificationsLastRequestedAt === null) {
                this.#notificationsLastRequestedAt = result.requestedAt;
            }
            const nextCursor = result.nextCursor;
            return nextCursor;
        });
        this.threads = new ThreadDB();
        this.notifications = createStore_forNotifications();
        this.roomNotificationSettings = createStore_forRoomNotificationSettings(this.optimisticUpdates.signal);
        this.historyVersions = createStore_forHistoryVersions();
        const threadifications = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(this.threads.signal, this.notifications.signal, this.optimisticUpdates.signal, (ts, ns, updates)=>applyOptimisticUpdates_forThreadifications(ts, ns, updates));
        const threads = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(threadifications, (s)=>s.threadsDB);
        const notifications = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(threadifications, (s)=>({
                sortedNotifications: s.sortedNotifications,
                notificationsById: s.notificationsById
            }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
        const loadingUserThreads = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>{
            const query = JSON.parse(queryKey);
            const resource = new PaginatedResource(async (cursor)=>{
                const result = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getUserThreads_experimental({
                    cursor,
                    query
                });
                this.updateThreadifications(result.threads, result.inboxNotifications);
                this.permissionHints.update(result.permissionHints);
                if (this.#userThreadsLastRequestedAt === null) {
                    this.#userThreadsLastRequestedAt = result.requestedAt;
                }
                return result.nextCursor;
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                const threads2 = this.outputs.threads.get().findMany(void 0, // Do _not_ filter by roomId
                query ?? {}, "desc");
                const page = result.data;
                return {
                    isLoading: false,
                    threads: threads2,
                    hasFetchedAll: page.hasFetchedAll,
                    isFetchingMore: page.isFetchingMore,
                    fetchMoreError: page.fetchMoreError,
                    fetchMore: page.fetchMore
                };
            }, shallow2);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const loadingRoomThreads = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>{
            const [roomId, query] = JSON.parse(queryKey);
            const resource = new PaginatedResource(async (cursor)=>{
                const result = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getThreads({
                    roomId,
                    cursor,
                    query
                });
                this.updateThreadifications(result.threads, result.inboxNotifications);
                this.permissionHints.update(result.permissionHints);
                const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
                if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
                    this.#roomThreadsLastRequestedAtByRoom.set(roomId, result.requestedAt);
                }
                return result.nextCursor;
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                const threads2 = this.outputs.threads.get().findMany(roomId, query ?? {}, "asc");
                const page = result.data;
                return {
                    isLoading: false,
                    threads: threads2,
                    hasFetchedAll: page.hasFetchedAll,
                    isFetchingMore: page.isFetchingMore,
                    fetchMoreError: page.fetchMoreError,
                    fetchMore: page.fetchMore
                };
            }, shallow2);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const loadingNotifications = {
            signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const resource = this.#notificationsPaginationState;
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                const page = result.data;
                return {
                    isLoading: false,
                    inboxNotifications: this.outputs.notifications.get().sortedNotifications,
                    hasFetchedAll: page.hasFetchedAll,
                    isFetchingMore: page.isFetchingMore,
                    fetchMoreError: page.fetchMoreError,
                    fetchMore: page.fetchMore
                };
            }),
            waitUntilLoaded: this.#notificationsPaginationState.waitUntilLoaded
        };
        const settingsByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>{
            const resource = new SinglePageResource(async ()=>{
                const room = this.#client.getRoom(roomId);
                if (room === null) {
                    throw new Error(`Room '${roomId}' is not available on client`);
                }
                const result = await room.getNotificationSettings();
                this.roomNotificationSettings.update(roomId, result);
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                } else {
                    return ASYNC_OK("settings", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.roomNotificationSettings.signal.get()[roomId]));
                }
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const versionsByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>{
            const resource = new SinglePageResource(async ()=>{
                const room = this.#client.getRoom(roomId);
                if (room === null) {
                    throw new Error(`Room '${roomId}' is not available on client`);
                }
                const result = await room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].listTextVersions();
                this.historyVersions.update(roomId, result.versions);
                const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
                if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
                    this.#roomVersionsLastRequestedAtByRoom.set(roomId, result.requestedAt);
                }
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                } else {
                    return ASYNC_OK("versions", Object.values(this.historyVersions.signal.get()[roomId] ?? {}));
                }
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        this.outputs = {
            threadifications,
            threads,
            loadingRoomThreads,
            loadingUserThreads,
            notifications,
            loadingNotifications,
            settingsByRoomId,
            versionsByRoomId
        };
        autobind(this);
    }
    /**
   * Updates an existing inbox notification with a new value, replacing the
   * corresponding optimistic update.
   *
   * This will not update anything if the inbox notification ID isn't found.
   */ markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.markRead(inboxNotificationId, readAt);
        });
    }
    markAllInboxNotificationsRead(optimisticId, readAt) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.markAllRead(readAt);
        });
    }
    /**
   * Deletes an existing inbox notification, replacing the corresponding
   * optimistic update.
   */ deleteInboxNotification(inboxNotificationId, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.delete(inboxNotificationId);
        });
    }
    /**
   * Deletes *all* inbox notifications, replacing the corresponding optimistic
   * update.
   */ deleteAllInboxNotifications(optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.clear();
        });
    }
    /**
   * Creates an new thread, replacing the corresponding optimistic update.
   */ createThread(optimisticId, thread) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.threads.upsert(thread);
        });
    }
    /**
   * Updates an existing thread with a new value, replacing the corresponding
   * optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted; or
   * - The thread ID was updated more recently than the optimistic update's
   *   timestamp (if given)
   */ #updateThread(threadId, optimisticId, callback, updatedAt) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            if (optimisticId !== null) {
                this.optimisticUpdates.remove(optimisticId);
            }
            const db = this.threads;
            const existing = db.get(threadId);
            if (!existing) return;
            if (!!updatedAt && existing.updatedAt > updatedAt) return;
            db.upsert(callback(existing));
        });
    }
    patchThread(threadId, optimisticId, patch, updatedAt) {
        return this.#updateThread(threadId, optimisticId, (thread)=>({
                ...thread,
                ...compactObject(patch)
            }), updatedAt);
    }
    addReaction(threadId, optimisticId, commentId, reaction, createdAt) {
        this.#updateThread(threadId, optimisticId, (thread)=>applyAddReaction(thread, commentId, reaction), createdAt);
    }
    removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {
        this.#updateThread(threadId, optimisticId, (thread)=>applyRemoveReaction(thread, commentId, emoji, userId, removedAt), removedAt);
    }
    /**
   * Soft-deletes an existing thread by setting its `deletedAt` value,
   * replacing the corresponding optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted
   */ deleteThread(threadId, optimisticId) {
        return this.#updateThread(threadId, optimisticId, // A deletion is actually an update of the deletedAt property internally
        (thread)=>({
                ...thread,
                updatedAt: /* @__PURE__ */ new Date(),
                deletedAt: /* @__PURE__ */ new Date()
            }));
    }
    /**
   * Creates an existing comment and ensures the associated notification is
   * updated correctly, replacing the corresponding optimistic update.
   */ createComment(newComment, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            const existingThread = this.threads.get(newComment.threadId);
            if (!existingThread) {
                return;
            }
            this.threads.upsert(applyUpsertComment(existingThread, newComment));
            this.notifications.updateAssociatedNotification(newComment);
        });
    }
    editComment(threadId, optimisticId, editedComment) {
        return this.#updateThread(threadId, optimisticId, (thread)=>applyUpsertComment(thread, editedComment));
    }
    deleteComment(threadId, optimisticId, commentId, deletedAt) {
        return this.#updateThread(threadId, optimisticId, (thread)=>applyDeleteComment(thread, commentId, deletedAt), deletedAt);
    }
    updateThreadifications(threads, notifications, deletedThreads = [], deletedNotifications = []) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.threads.applyDelta(threads, deletedThreads);
            this.notifications.applyDelta(notifications, deletedNotifications);
        });
    }
    /**
   * Updates existing notification setting for a room with a new value,
   * replacing the corresponding optimistic update.
   */ updateRoomNotificationSettings(roomId, optimisticId, settings) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.roomNotificationSettings.update(roomId, settings);
        });
    }
    async fetchNotificationsDeltaUpdate(signal) {
        const lastRequestedAt = this.#notificationsLastRequestedAt;
        if (lastRequestedAt === null) {
            return;
        }
        const result = await this.#client.getInboxNotificationsSince({
            since: lastRequestedAt,
            signal
        });
        if (lastRequestedAt < result.requestedAt) {
            this.#notificationsLastRequestedAt = result.requestedAt;
        }
        this.updateThreadifications(result.threads.updated, result.inboxNotifications.updated, result.threads.deleted, result.inboxNotifications.deleted);
    }
    async fetchRoomThreadsDeltaUpdate(roomId, signal) {
        const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
        if (lastRequestedAt === void 0) {
            return;
        }
        const updates = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getThreadsSince({
            roomId,
            since: lastRequestedAt,
            signal
        });
        this.updateThreadifications(updates.threads.updated, updates.inboxNotifications.updated, updates.threads.deleted, updates.inboxNotifications.deleted);
        this.permissionHints.update(updates.permissionHints);
        if (lastRequestedAt < updates.requestedAt) {
            this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
        }
    }
    async fetchUserThreadsDeltaUpdate(signal) {
        const lastRequestedAt = this.#userThreadsLastRequestedAt;
        if (lastRequestedAt === null) {
            return;
        }
        const result = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getUserThreadsSince_experimental({
            since: lastRequestedAt,
            signal
        });
        if (lastRequestedAt < result.requestedAt) {
            this.#notificationsLastRequestedAt = result.requestedAt;
        }
        this.updateThreadifications(result.threads.updated, result.inboxNotifications.updated, result.threads.deleted, result.inboxNotifications.deleted);
        this.permissionHints.update(result.permissionHints);
    }
    async fetchRoomVersionsDeltaUpdate(roomId, signal) {
        const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
        if (lastRequestedAt === void 0) {
            return;
        }
        const room = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.#client.getRoom(roomId), `Room with id ${roomId} is not available on client`);
        const updates = await room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].listTextVersionsSince({
            since: lastRequestedAt,
            signal
        });
        this.historyVersions.update(roomId, updates.versions);
        if (lastRequestedAt < updates.requestedAt) {
            this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
        }
    }
    async refreshRoomNotificationSettings(roomId, signal) {
        const room = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.#client.getRoom(roomId), `Room with id ${roomId} is not available on client`);
        const result = await room.getNotificationSettings({
            signal
        });
        this.roomNotificationSettings.update(roomId, result);
    }
};
function applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {
    const threadsDB = baseThreadsDB.clone();
    let notificationsById = Object.fromEntries(notificationsLUT);
    for (const optimisticUpdate of optimisticUpdates){
        switch(optimisticUpdate.type){
            case "create-thread":
                {
                    threadsDB.upsert(optimisticUpdate.thread);
                    break;
                }
            case "edit-thread-metadata":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    if (thread.updatedAt > optimisticUpdate.updatedAt) {
                        break;
                    }
                    threadsDB.upsert({
                        ...thread,
                        updatedAt: optimisticUpdate.updatedAt,
                        metadata: {
                            ...thread.metadata,
                            ...optimisticUpdate.metadata
                        }
                    });
                    break;
                }
            case "mark-thread-as-resolved":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert({
                        ...thread,
                        resolved: true
                    });
                    break;
                }
            case "mark-thread-as-unresolved":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert({
                        ...thread,
                        resolved: false
                    });
                    break;
                }
            case "create-comment":
                {
                    const thread = threadsDB.get(optimisticUpdate.comment.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
                    const inboxNotification = Object.values(notificationsById).find((notification)=>notification.kind === "thread" && notification.threadId === thread.id);
                    if (inboxNotification === void 0) {
                        break;
                    }
                    notificationsById[inboxNotification.id] = {
                        ...inboxNotification,
                        notifiedAt: optimisticUpdate.comment.createdAt,
                        readAt: optimisticUpdate.comment.createdAt
                    };
                    break;
                }
            case "edit-comment":
                {
                    const thread = threadsDB.get(optimisticUpdate.comment.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
                    break;
                }
            case "delete-comment":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyDeleteComment(thread, optimisticUpdate.commentId, optimisticUpdate.deletedAt));
                    break;
                }
            case "delete-thread":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert({
                        ...thread,
                        deletedAt: optimisticUpdate.deletedAt,
                        updatedAt: optimisticUpdate.deletedAt,
                        comments: []
                    });
                    break;
                }
            case "add-reaction":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyAddReaction(thread, optimisticUpdate.commentId, optimisticUpdate.reaction));
                    break;
                }
            case "remove-reaction":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyRemoveReaction(thread, optimisticUpdate.commentId, optimisticUpdate.emoji, optimisticUpdate.userId, optimisticUpdate.removedAt));
                    break;
                }
            case "mark-inbox-notification-as-read":
                {
                    const ibn = notificationsById[optimisticUpdate.inboxNotificationId];
                    if (ibn === void 0) {
                        break;
                    }
                    notificationsById[optimisticUpdate.inboxNotificationId] = {
                        ...ibn,
                        readAt: optimisticUpdate.readAt
                    };
                    break;
                }
            case "mark-all-inbox-notifications-as-read":
                {
                    for(const id in notificationsById){
                        const ibn = notificationsById[id];
                        if (ibn === void 0) {
                            break;
                        }
                        notificationsById[id] = {
                            ...ibn,
                            readAt: optimisticUpdate.readAt
                        };
                    }
                    break;
                }
            case "delete-inbox-notification":
                {
                    delete notificationsById[optimisticUpdate.inboxNotificationId];
                    break;
                }
            case "delete-all-inbox-notifications":
                {
                    notificationsById = {};
                    break;
                }
        }
    }
    const sortedNotifications = // Sort so that the most recent notifications are first
    Object.values(notificationsById).filter((ibn)=>ibn.kind === "thread" ? threadsDB.get(ibn.threadId) !== void 0 : true).sort((a, b)=>b.notifiedAt.getTime() - a.notifiedAt.getTime());
    return {
        sortedNotifications,
        notificationsById,
        threadsDB
    };
}
function applyOptimisticUpdates_forSettings(settingsLUT, optimisticUpdates) {
    const settingsByRoomId = Object.fromEntries(settingsLUT);
    for (const optimisticUpdate of optimisticUpdates){
        switch(optimisticUpdate.type){
            case "update-notification-settings":
                {
                    const settings = settingsByRoomId[optimisticUpdate.roomId];
                    if (settings === void 0) {
                        break;
                    }
                    settingsByRoomId[optimisticUpdate.roomId] = {
                        ...settings,
                        ...optimisticUpdate.settings
                    };
                }
        }
    }
    return settingsByRoomId;
}
function compareInboxNotifications(inboxNotificationA, inboxNotificationB) {
    if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {
        return 1;
    } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {
        return -1;
    }
    if (inboxNotificationA.readAt && inboxNotificationB.readAt) {
        return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;
    } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {
        return inboxNotificationA.readAt ? 1 : -1;
    }
    return 0;
}
function applyUpsertComment(thread, comment) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    if (comment.threadId !== thread.id) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Comment ${comment.id} does not belong to thread ${thread.id}`);
        return thread;
    }
    const existingComment = thread.comments.find((existingComment2)=>existingComment2.id === comment.id);
    if (existingComment === void 0) {
        const updatedAt = new Date(Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime()));
        const updatedThread = {
            ...thread,
            updatedAt,
            comments: [
                ...thread.comments,
                comment
            ]
        };
        return updatedThread;
    }
    if (existingComment.deletedAt !== void 0) {
        return thread;
    }
    if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {
        const updatedComments = thread.comments.map((existingComment2)=>existingComment2.id === comment.id ? comment : existingComment2);
        const updatedThread = {
            ...thread,
            updatedAt: new Date(Math.max(thread.updatedAt.getTime(), comment.editedAt?.getTime() || comment.createdAt.getTime())),
            comments: updatedComments
        };
        return updatedThread;
    }
    return thread;
}
function applyDeleteComment(thread, commentId, deletedAt) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    const existingComment = thread.comments.find((comment)=>comment.id === commentId);
    if (existingComment === void 0) {
        return thread;
    }
    if (existingComment.deletedAt !== void 0) {
        return thread;
    }
    const updatedComments = thread.comments.map((comment)=>comment.id === commentId ? {
            ...comment,
            deletedAt,
            // We optimistically remove the comment body and attachments when marking it as deleted
            body: void 0,
            attachments: []
        } : comment);
    if (updatedComments.every((comment)=>comment.deletedAt !== void 0)) {
        return {
            ...thread,
            deletedAt,
            updatedAt: deletedAt
        };
    }
    return {
        ...thread,
        updatedAt: deletedAt,
        comments: updatedComments
    };
}
function applyAddReaction(thread, commentId, reaction) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    const existingComment = thread.comments.find((comment)=>comment.id === commentId);
    if (existingComment === void 0) {
        return thread;
    }
    if (existingComment.deletedAt !== void 0) {
        return thread;
    }
    const updatedComments = thread.comments.map((comment)=>comment.id === commentId ? {
            ...comment,
            reactions: upsertReaction(comment.reactions, reaction)
        } : comment);
    return {
        ...thread,
        updatedAt: new Date(Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())),
        comments: updatedComments
    };
}
function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    const existingComment = thread.comments.find((comment)=>comment.id === commentId);
    if (existingComment === void 0) {
        return thread;
    }
    if (existingComment.deletedAt !== void 0) {
        return thread;
    }
    const updatedComments = thread.comments.map((comment)=>comment.id === commentId ? {
            ...comment,
            reactions: comment.reactions.map((reaction)=>reaction.emoji === emoji ? {
                    ...reaction,
                    users: reaction.users.filter((user)=>user.id !== userId)
                } : reaction).filter((reaction)=>reaction.users.length > 0)
        } : comment);
    return {
        ...thread,
        updatedAt: new Date(Math.max(removedAt.getTime(), thread.updatedAt.getTime())),
        comments: updatedComments
    };
}
function upsertReaction(reactions, reaction) {
    const existingReaction = reactions.find((existingReaction2)=>existingReaction2.emoji === reaction.emoji);
    if (existingReaction === void 0) {
        return [
            ...reactions,
            {
                emoji: reaction.emoji,
                createdAt: reaction.createdAt,
                users: [
                    {
                        id: reaction.userId
                    }
                ]
            }
        ];
    }
    if (existingReaction.users.some((user)=>user.id === reaction.userId) === false) {
        return reactions.map((existingReaction2)=>existingReaction2.emoji === reaction.emoji ? {
                ...existingReaction2,
                users: [
                    ...existingReaction2.users,
                    {
                        id: reaction.userId
                    }
                ]
            } : existingReaction2);
    }
    return reactions;
}
;
var ClientContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
function missingUserError(userId) {
    return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
    return new Error(`resolveRoomsInfo didn't return anything for room '${roomId}'`);
}
function identity2(x) {
    return x;
}
var _umbrellaStores = /* @__PURE__ */ new WeakMap();
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
function selectorFor_useUnreadInboxNotificationsCount(result) {
    if (!result.inboxNotifications) {
        return result;
    }
    return ASYNC_OK("count", count(result.inboxNotifications, (n)=>n.readAt === null || n.readAt < n.notifiedAt));
}
function selectorFor_useUser(state, userId) {
    if (state === void 0 || state?.isLoading) {
        return state ?? {
            isLoading: true
        };
    }
    if (state.error) {
        return state;
    }
    if (!state.data) {
        return {
            isLoading: false,
            error: missingUserError(userId)
        };
    }
    return {
        isLoading: false,
        user: state.data
    };
}
function selectorFor_useRoomInfo(state, roomId) {
    if (state === void 0 || state?.isLoading) {
        return state ?? {
            isLoading: true
        };
    }
    if (state.error) {
        return state;
    }
    if (!state.data) {
        return {
            isLoading: false,
            error: missingRoomInfoError(roomId)
        };
    }
    return {
        isLoading: false,
        info: state.data
    };
}
function getOrCreateContextBundle(client) {
    let bundle = _bundles.get(client);
    if (!bundle) {
        bundle = makeLiveblocksContextBundle(client);
        _bundles.set(client, bundle);
    }
    return bundle;
}
function getUmbrellaStoreForClient(client) {
    let store = _umbrellaStores.get(client);
    if (!store) {
        store = new UmbrellaStore(client);
        _umbrellaStores.set(client, store);
    }
    return store;
}
function getLiveblocksExtrasForClient(client) {
    let extras = _extras.get(client);
    if (!extras) {
        extras = makeLiveblocksExtrasForClient(client);
        _extras.set(client, extras);
    }
    return extras;
}
function makeLiveblocksExtrasForClient(client) {
    const store = getUmbrellaStoreForClient(client);
    const notificationsPoller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
        try {
            return await store.fetchNotificationsDeltaUpdate(signal);
        } catch (err) {
            console.warn(`Polling new inbox notifications failed: ${String(err)}`);
            throw err;
        }
    }, config.NOTIFICATIONS_POLL_INTERVAL, {
        maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME
    });
    const userThreadsPoller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
        try {
            return await store.fetchUserThreadsDeltaUpdate(signal);
        } catch (err) {
            console.warn(`Polling new user threads failed: ${String(err)}`);
            throw err;
        }
    }, config.USER_THREADS_POLL_INTERVAL, {
        maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME
    });
    return {
        store,
        notificationsPoller,
        userThreadsPoller
    };
}
function makeLiveblocksContextBundle(client) {
    const useInboxNotificationThread2 = (inboxNotificationId)=>useInboxNotificationThread_withClient(client, inboxNotificationId);
    const useMarkInboxNotificationAsRead2 = ()=>useMarkInboxNotificationAsRead_withClient(client);
    const useMarkAllInboxNotificationsAsRead2 = ()=>useMarkAllInboxNotificationsAsRead_withClient(client);
    const useDeleteInboxNotification2 = ()=>useDeleteInboxNotification_withClient(client);
    const useDeleteAllInboxNotifications2 = ()=>useDeleteAllInboxNotifications_withClient(client);
    function LiveblocksProvider2(props) {
        useEnsureNoLiveblocksProvider();
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(ClientContext.Provider, {
            value: client,
            children: props.children
        });
    }
    const shared = createSharedContext(client);
    const bundle = {
        LiveblocksProvider: LiveblocksProvider2,
        useInboxNotifications: ()=>useInboxNotifications_withClient(client, identity2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]),
        useUnreadInboxNotificationsCount: ()=>useUnreadInboxNotificationsCount_withClient(client),
        useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
        useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
        useDeleteInboxNotification: useDeleteInboxNotification2,
        useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
        useInboxNotificationThread: useInboxNotificationThread2,
        useUserThreads_experimental,
        ...shared.classic,
        suspense: {
            LiveblocksProvider: LiveblocksProvider2,
            useInboxNotifications: ()=>useInboxNotificationsSuspense_withClient(client),
            useUnreadInboxNotificationsCount: ()=>useUnreadInboxNotificationsCountSuspense_withClient(client),
            useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
            useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
            useDeleteInboxNotification: useDeleteInboxNotification2,
            useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
            useInboxNotificationThread: useInboxNotificationThread2,
            useUserThreads_experimental: useUserThreadsSuspense_experimental,
            ...shared.suspense
        }
    };
    return bundle;
}
function useInboxNotifications_withClient(client, selector, isEqual) {
    const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useInboxNotifications_withClient.useEffect3": ()=>void store.outputs.loadingNotifications.waitUntilLoaded()
    }["useInboxNotifications_withClient.useEffect3"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useInboxNotifications_withClient.useEffect3": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useInboxNotifications_withClient.useEffect3": ()=>{
                    poller.dec();
                }
            })["useInboxNotifications_withClient.useEffect3"];
        }
    }["useInboxNotifications_withClient.useEffect3"], [
        poller
    ]);
    return useSignal(store.outputs.loadingNotifications.signal, selector, isEqual);
}
function useInboxNotificationsSuspense_withClient(client) {
    ensureNotServerSide();
    const store = getLiveblocksExtrasForClient(client).store;
    use(store.outputs.loadingNotifications.waitUntilLoaded());
    const result = useInboxNotifications_withClient(client, identity2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useUnreadInboxNotificationsCount_withClient(client) {
    return useInboxNotifications_withClient(client, selectorFor_useUnreadInboxNotificationsCount, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useUnreadInboxNotificationsCountSuspense_withClient(client) {
    ensureNotServerSide();
    const store = getLiveblocksExtrasForClient(client).store;
    use(store.outputs.loadingNotifications.waitUntilLoaded());
    const result = useUnreadInboxNotificationsCount_withClient(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkInboxNotificationAsRead_withClient.useCallback2": (inboxNotificationId)=>{
            const { store } = getLiveblocksExtrasForClient(client);
            const readAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-inbox-notification-as-read",
                inboxNotificationId,
                readAt
            });
            client.markInboxNotificationAsRead(inboxNotificationId).then({
                "useMarkInboxNotificationAsRead_withClient.useCallback2": ()=>{
                    store.markInboxNotificationRead(inboxNotificationId, readAt, optimisticId);
                }
            }["useMarkInboxNotificationAsRead_withClient.useCallback2"], {
                "useMarkInboxNotificationAsRead_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError({
                        type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
                        inboxNotificationId
                    }, err);
                }
            }["useMarkInboxNotificationAsRead_withClient.useCallback2"]);
        }
    }["useMarkInboxNotificationAsRead_withClient.useCallback2"], [
        client
    ]);
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkAllInboxNotificationsAsRead_withClient.useCallback2": ()=>{
            const { store } = getLiveblocksExtrasForClient(client);
            const readAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-all-inbox-notifications-as-read",
                readAt
            });
            client.markAllInboxNotificationsAsRead().then({
                "useMarkAllInboxNotificationsAsRead_withClient.useCallback2": ()=>{
                    store.markAllInboxNotificationsRead(optimisticId, readAt);
                }
            }["useMarkAllInboxNotificationsAsRead_withClient.useCallback2"], {
                "useMarkAllInboxNotificationsAsRead_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError(// No roomId, threadId, commentId to include for this error
                    {
                        type: "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR"
                    }, err);
                }
            }["useMarkAllInboxNotificationsAsRead_withClient.useCallback2"]);
        }
    }["useMarkAllInboxNotificationsAsRead_withClient.useCallback2"], [
        client
    ]);
}
function useDeleteInboxNotification_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteInboxNotification_withClient.useCallback2": (inboxNotificationId)=>{
            const { store } = getLiveblocksExtrasForClient(client);
            const deletedAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-inbox-notification",
                inboxNotificationId,
                deletedAt
            });
            client.deleteInboxNotification(inboxNotificationId).then({
                "useDeleteInboxNotification_withClient.useCallback2": ()=>{
                    store.deleteInboxNotification(inboxNotificationId, optimisticId);
                }
            }["useDeleteInboxNotification_withClient.useCallback2"], {
                "useDeleteInboxNotification_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError({
                        type: "DELETE_INBOX_NOTIFICATION_ERROR",
                        inboxNotificationId
                    }, err);
                }
            }["useDeleteInboxNotification_withClient.useCallback2"]);
        }
    }["useDeleteInboxNotification_withClient.useCallback2"], [
        client
    ]);
}
function useDeleteAllInboxNotifications_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteAllInboxNotifications_withClient.useCallback2": ()=>{
            const { store } = getLiveblocksExtrasForClient(client);
            const deletedAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-all-inbox-notifications",
                deletedAt
            });
            client.deleteAllInboxNotifications().then({
                "useDeleteAllInboxNotifications_withClient.useCallback2": ()=>{
                    store.deleteAllInboxNotifications(optimisticId);
                }
            }["useDeleteAllInboxNotifications_withClient.useCallback2"], {
                "useDeleteAllInboxNotifications_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError({
                        type: "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR"
                    }, err);
                }
            }["useDeleteAllInboxNotifications_withClient.useCallback2"]);
        }
    }["useDeleteAllInboxNotifications_withClient.useCallback2"], [
        client
    ]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
    const { store } = getLiveblocksExtrasForClient(client);
    return useSignal(store.outputs.threadifications, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useInboxNotificationThread_withClient.useSignal.useCallback2": (state)=>{
            const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])(`Inbox notification with ID "${inboxNotificationId}" not found`);
            if (inboxNotification.kind !== "thread") {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])(`Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`);
            }
            const thread = state.threadsDB.get(inboxNotification.threadId) ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])(`Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`);
            return thread;
        }
    }["useInboxNotificationThread_withClient.useSignal.useCallback2"], [
        inboxNotificationId
    ]));
}
function useUser_withClient(client, userId) {
    const usersStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].usersStore;
    const getUserState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUser_withClient.useCallback2[getUserState]": ()=>usersStore.getItemState(userId)
    }["useUser_withClient.useCallback2[getUserState]"], [
        usersStore,
        userId
    ]);
    const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUser_withClient.useCallback2[selector]": (state)=>selectorFor_useUser(state, userId)
    }["useUser_withClient.useCallback2[selector]"], [
        userId
    ]);
    const result = useSyncExternalStoreWithSelector(usersStore.subscribe, getUserState, getUserState, selector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUser_withClient.useEffect3": ()=>void usersStore.enqueue(userId)
    }["useUser_withClient.useEffect3"]);
    return result;
}
function useUserSuspense_withClient(client, userId) {
    const usersStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].usersStore;
    const getUserState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUserSuspense_withClient.useCallback2[getUserState]": ()=>usersStore.getItemState(userId)
    }["useUserSuspense_withClient.useCallback2[getUserState]"], [
        usersStore,
        userId
    ]);
    const userState = getUserState();
    if (!userState || userState.isLoading) {
        throw usersStore.enqueue(userId);
    }
    if (userState.error) {
        throw userState.error;
    }
    if (!userState.data) {
        throw missingUserError(userId);
    }
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(usersStore.subscribe, getUserState, getUserState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state !== void 0, "Unexpected missing state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.isLoading, "Unexpected loading state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.error, "Unexpected error state");
    return {
        isLoading: false,
        user: state.data,
        error: void 0
    };
}
function useRoomInfo_withClient(client, roomId) {
    const roomsInfoStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].roomsInfoStore;
    const getRoomInfoState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomInfo_withClient.useCallback2[getRoomInfoState]": ()=>roomsInfoStore.getItemState(roomId)
    }["useRoomInfo_withClient.useCallback2[getRoomInfoState]"], [
        roomsInfoStore,
        roomId
    ]);
    const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomInfo_withClient.useCallback2[selector]": (state)=>selectorFor_useRoomInfo(state, roomId)
    }["useRoomInfo_withClient.useCallback2[selector]"], [
        roomId
    ]);
    const result = useSyncExternalStoreWithSelector(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState, selector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomInfo_withClient.useEffect3": ()=>void roomsInfoStore.enqueue(roomId)
    }["useRoomInfo_withClient.useEffect3"]);
    return result;
}
function useRoomInfoSuspense_withClient(client, roomId) {
    const roomsInfoStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].roomsInfoStore;
    const getRoomInfoState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomInfoSuspense_withClient.useCallback2[getRoomInfoState]": ()=>roomsInfoStore.getItemState(roomId)
    }["useRoomInfoSuspense_withClient.useCallback2[getRoomInfoState]"], [
        roomsInfoStore,
        roomId
    ]);
    const roomInfoState = getRoomInfoState();
    if (!roomInfoState || roomInfoState.isLoading) {
        throw roomsInfoStore.enqueue(roomId);
    }
    if (roomInfoState.error) {
        throw roomInfoState.error;
    }
    if (!roomInfoState.data) {
        throw missingRoomInfoError(roomId);
    }
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state !== void 0, "Unexpected missing state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.isLoading, "Unexpected loading state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.error, "Unexpected error state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state.data !== void 0, "Unexpected missing room info data");
    return {
        isLoading: false,
        info: state.data,
        error: void 0
    };
}
function createSharedContext(client) {
    const useClient2 = ()=>client;
    function useSyncStatus2(options) {
        return useSyncStatus_withClient(client, options);
    }
    return {
        classic: {
            useClient: useClient2,
            useUser: (userId)=>useUser_withClient(client, userId),
            useRoomInfo: (roomId)=>useRoomInfo_withClient(client, roomId),
            useIsInsideRoom,
            useErrorListener,
            useSyncStatus: useSyncStatus2
        },
        suspense: {
            useClient: useClient2,
            useUser: (userId)=>useUserSuspense_withClient(client, userId),
            useRoomInfo: (roomId)=>useRoomInfoSuspense_withClient(client, roomId),
            useIsInsideRoom,
            useErrorListener,
            useSyncStatus: useSyncStatus2
        }
    };
}
function useEnsureNoLiveblocksProvider(options) {
    const existing = useClientOrNull();
    if (!options?.allowNesting && existing !== null) {
        throw new Error("You cannot nest multiple LiveblocksProvider instances in the same React tree.");
    }
}
function useClientOrNull() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(ClientContext);
}
function useClient() {
    return useClientOrNull() ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])("LiveblocksProvider is missing from the React tree.");
}
function LiveblocksProviderWithClient(props) {
    useEnsureNoLiveblocksProvider(props);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(ClientContext.Provider, {
        value: props.client,
        children: props.children
    });
}
function LiveblocksProvider(props) {
    const { children, ...o } = props;
    const options = {
        publicApiKey: useInitial(o.publicApiKey),
        throttle: useInitial(o.throttle),
        lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
        backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
        polyfills: useInitial(o.polyfills),
        unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),
        unstable_streamData: useInitial(o.unstable_streamData),
        preventUnsavedChanges: useInitial(o.preventUnsavedChanges),
        authEndpoint: useInitialUnlessFunction(o.authEndpoint),
        resolveMentionSuggestions: useInitialUnlessFunction(o.resolveMentionSuggestions),
        resolveUsers: useInitialUnlessFunction(o.resolveUsers),
        resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
        baseUrl: useInitial(// @ts-expect-error - Hidden config options
        o.baseUrl),
        enableDebugLogging: useInitial(// @ts-expect-error - Hidden config options
        o.enableDebugLogging)
    };
    const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "LiveblocksProvider.useMemo2[client]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createClient"])(options)
    }["LiveblocksProvider.useMemo2[client]"], []);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(LiveblocksProviderWithClient, {
        client,
        children
    });
}
function createLiveblocksContext(client) {
    return getOrCreateContextBundle(client);
}
function useUserThreads_experimental(options = {}) {
    const client = useClient();
    const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);
    const queryKey = makeUserThreadsQueryKey(options.query);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUserThreads_experimental.useEffect3": ()=>void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()
    }["useUserThreads_experimental.useEffect3"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUserThreads_experimental.useEffect3": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useUserThreads_experimental.useEffect3": ()=>{
                    poller.dec();
                }
            })["useUserThreads_experimental.useEffect3"];
        }
    }["useUserThreads_experimental.useEffect3"], [
        poller
    ]);
    return useSignal(store.outputs.loadingUserThreads.getOrCreate(queryKey).signal);
}
function useUserThreadsSuspense_experimental(options = {}) {
    ensureNotServerSide();
    const client = useClient();
    const { store } = getLiveblocksExtrasForClient(client);
    const queryKey = makeUserThreadsQueryKey(options.query);
    use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());
    const result = useUserThreads_experimental(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useInboxNotifications() {
    return useInboxNotifications_withClient(useClient(), identity2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useInboxNotificationsSuspense() {
    return useInboxNotificationsSuspense_withClient(useClient());
}
function useInboxNotificationThread(inboxNotificationId) {
    return useInboxNotificationThread_withClient(useClient(), inboxNotificationId);
}
function useMarkAllInboxNotificationsAsRead() {
    return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
    return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
    return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
    return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount() {
    return useUnreadInboxNotificationsCount_withClient(useClient());
}
function useUnreadInboxNotificationsCountSuspense() {
    return useUnreadInboxNotificationsCountSuspense_withClient(useClient());
}
function useUser(userId) {
    const client = useClient();
    return useUser_withClient(client, userId);
}
function useUserSuspense(userId) {
    const client = useClient();
    return useUserSuspense_withClient(client, userId);
}
function useRoomInfo(roomId) {
    return useRoomInfo_withClient(useClient(), roomId);
}
function useRoomInfoSuspense(roomId) {
    return useRoomInfoSuspense_withClient(useClient(), roomId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserSuspense = useUserSuspense;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;
function useSyncStatus_withClient(client, options) {
    const smooth = useInitial(options?.smooth ?? false);
    if (smooth) {
        return useSyncStatusSmooth_withClient(client);
    } else {
        return useSyncStatusImmediate_withClient(client);
    }
}
function useSyncStatusImmediate_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(client.events.syncStatus.subscribe, client.getSyncStatus, client.getSyncStatus);
}
function useSyncStatusSmooth_withClient(client) {
    const getter = client.getSyncStatus;
    const [status, setStatus] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(getter);
    const oldStatus = useLatest(getter());
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncStatusSmooth_withClient.useEffect3": ()=>{
            let timeoutId;
            const unsub = client.events.syncStatus.subscribe({
                "useSyncStatusSmooth_withClient.useEffect3.unsub": ()=>{
                    const newStatus = getter();
                    if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
                        timeoutId = setTimeout({
                            "useSyncStatusSmooth_withClient.useEffect3.unsub": ()=>setStatus(newStatus)
                        }["useSyncStatusSmooth_withClient.useEffect3.unsub"], config.SMOOTH_DELAY);
                    } else {
                        clearTimeout(timeoutId);
                        setStatus(newStatus);
                    }
                }
            }["useSyncStatusSmooth_withClient.useEffect3.unsub"]);
            return ({
                "useSyncStatusSmooth_withClient.useEffect3": ()=>{
                    clearTimeout(timeoutId);
                    unsub();
                }
            })["useSyncStatusSmooth_withClient.useEffect3"];
        }
    }["useSyncStatusSmooth_withClient.useEffect3"], [
        client,
        getter,
        oldStatus
    ]);
    return status;
}
function useSyncStatus(options) {
    return useSyncStatus_withClient(useClient(), options);
}
function useErrorListener(callback) {
    const client = useClient();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useErrorListener.useEffect3": ()=>client.events.error.subscribe({
                "useErrorListener.useEffect3": (e)=>savedCallback.current(e)
            }["useErrorListener.useEffect3"])
    }["useErrorListener.useEffect3"], [
        client,
        savedCallback
    ]);
}
;
;
;
;
function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
    if (shouldScrollOnLoad === false) return;
    if (!state.threads) return;
    const isWindowDefined = typeof window !== "undefined";
    if (!isWindowDefined) return;
    const hash = window.location.hash;
    const commentId = hash.slice(1);
    if (!commentId.startsWith("cm_")) return;
    const comment = document.getElementById(commentId);
    if (comment === null) return;
    const comments = state.threads.flatMap((thread)=>thread.comments);
    const isCommentInThreads = comments.some((comment2)=>comment2.id === commentId);
    if (!isCommentInThreads) return;
    comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useScrollToCommentOnLoadEffect.useEffect4": ()=>{
            handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
        }
    }["useScrollToCommentOnLoadEffect.useEffect4"], // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [
        state.isLoading
    ]);
}
;
var noop3 = ()=>{};
var identity3 = (x)=>x;
var STABLE_EMPTY_LIST = Object.freeze([]);
function alwaysEmptyList() {
    return STABLE_EMPTY_LIST;
}
function alwaysNull() {
    return null;
}
function selectorFor_useOthersConnectionIds(others) {
    return others.map((user)=>user.connectionId);
}
function makeMutationContext(room) {
    const cannotUseUntil = "This mutation cannot be used until";
    const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
    const needsStorage = `${cannotUseUntil} storage has been loaded`;
    return {
        get storage () {
            const mutableRoot = room.getStorageSnapshot();
            if (mutableRoot === null) {
                throw new Error(needsStorage);
            }
            return mutableRoot;
        },
        get self () {
            const self = room.getSelf();
            if (self === null) {
                throw new Error(needsPresence);
            }
            return self;
        },
        get others () {
            const others = room.getOthers();
            if (room.getSelf() === null) {
                throw new Error(needsPresence);
            }
            return others;
        },
        setMyPresence: room.updatePresence
    };
}
function getCurrentUserId(client) {
    const userId = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].currentUserId.get();
    if (userId === void 0) {
        return "anonymous";
    }
    return userId;
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
    let bundle = _bundles2.get(client);
    if (!bundle) {
        bundle = makeRoomContextBundle(client);
        _bundles2.set(client, bundle);
    }
    return bundle;
}
function getRoomExtrasForClient(client) {
    let extras = _extras2.get(client);
    if (!extras) {
        extras = makeRoomExtrasForClient(client);
        _extras2.set(client, extras);
    }
    return extras;
}
function makeRoomExtrasForClient(client) {
    const store = getUmbrellaStoreForClient(client);
    function onMutationFailure(optimisticId, context, innerError) {
        store.optimisticUpdates.remove(optimisticId);
        if (innerError instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpError"]) {
            if (innerError.status === 403) {
                const detailedMessage = [
                    innerError.message,
                    innerError.details?.suggestion,
                    innerError.details?.docs
                ].filter(Boolean).join("\n");
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(detailedMessage);
            }
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError(context, innerError);
        } else {
            throw innerError;
        }
    }
    const threadsPollersByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
            try {
                return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);
                throw err;
            }
        }, config.ROOM_THREADS_POLL_INTERVAL, {
            maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME
        }));
    const versionsPollersByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
            try {
                return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);
                throw err;
            }
        }, config.HISTORY_VERSIONS_POLL_INTERVAL, {
            maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME
        }));
    const roomNotificationSettingsPollersByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
            try {
                return await store.refreshRoomNotificationSettings(roomId, signal);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`);
                throw err;
            }
        }, config.NOTIFICATION_SETTINGS_POLL_INTERVAL, {
            maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME
        }));
    return {
        store,
        onMutationFailure,
        getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(threadsPollersByRoomId),
        getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),
        getOrCreateNotificationsSettingsPollerForRoomId: roomNotificationSettingsPollersByRoomId.getOrCreate.bind(roomNotificationSettingsPollersByRoomId)
    };
}
function makeRoomContextBundle(client) {
    function RoomProvider_withImplicitLiveblocksProvider(props) {
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(LiveblocksProviderWithClient, {
            client,
            allowNesting: true,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RoomProvider, {
                ...props
            })
        });
    }
    const shared = createSharedContext(client);
    const bundle = {
        RoomContext,
        RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
        useRoom,
        useStatus,
        useStorageStatus,
        useBatch,
        useBroadcastEvent,
        useOthersListener,
        useLostConnectionListener,
        useEventListener,
        useHistory,
        useUndo,
        useRedo,
        useCanRedo,
        useCanUndo,
        useStorageRoot,
        useStorage,
        useSelf,
        useMyPresence,
        useUpdateMyPresence,
        useOthers,
        useOthersMapped,
        useOthersConnectionIds,
        useOther,
        useMutation,
        useThreads,
        useCreateThread,
        useDeleteThread,
        useEditThreadMetadata,
        useMarkThreadAsResolved,
        useMarkThreadAsUnresolved,
        useCreateComment,
        useEditComment,
        useDeleteComment,
        useAddReaction,
        useRemoveReaction,
        useMarkThreadAsRead,
        useThreadSubscription,
        useAttachmentUrl,
        useHistoryVersions,
        useHistoryVersionData,
        useRoomNotificationSettings,
        useUpdateRoomNotificationSettings,
        ...shared.classic,
        suspense: {
            RoomContext,
            RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
            useRoom,
            useStatus,
            useStorageStatus: useStorageStatusSuspense,
            useBatch,
            useBroadcastEvent,
            useOthersListener,
            useLostConnectionListener,
            useEventListener,
            useHistory,
            useUndo,
            useRedo,
            useCanRedo,
            useCanUndo,
            useStorageRoot,
            useStorage: useStorageSuspense,
            useSelf: useSelfSuspense,
            useMyPresence,
            useUpdateMyPresence,
            useOthers: useOthersSuspense,
            useOthersMapped: useOthersMappedSuspense,
            useOthersConnectionIds: useOthersConnectionIdsSuspense,
            useOther: useOtherSuspense,
            useMutation,
            useThreads: useThreadsSuspense,
            useCreateThread,
            useDeleteThread,
            useEditThreadMetadata,
            useMarkThreadAsResolved,
            useMarkThreadAsUnresolved,
            useCreateComment,
            useEditComment,
            useDeleteComment,
            useAddReaction,
            useRemoveReaction,
            useMarkThreadAsRead,
            useThreadSubscription,
            useAttachmentUrl: useAttachmentUrlSuspense,
            // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,
            useHistoryVersions: useHistoryVersionsSuspense,
            useRoomNotificationSettings: useRoomNotificationSettingsSuspense,
            useUpdateRoomNotificationSettings,
            ...shared.suspense
        }
    };
    return Object.defineProperty(bundle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"], {
        enumerable: false
    });
}
function RoomProvider(props) {
    const client = useClient();
    const [cache] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "RoomProvider.useState2": ()=>/* @__PURE__ */ new Map()
    }["RoomProvider.useState2"]);
    const stableEnterRoom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "RoomProvider.useCallback3[stableEnterRoom]": (roomId, options)=>{
            const cached = cache.get(roomId);
            if (cached) return cached;
            const rv = client.enterRoom(roomId, options);
            const origLeave = rv.leave;
            rv.leave = ({
                "RoomProvider.useCallback3[stableEnterRoom]": ()=>{
                    origLeave();
                    cache.delete(roomId);
                }
            })["RoomProvider.useCallback3[stableEnterRoom]"];
            cache.set(roomId, rv);
            return rv;
        }
    }["RoomProvider.useCallback3[stableEnterRoom]"], [
        client,
        cache
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RoomProviderInner, {
        ...props,
        stableEnterRoom
    });
}
function RoomProviderInner(props) {
    const client = useClient();
    const { id: roomId, stableEnterRoom } = props;
    if ("TURBOPACK compile-time truthy", 1) {
        if (!roomId) {
            throw new Error("RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required");
        }
        if (typeof roomId !== "string") {
            throw new Error("RoomProvider id property should be a string.");
        }
        const majorReactVersion = parseInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]) || 1;
        const requiredVersion = 18;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["errorIf"])(majorReactVersion < requiredVersion, `React ${requiredVersion} or higher is required (you\u2019re on ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]})`);
    }
    const frozenProps = useInitial({
        initialPresence: props.initialPresence,
        initialStorage: props.initialStorage,
        autoConnect: props.autoConnect ?? typeof window !== "undefined"
    });
    const [{ room }, setRoomLeavePair] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "RoomProviderInner.useState2": ()=>stableEnterRoom(roomId, {
                ...frozenProps,
                autoConnect: false
            })
    }["RoomProviderInner.useState2"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RoomProviderInner.useEffect5": ()=>{
            const { store } = getRoomExtrasForClient(client);
            async function handleCommentEvent(message) {
                if (message.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].THREAD_DELETED) {
                    store.deleteThread(message.threadId, null);
                    return;
                }
                const info = await room.getThread(message.threadId);
                if (!info.thread) {
                    store.deleteThread(message.threadId, null);
                    return;
                }
                const { thread, inboxNotification: maybeNotification } = info;
                const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);
                switch(message.type){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_EDITED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].THREAD_METADATA_UPDATED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].THREAD_UPDATED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_REACTION_ADDED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_REACTION_REMOVED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_DELETED:
                        if (!existingThread) break;
                        store.updateThreadifications([
                            thread
                        ], maybeNotification ? [
                            maybeNotification
                        ] : []);
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_CREATED:
                        store.updateThreadifications([
                            thread
                        ], maybeNotification ? [
                            maybeNotification
                        ] : []);
                        break;
                    default:
                        break;
                }
            }
            return room.events.comments.subscribe({
                "RoomProviderInner.useEffect5": (message)=>void handleCommentEvent(message)
            }["RoomProviderInner.useEffect5"]);
        }
    }["RoomProviderInner.useEffect5"], [
        client,
        room
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RoomProviderInner.useEffect5": ()=>{
            const pair = stableEnterRoom(roomId, frozenProps);
            setRoomLeavePair(pair);
            const { room: room2, leave } = pair;
            if (frozenProps.autoConnect) {
                room2.connect();
            }
            return ({
                "RoomProviderInner.useEffect5": ()=>{
                    leave();
                }
            })["RoomProviderInner.useEffect5"];
        }
    }["RoomProviderInner.useEffect5"], [
        roomId,
        frozenProps,
        stableEnterRoom
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RoomContext.Provider, {
        value: room,
        children: props.children
    });
}
function useRoom() {
    const room = useRoomOrNull();
    if (room === null) {
        throw new Error("RoomProvider is missing from the React tree.");
    }
    return room;
}
function useStatus() {
    const room = useRoom();
    const subscribe = room.events.status.subscribe;
    const getSnapshot = room.getStatus;
    const getServerSnapshot = room.getStatus;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getServerSnapshot);
}
function useReportTextEditor(editor, rootKey) {
    const isReported = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    const room = useRoom();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useReportTextEditor.useEffect5": ()=>{
            if (isReported.current) {
                return;
            }
            const unsubscribe = room.events.status.subscribe({
                "useReportTextEditor.useEffect5.unsubscribe": (status)=>{
                    if (status === "connected" && !isReported.current) {
                        isReported.current = true;
                        void room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].reportTextEditor(editor, rootKey);
                    }
                }
            }["useReportTextEditor.useEffect5.unsubscribe"]);
            return unsubscribe;
        }
    }["useReportTextEditor.useEffect5"], [
        room,
        editor,
        rootKey
    ]);
}
function useYjsProvider() {
    const room = useRoom();
    const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useYjsProvider.useCallback3[subscribe]": (onStoreChange)=>{
            return room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].yjsProviderDidChange.subscribe(onStoreChange);
        }
    }["useYjsProvider.useCallback3[subscribe]"], [
        room
    ]);
    const getSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useYjsProvider.useCallback3[getSnapshot]": ()=>{
            return room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].getYjsProvider();
        }
    }["useYjsProvider.useCallback3[getSnapshot]"], [
        room
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getSnapshot);
}
function useCreateTextMention() {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useCreateTextMention.useCallback3": (userId, mentionId)=>{
            room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].createTextMention(userId, mentionId).catch({
                "useCreateTextMention.useCallback3": (err)=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(`Cannot create text mention for user '${userId}' and mention '${mentionId}'`, err);
                }
            }["useCreateTextMention.useCallback3"]);
        }
    }["useCreateTextMention.useCallback3"], [
        room
    ]);
}
function useDeleteTextMention() {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteTextMention.useCallback3": (mentionId)=>{
            room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].deleteTextMention(mentionId).catch({
                "useDeleteTextMention.useCallback3": (err)=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(`Cannot delete text mention '${mentionId}'`, err);
                }
            }["useDeleteTextMention.useCallback3"]);
        }
    }["useDeleteTextMention.useCallback3"], [
        room
    ]);
}
function useResolveMentionSuggestions() {
    const client = useClient();
    return client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].resolveMentionSuggestions;
}
function useMentionSuggestionsCache() {
    const client = useClient();
    return client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].mentionSuggestionsCache;
}
function useStorageStatus(options) {
    const smooth = useInitial(options?.smooth ?? false);
    if (smooth) {
        return useStorageStatusSmooth();
    } else {
        return useStorageStatusImmediate();
    }
}
function useStorageStatusImmediate() {
    const room = useRoom();
    const subscribe = room.events.storageStatus.subscribe;
    const getSnapshot = room.getStorageStatus;
    const getServerSnapshot = room.getStorageStatus;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatusSmooth() {
    const room = useRoom();
    const [status, setStatus] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(room.getStorageStatus);
    const oldStatus = useLatest(room.getStorageStatus());
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useStorageStatusSmooth.useEffect5": ()=>{
            let timeoutId;
            const unsub = room.events.storageStatus.subscribe({
                "useStorageStatusSmooth.useEffect5.unsub": (newStatus)=>{
                    if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
                        timeoutId = setTimeout({
                            "useStorageStatusSmooth.useEffect5.unsub": ()=>setStatus(newStatus)
                        }["useStorageStatusSmooth.useEffect5.unsub"], config.SMOOTH_DELAY);
                    } else {
                        clearTimeout(timeoutId);
                        setStatus(newStatus);
                    }
                }
            }["useStorageStatusSmooth.useEffect5.unsub"]);
            return ({
                "useStorageStatusSmooth.useEffect5": ()=>{
                    clearTimeout(timeoutId);
                    unsub();
                }
            })["useStorageStatusSmooth.useEffect5"];
        }
    }["useStorageStatusSmooth.useEffect5"], [
        room,
        oldStatus
    ]);
    return status;
}
function useBatch() {
    return useRoom().batch;
}
function useBroadcastEvent() {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useBroadcastEvent.useCallback3": (event, options = {
            shouldQueueEventIfNotReady: false
        })=>{
            room.broadcastEvent(event, options);
        }
    }["useBroadcastEvent.useCallback3"], [
        room
    ]);
}
function useOthersListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useOthersListener.useEffect5": ()=>room.events.others.subscribe({
                "useOthersListener.useEffect5": (event)=>savedCallback.current(event)
            }["useOthersListener.useEffect5"])
    }["useOthersListener.useEffect5"], [
        room,
        savedCallback
    ]);
}
function useLostConnectionListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useLostConnectionListener.useEffect5": ()=>room.events.lostConnection.subscribe({
                "useLostConnectionListener.useEffect5": (event)=>savedCallback.current(event)
            }["useLostConnectionListener.useEffect5"])
    }["useLostConnectionListener.useEffect5"], [
        room,
        savedCallback
    ]);
}
function useEventListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useEventListener.useEffect5": ()=>{
            const listener = {
                "useEventListener.useEffect5.listener": (eventData)=>{
                    savedCallback.current(eventData);
                }
            }["useEventListener.useEffect5.listener"];
            return room.events.customEvent.subscribe(listener);
        }
    }["useEventListener.useEffect5"], [
        room,
        savedCallback
    ]);
}
function useHistory() {
    return useRoom().history;
}
function useUndo() {
    return useHistory().undo;
}
function useRedo() {
    return useHistory().redo;
}
function useCanUndo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canUndo = room.history.canUndo;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, canUndo, canUndo);
}
function useCanRedo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canRedo = room.history.canRedo;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.self.subscribe;
    const getSnapshot = room.getSelf;
    const selector = maybeSelector ?? identity3;
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useSelf.useCallback3[wrappedSelector]": (me)=>me !== null ? selector(me) : null
    }["useSelf.useCallback3[wrappedSelector]"], [
        selector
    ]);
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);
}
function useMyPresence() {
    const room = useRoom();
    const subscribe = room.events.myPresence.subscribe;
    const getSnapshot = room.getPresence;
    const presence = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getSnapshot);
    const setPresence = room.updatePresence;
    return [
        presence,
        setPresence
    ];
}
function useUpdateMyPresence() {
    return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.others.subscribe;
    const getSnapshot = room.getOthers;
    const getServerSnapshot = alwaysEmptyList;
    return useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector ?? identity3, isEqual);
}
function useOthersMapped(itemSelector, itemIsEqual) {
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOthersMapped.useCallback3[wrappedSelector]": (others)=>others.map({
                "useOthersMapped.useCallback3[wrappedSelector]": (other)=>[
                        other.connectionId,
                        itemSelector(other)
                    ]
            }["useOthersMapped.useCallback3[wrappedSelector]"])
    }["useOthersMapped.useCallback3[wrappedSelector]"], [
        itemSelector
    ]);
    const wrappedIsEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOthersMapped.useCallback3[wrappedIsEqual]": (a, b)=>{
            const eq = itemIsEqual ?? Object.is;
            return a.length === b.length && a.every({
                "useOthersMapped.useCallback3[wrappedIsEqual]": (atuple, index)=>{
                    const btuple = b[index];
                    return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
                }
            }["useOthersMapped.useCallback3[wrappedIsEqual]"]);
        }
    }["useOthersMapped.useCallback3[wrappedIsEqual]"], [
        itemIsEqual
    ]);
    return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
    return useOthers(selectorFor_useOthersConnectionIds, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOther.useCallback3[wrappedSelector]": (others)=>{
            const other2 = others.find({
                "useOther.useCallback3[wrappedSelector].other2": (other3)=>other3.connectionId === connectionId
            }["useOther.useCallback3[wrappedSelector].other2"]);
            return other2 !== void 0 ? selector(other2) : NOT_FOUND;
        }
    }["useOther.useCallback3[wrappedSelector]"], [
        connectionId,
        selector
    ]);
    const wrappedIsEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOther.useCallback3[wrappedIsEqual]": (prev, curr)=>{
            if (prev === NOT_FOUND || curr === NOT_FOUND) {
                return prev === curr;
            }
            const eq = isEqual ?? Object.is;
            return eq(prev, curr);
        }
    }["useOther.useCallback3[wrappedIsEqual]"], [
        isEqual
    ]);
    const other = useOthers(wrappedSelector, wrappedIsEqual);
    if (other === NOT_FOUND) {
        throw new Error(`No such other user with connection id ${connectionId} exists`);
    }
    return other;
}
function useMutableStorageRoot() {
    const room = useRoom();
    const subscribe = room.events.storageDidLoad.subscribeOnce;
    const getSnapshot = room.getStorageSnapshot;
    const getServerSnapshot = alwaysNull;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
    return [
        useMutableStorageRoot()
    ];
}
function useStorage(selector, isEqual) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useStorage.useCallback3[wrappedSelector]": (rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null
    }["useStorage.useCallback3[wrappedSelector]"], [
        selector
    ]);
    const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useStorage.useCallback3[subscribe]": (onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {
                isDeep: true
            }) : noop3
    }["useStorage.useCallback3[subscribe]"], [
        room,
        rootOrNull
    ]);
    const getSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useStorage.useCallback3[getSnapshot]": ()=>{
            if (rootOrNull === null) {
                return null;
            } else {
                const root = rootOrNull;
                const imm = root.toImmutable();
                return imm;
            }
        }
    }["useStorage.useCallback3[getSnapshot]"], [
        rootOrNull
    ]);
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);
}
function useMutation(callback, deps) {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useMutation.useMemo3": ()=>{
            return ({
                "useMutation.useMemo3": (...args)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    room.batch({
                        "useMutation.useMemo3": ()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
                            callback(makeMutationContext(room), ...args)
                    }["useMutation.useMemo3"])
            })["useMutation.useMemo3"];
        }
    }["useMutation.useMemo3"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        room,
        ...deps
    ]);
}
function useThreads(options = {}) {
    const { scrollOnLoad = true } = options;
    const client = useClient();
    const room = useRoom();
    const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);
    const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
    const poller = getOrCreateThreadsPollerForRoomId(room.id);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useThreads.useEffect5": ()=>void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()
    }["useThreads.useEffect5"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useThreads.useEffect5": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useThreads.useEffect5": ()=>poller.dec()
            })["useThreads.useEffect5"];
        }
    }["useThreads.useEffect5"], [
        poller
    ]);
    const result = useSignal(store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal);
    useScrollToCommentOnLoadEffect(scrollOnLoad, result);
    return result;
}
function useCreateThread() {
    return useCreateRoomThread(useRoom().id);
}
function useCreateRoomThread(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useCreateRoomThread.useCallback3": (options)=>{
            const body = options.body;
            const metadata = options.metadata ?? {};
            const attachments = options.attachments;
            const threadId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createThreadId"])();
            const commentId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCommentId"])();
            const createdAt = /* @__PURE__ */ new Date();
            const newComment = {
                id: commentId,
                threadId,
                roomId,
                createdAt,
                type: "comment",
                userId: getCurrentUserId(client),
                body,
                reactions: [],
                attachments: attachments ?? []
            };
            const newThread = {
                id: threadId,
                type: "thread",
                createdAt,
                updatedAt: createdAt,
                roomId,
                metadata,
                comments: [
                    newComment
                ],
                resolved: false
            };
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "create-thread",
                thread: newThread,
                roomId
            });
            const attachmentIds = attachments?.map({
                "useCreateRoomThread.useCallback3": (attachment)=>attachment.id
            }["useCreateRoomThread.useCallback3"]);
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.createThread({
                roomId,
                threadId,
                commentId,
                body,
                metadata,
                attachmentIds
            }).then({
                "useCreateRoomThread.useCallback3": (thread)=>{
                    store.createThread(optimisticId, thread);
                }
            }["useCreateRoomThread.useCallback3"], {
                "useCreateRoomThread.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "CREATE_THREAD_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        body,
                        metadata
                    }, err)
            }["useCreateRoomThread.useCallback3"]);
            return newThread;
        }
    }["useCreateRoomThread.useCallback3"], [
        client,
        roomId
    ]);
}
function useDeleteThread() {
    return useDeleteRoomThread(useRoom().id);
}
function useDeleteRoomThread(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteRoomThread.useCallback3": (threadId)=>{
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const userId = getCurrentUserId(client);
            const existing = store.outputs.threads.get().get(threadId);
            if (existing?.comments?.[0]?.userId !== userId) {
                throw new Error("Only the thread creator can delete the thread");
            }
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-thread",
                roomId,
                threadId,
                deletedAt: /* @__PURE__ */ new Date()
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.deleteThread({
                roomId,
                threadId
            }).then({
                "useDeleteRoomThread.useCallback3": ()=>{
                    store.deleteThread(threadId, optimisticId);
                }
            }["useDeleteRoomThread.useCallback3"], {
                "useDeleteRoomThread.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "DELETE_THREAD_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useDeleteRoomThread.useCallback3"]);
        }
    }["useDeleteRoomThread.useCallback3"], [
        client,
        roomId
    ]);
}
function useEditThreadMetadata() {
    return useEditRoomThreadMetadata(useRoom().id);
}
function useEditRoomThreadMetadata(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useEditRoomThreadMetadata.useCallback3": (options)=>{
            if (!options.metadata) {
                return;
            }
            const threadId = options.threadId;
            const metadata = options.metadata;
            const updatedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "edit-thread-metadata",
                metadata,
                threadId,
                updatedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.editThreadMetadata({
                roomId,
                threadId,
                metadata
            }).then({
                "useEditRoomThreadMetadata.useCallback3": (metadata2)=>// Replace the optimistic update by the real thing
                    store.patchThread(threadId, optimisticId, {
                        metadata: metadata2
                    }, updatedAt)
            }["useEditRoomThreadMetadata.useCallback3"], {
                "useEditRoomThreadMetadata.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "EDIT_THREAD_METADATA_ERROR",
                        roomId,
                        threadId,
                        metadata
                    }, err)
            }["useEditRoomThreadMetadata.useCallback3"]);
        }
    }["useEditRoomThreadMetadata.useCallback3"], [
        client,
        roomId
    ]);
}
function useCreateComment() {
    return useCreateRoomComment(useRoom().id);
}
function useCreateRoomComment(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useCreateRoomComment.useCallback3": ({ threadId, body, attachments })=>{
            const commentId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCommentId"])();
            const createdAt = /* @__PURE__ */ new Date();
            const comment = {
                id: commentId,
                threadId,
                roomId,
                type: "comment",
                createdAt,
                userId: getCurrentUserId(client),
                body,
                reactions: [],
                attachments: attachments ?? []
            };
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "create-comment",
                comment
            });
            const attachmentIds = attachments?.map({
                "useCreateRoomComment.useCallback3": (attachment)=>attachment.id
            }["useCreateRoomComment.useCallback3"]);
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.createComment({
                roomId,
                threadId,
                commentId,
                body,
                attachmentIds
            }).then({
                "useCreateRoomComment.useCallback3": (newComment)=>{
                    store.createComment(newComment, optimisticId);
                }
            }["useCreateRoomComment.useCallback3"], {
                "useCreateRoomComment.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "CREATE_COMMENT_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        body
                    }, err)
            }["useCreateRoomComment.useCallback3"]);
            return comment;
        }
    }["useCreateRoomComment.useCallback3"], [
        client,
        roomId
    ]);
}
function useEditComment() {
    return useEditRoomComment(useRoom().id);
}
function useEditRoomComment(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useEditRoomComment.useCallback3": ({ threadId, commentId, body, attachments })=>{
            const editedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);
            if (existing === void 0) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`);
                return;
            }
            const comment = existing.comments.find({
                "useEditRoomComment.useCallback3.comment": (comment2)=>comment2.id === commentId
            }["useEditRoomComment.useCallback3.comment"]);
            if (comment === void 0 || comment.deletedAt !== void 0) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`);
                return;
            }
            const optimisticId = store.optimisticUpdates.add({
                type: "edit-comment",
                comment: {
                    ...comment,
                    editedAt,
                    body,
                    attachments: attachments ?? []
                }
            });
            const attachmentIds = attachments?.map({
                "useEditRoomComment.useCallback3": (attachment)=>attachment.id
            }["useEditRoomComment.useCallback3"]);
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.editComment({
                roomId,
                threadId,
                commentId,
                body,
                attachmentIds
            }).then({
                "useEditRoomComment.useCallback3": (editedComment)=>{
                    store.editComment(threadId, optimisticId, editedComment);
                }
            }["useEditRoomComment.useCallback3"], {
                "useEditRoomComment.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "EDIT_COMMENT_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        body
                    }, err)
            }["useEditRoomComment.useCallback3"]);
        }
    }["useEditRoomComment.useCallback3"], [
        client,
        roomId
    ]);
}
function useDeleteComment() {
    return useDeleteRoomComment(useRoom().id);
}
function useDeleteRoomComment(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteRoomComment.useCallback3": ({ threadId, commentId })=>{
            const deletedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-comment",
                threadId,
                commentId,
                deletedAt,
                roomId
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.deleteComment({
                roomId,
                threadId,
                commentId
            }).then({
                "useDeleteRoomComment.useCallback3": ()=>{
                    store.deleteComment(threadId, optimisticId, commentId, deletedAt);
                }
            }["useDeleteRoomComment.useCallback3"], {
                "useDeleteRoomComment.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "DELETE_COMMENT_ERROR",
                        roomId,
                        threadId,
                        commentId
                    }, err)
            }["useDeleteRoomComment.useCallback3"]);
        }
    }["useDeleteRoomComment.useCallback3"], [
        client,
        roomId
    ]);
}
function useAddReaction() {
    return useAddRoomCommentReaction(useRoom().id);
}
function useAddRoomCommentReaction(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useAddRoomCommentReaction.useCallback3": ({ threadId, commentId, emoji })=>{
            const createdAt = /* @__PURE__ */ new Date();
            const userId = getCurrentUserId(client);
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "add-reaction",
                threadId,
                commentId,
                reaction: {
                    emoji,
                    userId,
                    createdAt
                }
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.addReaction({
                roomId,
                threadId,
                commentId,
                emoji
            }).then({
                "useAddRoomCommentReaction.useCallback3": (addedReaction)=>{
                    store.addReaction(threadId, optimisticId, commentId, addedReaction, createdAt);
                }
            }["useAddRoomCommentReaction.useCallback3"], {
                "useAddRoomCommentReaction.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "ADD_REACTION_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        emoji
                    }, err)
            }["useAddRoomCommentReaction.useCallback3"]);
        }
    }["useAddRoomCommentReaction.useCallback3"], [
        client,
        roomId
    ]);
}
function useRemoveReaction() {
    return useRemoveRoomCommentReaction(useRoom().id);
}
function useRemoveRoomCommentReaction(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRemoveRoomCommentReaction.useCallback3": ({ threadId, commentId, emoji })=>{
            const userId = getCurrentUserId(client);
            const removedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "remove-reaction",
                threadId,
                commentId,
                emoji,
                userId,
                removedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.removeReaction({
                roomId,
                threadId,
                commentId,
                emoji
            }).then({
                "useRemoveRoomCommentReaction.useCallback3": ()=>{
                    store.removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt);
                }
            }["useRemoveRoomCommentReaction.useCallback3"], {
                "useRemoveRoomCommentReaction.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "REMOVE_REACTION_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        emoji
                    }, err)
            }["useRemoveRoomCommentReaction.useCallback3"]);
        }
    }["useRemoveRoomCommentReaction.useCallback3"], [
        client,
        roomId
    ]);
}
function useMarkThreadAsRead() {
    return useMarkRoomThreadAsRead(useRoom().id);
}
function useMarkRoomThreadAsRead(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkRoomThreadAsRead.useCallback3": (threadId)=>{
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const inboxNotification = Object.values(store.outputs.notifications.get().notificationsById).find({
                "useMarkRoomThreadAsRead.useCallback3.inboxNotification": (inboxNotification2)=>inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
            }["useMarkRoomThreadAsRead.useCallback3.inboxNotification"]);
            if (!inboxNotification) return;
            const now = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-inbox-notification-as-read",
                inboxNotificationId: inboxNotification.id,
                readAt: now
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.markRoomInboxNotificationAsRead({
                roomId,
                inboxNotificationId: inboxNotification.id
            }).then({
                "useMarkRoomThreadAsRead.useCallback3": ()=>{
                    store.markInboxNotificationRead(inboxNotification.id, now, optimisticId);
                }
            }["useMarkRoomThreadAsRead.useCallback3"], {
                "useMarkRoomThreadAsRead.useCallback3": (err)=>{
                    onMutationFailure(optimisticId, {
                        type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
                        roomId,
                        inboxNotificationId: inboxNotification.id
                    }, err);
                    return;
                }
            }["useMarkRoomThreadAsRead.useCallback3"]);
        }
    }["useMarkRoomThreadAsRead.useCallback3"], [
        client,
        roomId
    ]);
}
function useMarkThreadAsResolved() {
    return useMarkRoomThreadAsResolved(useRoom().id);
}
function useMarkRoomThreadAsResolved(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkRoomThreadAsResolved.useCallback3": (threadId)=>{
            const updatedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-thread-as-resolved",
                threadId,
                updatedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.markThreadAsResolved({
                roomId,
                threadId
            }).then({
                "useMarkRoomThreadAsResolved.useCallback3": ()=>{
                    store.patchThread(threadId, optimisticId, {
                        resolved: true
                    }, updatedAt);
                }
            }["useMarkRoomThreadAsResolved.useCallback3"], {
                "useMarkRoomThreadAsResolved.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "MARK_THREAD_AS_RESOLVED_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useMarkRoomThreadAsResolved.useCallback3"]);
        }
    }["useMarkRoomThreadAsResolved.useCallback3"], [
        client,
        roomId
    ]);
}
function useMarkThreadAsUnresolved() {
    return useMarkRoomThreadAsUnresolved(useRoom().id);
}
function useMarkRoomThreadAsUnresolved(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkRoomThreadAsUnresolved.useCallback3": (threadId)=>{
            const updatedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-thread-as-unresolved",
                threadId,
                updatedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.markThreadAsUnresolved({
                roomId,
                threadId
            }).then({
                "useMarkRoomThreadAsUnresolved.useCallback3": ()=>{
                    store.patchThread(threadId, optimisticId, {
                        resolved: false
                    }, updatedAt);
                }
            }["useMarkRoomThreadAsUnresolved.useCallback3"], {
                "useMarkRoomThreadAsUnresolved.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "MARK_THREAD_AS_UNRESOLVED_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useMarkRoomThreadAsUnresolved.useCallback3"]);
        }
    }["useMarkRoomThreadAsUnresolved.useCallback3"], [
        client,
        roomId
    ]);
}
function useThreadSubscription(threadId) {
    const client = useClient();
    const { store } = getRoomExtrasForClient(client);
    const signal = store.outputs.threadifications;
    const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useThreadSubscription.useCallback3[selector]": (state)=>{
            const notification = state.sortedNotifications.find({
                "useThreadSubscription.useCallback3[selector].notification": (inboxNotification)=>inboxNotification.kind === "thread" && inboxNotification.threadId === threadId
            }["useThreadSubscription.useCallback3[selector].notification"]);
            const thread = state.threadsDB.get(threadId);
            if (notification === void 0 || thread === void 0) {
                return {
                    status: "not-subscribed"
                };
            }
            return {
                status: "subscribed",
                unreadSince: notification.readAt
            };
        }
    }["useThreadSubscription.useCallback3[selector]"], [
        threadId
    ]);
    return useSignal(signal, selector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useRoomNotificationSettings() {
    const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
    const client = useClient();
    const room = useRoom();
    const { store, getOrCreateNotificationsSettingsPollerForRoomId } = getRoomExtrasForClient(client);
    const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomNotificationSettings.useEffect5": ()=>void store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    }["useRoomNotificationSettings.useEffect5"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomNotificationSettings.useEffect5": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useRoomNotificationSettings.useEffect5": ()=>{
                    poller.dec();
                }
            })["useRoomNotificationSettings.useEffect5"];
        }
    }["useRoomNotificationSettings.useEffect5"], [
        poller
    ]);
    const settings = useSignal(store.outputs.settingsByRoomId.getOrCreate(room.id).signal);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useRoomNotificationSettings.useMemo3": ()=>{
            return [
                settings,
                updateRoomNotificationSettings
            ];
        }
    }["useRoomNotificationSettings.useMemo3"], [
        settings,
        updateRoomNotificationSettings
    ]);
}
function useRoomNotificationSettingsSuspense() {
    ensureNotServerSide();
    const client = useClient();
    const store = getRoomExtrasForClient(client).store;
    const room = useRoom();
    use(store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded());
    const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!settings.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!settings.isLoading, "Did not expect loading");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useRoomNotificationSettingsSuspense.useMemo3": ()=>{
            return [
                settings,
                updateRoomNotificationSettings
            ];
        }
    }["useRoomNotificationSettingsSuspense.useMemo3"], [
        settings,
        updateRoomNotificationSettings
    ]);
}
function useHistoryVersionData(versionId) {
    const [state, setState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        isLoading: true
    });
    const room = useRoom();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useHistoryVersionData.useEffect5": ()=>{
            setState({
                isLoading: true
            });
            const load = {
                "useHistoryVersionData.useEffect5.load": async ()=>{
                    try {
                        const response = await room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].getTextVersion(versionId);
                        const buffer = await response.arrayBuffer();
                        const data = new Uint8Array(buffer);
                        setState({
                            isLoading: false,
                            data
                        });
                    } catch (error) {
                        setState({
                            isLoading: false,
                            error: error instanceof Error ? error : new Error("An unknown error occurred while loading this version")
                        });
                    }
                }
            }["useHistoryVersionData.useEffect5.load"];
            void load();
        }
    }["useHistoryVersionData.useEffect5"], [
        room,
        versionId
    ]);
    return state;
}
function useHistoryVersions() {
    const client = useClient();
    const room = useRoom();
    const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);
    const poller = getOrCreateVersionsPollerForRoomId(room.id);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useHistoryVersions.useEffect5": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useHistoryVersions.useEffect5": ()=>poller.dec()
            })["useHistoryVersions.useEffect5"];
        }
    }["useHistoryVersions.useEffect5"], [
        poller
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useHistoryVersions.useEffect5": ()=>void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    }["useHistoryVersions.useEffect5"]);
    return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);
}
function useHistoryVersionsSuspense() {
    ensureNotServerSide();
    const client = useClient();
    const room = useRoom();
    const store = getRoomExtrasForClient(client).store;
    use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());
    const result = useHistoryVersions();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useUpdateRoomNotificationSettings() {
    const client = useClient();
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUpdateRoomNotificationSettings.useCallback3": (settings)=>{
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "update-notification-settings",
                roomId: room.id,
                settings
            });
            room.updateNotificationSettings(settings).then({
                "useUpdateRoomNotificationSettings.useCallback3": (settings2)=>{
                    store.updateRoomNotificationSettings(room.id, optimisticId, settings2);
                }
            }["useUpdateRoomNotificationSettings.useCallback3"], {
                "useUpdateRoomNotificationSettings.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "UPDATE_NOTIFICATION_SETTINGS_ERROR",
                        roomId: room.id
                    }, err)
            }["useUpdateRoomNotificationSettings.useCallback3"]);
        }
    }["useUpdateRoomNotificationSettings.useCallback3"], [
        client,
        room
    ]);
}
function useSuspendUntilPresenceReady() {
    ensureNotServerSide();
    const room = useRoom();
    use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useSelf(selector, isEqual);
}
function useOthersSuspense(selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useOthers(selector, isEqual);
}
function useOthersConnectionIdsSuspense() {
    useSuspendUntilPresenceReady();
    return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
    useSuspendUntilPresenceReady();
    return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
    ensureNotServerSide();
    const room = useRoom();
    use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
    useSuspendUntilStorageReady();
    return useStorage(selector, isEqual);
}
function useStorageStatusSuspense(options) {
    useSuspendUntilStorageReady();
    return useStorageStatus(options);
}
function useThreadsSuspense(options = {}) {
    ensureNotServerSide();
    const client = useClient();
    const room = useRoom();
    const { store } = getRoomExtrasForClient(client);
    const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
    use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());
    const result = useThreads(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function selectorFor_useAttachmentUrl(state) {
    if (state === void 0 || state?.isLoading) {
        return state ?? {
            isLoading: true
        };
    }
    if (state.error) {
        return state;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state.data !== void 0, "Unexpected missing attachment URL");
    return {
        isLoading: false,
        url: state.data
    };
}
function useAttachmentUrl(attachmentId) {
    const room = useRoom();
    return useRoomAttachmentUrl(attachmentId, room.id);
}
function useRoomAttachmentUrl(attachmentId, roomId) {
    const client = useClient();
    const store = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getOrCreateAttachmentUrlsStore(roomId);
    const getAttachmentUrlState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomAttachmentUrl.useCallback3[getAttachmentUrlState]": ()=>store.getItemState(attachmentId)
    }["useRoomAttachmentUrl.useCallback3[getAttachmentUrlState]"], [
        store,
        attachmentId
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomAttachmentUrl.useEffect5": ()=>{
            void store.enqueue(attachmentId);
        }
    }["useRoomAttachmentUrl.useEffect5"], [
        store,
        attachmentId
    ]);
    return useSyncExternalStoreWithSelector(store.subscribe, getAttachmentUrlState, getAttachmentUrlState, selectorFor_useAttachmentUrl, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useAttachmentUrlSuspense(attachmentId) {
    const room = useRoom();
    const { attachmentUrlsStore } = room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]];
    const getAttachmentUrlState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useAttachmentUrlSuspense.useCallback3[getAttachmentUrlState]": ()=>attachmentUrlsStore.getItemState(attachmentId)
    }["useAttachmentUrlSuspense.useCallback3[getAttachmentUrlState]"], [
        attachmentUrlsStore,
        attachmentId
    ]);
    const attachmentUrlState = getAttachmentUrlState();
    if (!attachmentUrlState || attachmentUrlState.isLoading) {
        throw attachmentUrlsStore.enqueue(attachmentId);
    }
    if (attachmentUrlState.error) {
        throw attachmentUrlState.error;
    }
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(attachmentUrlsStore.subscribe, getAttachmentUrlState, getAttachmentUrlState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state !== void 0, "Unexpected missing state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.isLoading, "Unexpected loading state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.error, "Unexpected error state");
    return {
        isLoading: false,
        url: state.data,
        error: void 0
    };
}
var NO_PERMISSIONS = /* @__PURE__ */ new Set();
function useRoomPermissions(roomId) {
    const client = useClient();
    const store = getRoomExtrasForClient(client).store;
    return useSignal(store.permissionHints.signal, {
        "useRoomPermissions.useSignal": (hints)=>hints.get(roomId) ?? NO_PERMISSIONS
    }["useRoomPermissions.useSignal"]);
}
function createRoomContext(client) {
    return getOrCreateRoomContextBundle(client);
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useOthersMappedSuspense = useOthersMappedSuspense;
var _useThreads = useThreads;
var _useThreadsSuspense = useThreadsSuspense;
var _useRoomNotificationSettings = useRoomNotificationSettings;
var _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense;
var _useHistoryVersions = useHistoryVersions;
var _useHistoryVersionsSuspense = useHistoryVersionsSuspense;
var _useOther = useOther;
function _useOthers(...args) {
    return useOthers(...args);
}
var _useOtherSuspense = useOtherSuspense;
function _useOthersSuspense(...args) {
    return useOthersSuspense(...args);
}
var _useStorage = useStorage;
var _useStorageSuspense = useStorageSuspense;
function _useSelf(...args) {
    return useSelf(...args);
}
function _useSelfSuspense(...args) {
    return useSelfSuspense(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;
;
 //# sourceMappingURL=chunk-63WTJCBG.mjs.map
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export _useOtherSuspense as useOther>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useOther": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_useOtherSuspense"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export useOthersConnectionIdsSuspense as useOthersConnectionIds>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useOthersConnectionIds": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOthersConnectionIdsSuspense"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export _useOthersMappedSuspense as useOthersMapped>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useOthersMapped": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_useOthersMappedSuspense"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export _useMutation as useMutation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useMutation": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_useMutation"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export _useStorageSuspense as useStorage>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useStorage": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_useStorageSuspense"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export _useOthersSuspense as useOthers>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useOthers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_useOthersSuspense"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export _useSelfSuspense as useSelf>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useSelf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_useSelfSuspense"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript) <export _RoomProvider as RoomProvider>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RoomProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_RoomProvider"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$react$2f$dist$2f$chunk$2d$63WTJCBG$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@liveblocks/react/dist/chunk-63WTJCBG.mjs [app-client] (ecmascript)");
}}),
"[project]/node_modules/@liveblocks/react/dist/chunk-FE7VYVHO.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/version.ts
__turbopack_esm__({
    "ClientSideSuspense": (()=>ClientSideSuspense),
    "PKG_FORMAT": (()=>PKG_FORMAT),
    "PKG_NAME": (()=>PKG_NAME),
    "PKG_VERSION": (()=>PKG_VERSION)
});
// src/ClientSideSuspense.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "2.16.2";
var PKG_FORMAT = "esm";
;
;
function ClientSideSuspense(props) {
    const [mounted, setMounted] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ClientSideSuspense.useEffect": ()=>{
            setMounted(true);
        }
    }["ClientSideSuspense.useEffect"], []);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Suspense"], {
        fallback: props.fallback,
        children: mounted ? typeof props.children === "function" ? props.children() : props.children : props.fallback
    });
}
;
 //# sourceMappingURL=chunk-FE7VYVHO.mjs.map
}}),
}]);

//# sourceMappingURL=node_modules_%40liveblocks_react_dist_09766e._.js.map