{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/contexts.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/use-sync-external-store-with-selector.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/use-signal.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/liveblocks.tsx","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/config.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/AsyncResult.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/itertools.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/ssr.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/use-initial.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/use-latest.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/use-polyfill.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/umbrella-store.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/autobind.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/shallow2.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/ThreadDB.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/lib/querying.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/room.tsx","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/use-scroll-to-comment-on-load-effect.ts"],"sourcesContent":["import type {\n  BaseMetadata,\n  BaseUserMeta,\n  Json,\n  JsonObject,\n  LsonObject,\n  Room,\n} from \"@liveblocks/client\";\nimport type { OpaqueRoom } from \"@liveblocks/core\";\nimport { createContext, useContext } from \"react\";\n\n/**\n * Raw access to the React context where the RoomProvider stores the current\n * room. Exposed for advanced use cases only.\n *\n * @private This is a private/advanced API. Do not rely on it.\n */\nexport const RoomContext = createContext<OpaqueRoom | null>(null);\n\n/** @private */\nexport function useRoomOrNull<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(): Room<P, S, U, E, M> | null {\n  return useContext(RoomContext) as Room<P, S, U, E, M> | null;\n}\n\n/**\n * Returns whether the hook is called within a RoomProvider context.\n *\n * @example\n * const isInsideRoom = useIsInsideRoom();\n */\nexport function useIsInsideRoom(): boolean {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable react-hooks/exhaustive-deps */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {\n  useDebugValue,\n  useEffect,\n  useMemo,\n  useRef,\n  useSyncExternalStore,\n} from \"react\";\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  );\n}\n\n// Same as useSyncExternalStore, but supports selector and isEqual arguments.\nexport function useSyncExternalStoreWithSelector<Snapshot, Selection>(\n  subscribe: (callback: () => void) => () => void,\n  getSnapshot: () => Snapshot,\n  getServerSnapshot: void | null | (() => Snapshot),\n  selector: (snapshot: Snapshot) => Selection,\n  isEqual?: (a: Selection, b: Selection) => boolean\n): Selection {\n  type X =\n    | { hasValue: true; value: Selection }\n    | { hasValue: false; value: null }\n    | null;\n\n  // Use this to track the rendered snapshot.\n  const instRef = useRef<X>(null);\n\n  let inst: X;\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null,\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  const [getSelection, getServerSelection] = useMemo(() => {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    let hasMemo = false;\n    let memoizedSnapshot: unknown;\n    let memoizedSelection: Selection;\n    const memoizedSelector = (nextSnapshot: Snapshot) => {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n        const nextSelection = selector(nextSnapshot);\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            const currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSelection)) {\n              memoizedSelection = currentSelection!;\n              return currentSelection;\n            }\n          }\n        }\n        memoizedSelection = nextSelection;\n        return nextSelection;\n      }\n\n      // We may be able to reuse the previous invocation's result.\n      const prevSnapshot: Snapshot = memoizedSnapshot as any;\n      const prevSelection: Selection = memoizedSelection as any;\n\n      if (is(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      }\n\n      // The snapshot has changed, so we need to compute a new selection.\n      const nextSelection = selector(nextSnapshot);\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        // The snapshot still has changed, so make sure to update to not keep\n        // old references alive\n        memoizedSnapshot = nextSnapshot;\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    };\n\n    const maybeGetServerSnapshot =\n      getServerSnapshot === undefined ? null : getServerSnapshot;\n    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());\n    const getServerSnapshotWithSelector =\n      maybeGetServerSnapshot === null\n        ? undefined\n        : () => memoizedSelector(maybeGetServerSnapshot());\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]);\n\n  const value = useSyncExternalStore(\n    subscribe,\n    getSelection,\n    getServerSelection\n  );\n\n  useEffect(() => {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n\n  useDebugValue(value);\n  return value;\n}\n","import type { ISignal } from \"@liveblocks/core\";\n\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nconst identity = <T>(value: T): T => value;\n\nexport function useSignal<T>(signal: ISignal<T>): T;\nexport function useSignal<T, V>(\n  signal: ISignal<T>,\n  selector: (value: T) => V,\n  isEqual?: (a: V, b: V) => boolean\n): V;\nexport function useSignal<T, V>(\n  signal: ISignal<T>,\n  selector?: (value: T) => V,\n  isEqual?: (a: V, b: V) => boolean\n): T | V {\n  return useSyncExternalStoreWithSelector(\n    signal.subscribe,\n    signal.get,\n    signal.get,\n    selector ?? (identity as (value: T) => V),\n    isEqual\n  );\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  ClientOptions,\n  ThreadData,\n} from \"@liveblocks/client\";\nimport type {\n  AsyncResult,\n  BaseRoomInfo,\n  DM,\n  DU,\n  LiveblocksError,\n  OpaqueClient,\n  SyncStatus,\n} from \"@liveblocks/core\";\nimport {\n  assert,\n  createClient,\n  kInternal,\n  makePoller,\n  raise,\n  shallow,\n} from \"@liveblocks/core\";\nimport type { PropsWithChildren } from \"react\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n  useSyncExternalStore,\n} from \"react\";\n\nimport { config } from \"./config\";\nimport { useIsInsideRoom } from \"./contexts\";\nimport { ASYNC_OK } from \"./lib/AsyncResult\";\nimport { count } from \"./lib/itertools\";\nimport { ensureNotServerSide } from \"./lib/ssr\";\nimport { useInitial, useInitialUnlessFunction } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { use } from \"./lib/use-polyfill\";\nimport type {\n  InboxNotificationsAsyncResult,\n  LiveblocksContextBundle,\n  RoomInfoAsyncResult,\n  RoomInfoAsyncSuccess,\n  SharedContextBundle,\n  ThreadsAsyncResult,\n  ThreadsAsyncSuccess,\n  UnreadInboxNotificationsCountAsyncResult,\n  UserAsyncResult,\n  UserAsyncSuccess,\n  UseSyncStatusOptions,\n  UseUserThreadsOptions,\n} from \"./types\";\nimport { makeUserThreadsQueryKey, UmbrellaStore } from \"./umbrella-store\";\nimport { useSignal } from \"./use-signal\";\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\n/**\n * Raw access to the React context where the LiveblocksProvider stores the\n * current client. Exposed for advanced use cases only.\n *\n * @private This is a private/advanced API. Do not rely on it.\n */\nexport const ClientContext = createContext<OpaqueClient | null>(null);\n\nfunction missingUserError(userId: string) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\n\nfunction missingRoomInfoError(roomId: string) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n\nconst _umbrellaStores = new WeakMap<\n  OpaqueClient,\n  UmbrellaStore<BaseMetadata>\n>();\nconst _extras = new WeakMap<\n  OpaqueClient,\n  ReturnType<typeof makeLiveblocksExtrasForClient>\n>();\nconst _bundles = new WeakMap<\n  OpaqueClient,\n  LiveblocksContextBundle<BaseUserMeta, BaseMetadata>\n>();\n\nfunction selectorFor_useUnreadInboxNotificationsCount(\n  result: InboxNotificationsAsyncResult\n): UnreadInboxNotificationsCountAsyncResult {\n  if (!result.inboxNotifications) {\n    // Can be loading or error states\n    return result;\n  }\n\n  return ASYNC_OK(\n    \"count\",\n    count(\n      result.inboxNotifications,\n      (n) => n.readAt === null || n.readAt < n.notifiedAt\n    )\n  );\n}\n\nfunction selectorFor_useUser<U extends BaseUserMeta>(\n  state: AsyncResult<U[\"info\"] | undefined> | undefined,\n  userId: string\n): UserAsyncResult<U[\"info\"]> {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this user\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    user: state.data,\n  };\n}\n\nfunction selectorFor_useRoomInfo(\n  state: AsyncResult<BaseRoomInfo | undefined> | undefined,\n  roomId: string\n): RoomInfoAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this room info\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    info: state.data,\n  };\n}\n\nfunction getOrCreateContextBundle<\n  U extends BaseUserMeta,\n  M extends BaseMetadata,\n>(client: OpaqueClient): LiveblocksContextBundle<U, M> {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle as LiveblocksContextBundle<U, M>;\n}\n\n/**\n * Gets or creates a unique Umbrella store for each unique client instance.\n *\n * @private\n */\nexport function getUmbrellaStoreForClient<M extends BaseMetadata>(\n  client: OpaqueClient\n): UmbrellaStore<M> {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store as unknown as UmbrellaStore<M>;\n}\n\n// TODO: Likely a better / more clear name for this helper will arise. I'll\n// rename this later. All of these are implementation details to support inbox\n// notifications on a per-client basis.\n/** @internal Only exported for unit tests. */\nexport function getLiveblocksExtrasForClient<M extends BaseMetadata>(\n  client: OpaqueClient\n) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n\n  return extras as unknown as Omit<typeof extras, \"store\"> & {\n    store: UmbrellaStore<M>;\n  };\n}\n\nfunction makeLiveblocksExtrasForClient(client: OpaqueClient) {\n  const store = getUmbrellaStoreForClient(client);\n  // TODO                                ^ Bind to M type param here\n\n  //\n  // How pagination and delta updates work\n  // =====================================\n  //\n  // Suppose we call fetchInboxNotifications() for the first time. Then,\n  // eventually we'll see this timeline of notifications:\n  //\n  // <-- Newer                        Older -->\n  //       |---o---------o----------o---|\n  //\n  //       o = an inbox notification\n  //\n  // In this array, there are three entries, ordered from latest to oldest.\n  //\n  // Now if we call fetchInboxNotifications() again (which is what the\n  // periodic poller does), then the array may get updated with newer inbox\n  // notifications, meaning entries will appear at the head end of the array.\n  // This is a so called \"delta update\".\n  //\n  // <-- Newer                                 Older -->\n  //       |--o---o-|---o---------o----------o---|\n  //          delta\n  //\n  // Here, two new entries have appeared at the start.\n  //\n  // Another way to update this array is to use \"pagination\". Pagination will\n  // update this list at the _tail_ end.\n  //\n  // After calling fetchMore():\n  //\n  // <-- Newer                                                  Older -->\n  //       |--o---o-|---o---------o----------o---|--o--o-o-o-o-o--|\n  //                                                   page 2\n  //\n  // And calling fetchMore() another time:\n  //\n  // <-- Newer                                                                  Older -->\n  //       |--o---o-|---o---------o----------o---|--o--o-o-o-o-o--|--o-o---o---o--|\n  //                                                   page 2           page 3\n  //\n  // In terms of HTTP requests:\n  // - A delta update will perform a GET /v2/c/inbox-notifications?since=...\n  // - Pagination will perform a GET /v2/c/inbox-notifications?cursor=...\n  //\n\n  const notificationsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n\n  const userThreadsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller,\n  };\n}\n\nfunction makeLiveblocksContextBundle<\n  U extends BaseUserMeta,\n  M extends BaseMetadata,\n>(client: Client<U>): LiveblocksContextBundle<U, M> {\n  // Bind all hooks to the current client instance\n  const useInboxNotificationThread = (inboxNotificationId: string) =>\n    useInboxNotificationThread_withClient<M>(client, inboxNotificationId);\n\n  const useMarkInboxNotificationAsRead = () =>\n    useMarkInboxNotificationAsRead_withClient(client);\n\n  const useMarkAllInboxNotificationsAsRead = () =>\n    useMarkAllInboxNotificationsAsRead_withClient(client);\n\n  const useDeleteInboxNotification = () =>\n    useDeleteInboxNotification_withClient(client);\n\n  const useDeleteAllInboxNotifications = () =>\n    useDeleteAllInboxNotifications_withClient(client);\n\n  // NOTE: This version of the LiveblocksProvider does _not_ take any props.\n  // This is because we already have a client bound to it.\n  function LiveblocksProvider(props: PropsWithChildren) {\n    useEnsureNoLiveblocksProvider();\n    return (\n      <ClientContext.Provider value={client}>\n        {props.children}\n      </ClientContext.Provider>\n    );\n  }\n\n  const shared = createSharedContext<U>(client);\n\n  const bundle: LiveblocksContextBundle<U, M> = {\n    LiveblocksProvider,\n\n    useInboxNotifications: () =>\n      useInboxNotifications_withClient(client, identity, shallow),\n    useUnreadInboxNotificationsCount: () =>\n      useUnreadInboxNotificationsCount_withClient(client),\n\n    useMarkInboxNotificationAsRead,\n    useMarkAllInboxNotificationsAsRead,\n\n    useDeleteInboxNotification,\n    useDeleteAllInboxNotifications,\n\n    useInboxNotificationThread,\n    useUserThreads_experimental,\n\n    ...shared.classic,\n\n    suspense: {\n      LiveblocksProvider,\n\n      useInboxNotifications: () =>\n        useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () =>\n        useUnreadInboxNotificationsCountSuspense_withClient(client),\n\n      useMarkInboxNotificationAsRead,\n      useMarkAllInboxNotificationsAsRead,\n\n      useDeleteInboxNotification,\n      useDeleteAllInboxNotifications,\n\n      useInboxNotificationThread,\n\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n\n      ...shared.suspense,\n    },\n  };\n  return bundle;\n}\n\nfunction useInboxNotifications_withClient<T>(\n  client: OpaqueClient,\n  selector: (result: InboxNotificationsAsyncResult) => T,\n  isEqual: (a: T, b: T) => boolean\n): T {\n  const { store, notificationsPoller: poller } =\n    getLiveblocksExtrasForClient(client);\n\n  // Trigger initial loading of inbox notifications if it hasn't started\n  // already, but don't await its promise.\n  useEffect(\n    () => void store.outputs.loadingNotifications.waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  return useSignal(\n    store.outputs.loadingNotifications.signal,\n    selector,\n    isEqual\n  );\n}\n\nfunction useInboxNotificationsSuspense_withClient(client: OpaqueClient) {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  // Suspend until there are at least some inbox notifications\n  use(store.outputs.loadingNotifications.waitUntilLoaded());\n\n  // We're in a Suspense world here, and as such, the useInboxNotifications()\n  // hook is expected to only return success results when we're here.\n  const result = useInboxNotifications_withClient(client, identity, shallow);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction useUnreadInboxNotificationsCount_withClient(client: OpaqueClient) {\n  return useInboxNotifications_withClient(\n    client,\n    selectorFor_useUnreadInboxNotificationsCount,\n    shallow\n  );\n}\n\nfunction useUnreadInboxNotificationsCountSuspense_withClient(\n  client: OpaqueClient\n) {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  // Suspend until there are at least some inbox notifications\n  use(store.outputs.loadingNotifications.waitUntilLoaded());\n\n  const result = useUnreadInboxNotificationsCount_withClient(client);\n  assert(!result.isLoading, \"Did not expect loading\");\n  assert(!result.error, \"Did not expect error\");\n  return result;\n}\n\nfunction useMarkInboxNotificationAsRead_withClient(client: OpaqueClient) {\n  return useCallback(\n    (inboxNotificationId: string) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n\n      const readAt = new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt,\n      });\n\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.markInboxNotificationRead(\n            inboxNotificationId,\n            readAt,\n            optimisticId\n          );\n        },\n        (err: Error) => {\n          store.optimisticUpdates.remove(optimisticId);\n          // XXX_vincent Add unit test for this error\n          client[kInternal].emitError(\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              inboxNotificationId,\n            },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useMarkAllInboxNotificationsAsRead_withClient(client: OpaqueClient) {\n  return useCallback(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const readAt = new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt,\n    });\n\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        // Replace the optimistic update by the real thing\n        store.markAllInboxNotificationsRead(optimisticId, readAt);\n      },\n      (err: Error) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[kInternal].emitError(\n          // No roomId, threadId, commentId to include for this error\n          { type: \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\n\nfunction useDeleteInboxNotification_withClient(client: OpaqueClient) {\n  return useCallback(\n    (inboxNotificationId: string) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n\n      const deletedAt = new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt,\n      });\n\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.deleteInboxNotification(inboxNotificationId, optimisticId);\n        },\n        (err: Error) => {\n          store.optimisticUpdates.remove(optimisticId);\n          // XXX_vincent Add unit test for this error\n          client[kInternal].emitError(\n            { type: \"DELETE_INBOX_NOTIFICATION_ERROR\", inboxNotificationId },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useDeleteAllInboxNotifications_withClient(client: OpaqueClient) {\n  return useCallback(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const deletedAt = new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt,\n    });\n\n    client.deleteAllInboxNotifications().then(\n      () => {\n        // Replace the optimistic update by the real thing\n        store.deleteAllInboxNotifications(optimisticId);\n      },\n      (err: Error) => {\n        store.optimisticUpdates.remove(optimisticId);\n        // XXX_vincent Add unit test for this error\n        client[kInternal].emitError(\n          { type: \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\n\nfunction useInboxNotificationThread_withClient<M extends BaseMetadata>(\n  client: OpaqueClient,\n  inboxNotificationId: string\n): ThreadData<M> {\n  const { store } = getLiveblocksExtrasForClient<M>(client);\n  return useSignal(\n    store.outputs.threadifications,\n    useCallback(\n      (state) => {\n        const inboxNotification =\n          state.notificationsById[inboxNotificationId] ??\n          raise(\n            `Inbox notification with ID \"${inboxNotificationId}\" not found`\n          );\n\n        if (inboxNotification.kind !== \"thread\") {\n          raise(\n            `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n          );\n        }\n\n        const thread =\n          state.threadsDB.get(inboxNotification.threadId) ??\n          raise(\n            `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n          );\n\n        return thread;\n      },\n      [inboxNotificationId]\n    )\n  );\n}\n\nfunction useUser_withClient<U extends BaseUserMeta>(\n  client: Client<U>,\n  userId: string\n): UserAsyncResult<U[\"info\"]> {\n  const usersStore = client[kInternal].usersStore;\n\n  const getUserState = useCallback(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getUserState>) =>\n      selectorFor_useUser(state, userId),\n    [userId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void usersStore.enqueue(userId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call usersStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the userId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the userId gets invalidated, the user would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useUserSuspense_withClient<U extends BaseUserMeta>(\n  client: Client<U>,\n  userId: string\n) {\n  const usersStore = client[kInternal].usersStore;\n\n  const getUserState = useCallback(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n\n  if (!userState || userState.isLoading) {\n    throw usersStore.enqueue(userId);\n  }\n\n  if (userState.error) {\n    throw userState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveUsers` for this user ID\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n\n  const state = useSyncExternalStore(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: undefined,\n  } as const;\n}\n\nfunction useRoomInfo_withClient(\n  client: OpaqueClient,\n  roomId: string\n): RoomInfoAsyncResult {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n\n  const getRoomInfoState = useCallback(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getRoomInfoState>) =>\n      selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void roomsInfoStore.enqueue(roomId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call roomsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the roomId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the roomId gets invalidated, the room info would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useRoomInfoSuspense_withClient(client: OpaqueClient, roomId: string) {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n\n  const getRoomInfoState = useCallback(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.enqueue(roomId);\n  }\n\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveRoomsInfo` for this room ID\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n\n  const state = useSyncExternalStore(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  assert(state.data !== undefined, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: undefined,\n  } as const;\n}\n\n/** @internal */\nexport function createSharedContext<U extends BaseUserMeta>(\n  client: Client<U>\n): SharedContextBundle<U> {\n  const useClient = () => client;\n\n  function useSyncStatus(options?: UseSyncStatusOptions) {\n    return useSyncStatus_withClient(client, options);\n  }\n\n  return {\n    classic: {\n      useClient,\n      useUser: (userId: string) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId: string) => useRoomInfo_withClient(client, roomId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus,\n    },\n    suspense: {\n      useClient,\n      useUser: (userId: string) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId: string) =>\n        useRoomInfoSuspense_withClient(client, roomId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus,\n    },\n  };\n}\n\n/**\n * @private This is an internal API.\n */\nfunction useEnsureNoLiveblocksProvider(options?: { allowNesting?: boolean }) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\n\n/**\n * @private This is an internal API.\n */\nexport function useClientOrNull<U extends BaseUserMeta>() {\n  return useContext(ClientContext) as Client<U> | null;\n}\n\n/**\n * Obtains a reference to the current Liveblocks client.\n */\nexport function useClient<U extends BaseUserMeta>() {\n  return (\n    useClientOrNull<U>() ??\n    raise(\"LiveblocksProvider is missing from the React tree.\")\n  );\n}\n\n/**\n * @private This is a private API.\n */\nexport function LiveblocksProviderWithClient(\n  props: PropsWithChildren<{\n    client: OpaqueClient;\n\n    // Private flag, used only to skip the nesting check if this is\n    // a LiveblocksProvider created implicitly by a factory-bound RoomProvider.\n    allowNesting?: boolean;\n  }>\n) {\n  useEnsureNoLiveblocksProvider(props);\n  return (\n    <ClientContext.Provider value={props.client}>\n      {props.children}\n    </ClientContext.Provider>\n  );\n}\n\n/**\n * Sets up a client for connecting to Liveblocks, and is the recommended way to do\n * this for React apps. You must define either `authEndpoint` or `publicApiKey`.\n * Resolver functions should be placed inside here, and a number of other options\n * are available, which correspond with those passed to `createClient`.\n * Unlike `RoomProvider`, `LiveblocksProvider` doesn’t call Liveblocks servers when mounted,\n * and it should be placed higher in your app’s component tree.\n */\nexport function LiveblocksProvider<U extends BaseUserMeta = DU>(\n  props: PropsWithChildren<ClientOptions<U>>\n) {\n  const { children, ...o } = props;\n\n  // It's important that the static options remain stable, otherwise we'd be\n  // creating new client instances on every render.\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),\n\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl as string | undefined\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging as boolean | undefined\n    ),\n  } as ClientOptions<U>;\n\n  // NOTE: Deliberately not passing any deps here, because we'll _never_ want\n  // to recreate a client instance after the first render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const client = useMemo(() => createClient<U>(options), []);\n  return (\n    <LiveblocksProviderWithClient client={client}>\n      {children}\n    </LiveblocksProviderWithClient>\n  );\n}\n\n/**\n * Creates a LiveblocksProvider and a set of typed hooks. Note that any\n * LiveblocksProvider created in this way takes no props, because it uses\n * settings from the given client instead.\n */\nexport function createLiveblocksContext<\n  U extends BaseUserMeta = DU,\n  M extends BaseMetadata = DM,\n>(client: OpaqueClient): LiveblocksContextBundle<U, M> {\n  return getOrCreateContextBundle<U, M>(client);\n}\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n *\n */\nfunction useUserThreads_experimental<M extends BaseMetadata>(\n  options: UseUserThreadsOptions<M> = {}\n): ThreadsAsyncResult<M> {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } =\n    getLiveblocksExtrasForClient<M>(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n\n  useEffect(\n    () =>\n      void store.outputs.loadingUserThreads\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  return useSignal(\n    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal\n  );\n}\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nfunction useUserThreadsSuspense_experimental<M extends BaseMetadata>(\n  options: UseUserThreadsOptions<M> = {}\n): ThreadsAsyncSuccess<M> {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient<M>(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n\n  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useUserThreads_experimental(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns the inbox notifications for the current user.\n *\n * @example\n * const { inboxNotifications, error, isLoading } = useInboxNotifications();\n */\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient(), identity, shallow);\n}\n\n/**\n * Returns the inbox notifications for the current user.\n *\n * @example\n * const { inboxNotifications } = useInboxNotifications();\n */\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\n\nfunction useInboxNotificationThread<M extends BaseMetadata>(\n  inboxNotificationId: string\n) {\n  return useInboxNotificationThread_withClient<M>(\n    useClient(),\n    inboxNotificationId\n  );\n}\n\n/**\n * Returns a function that marks all of the current user's inbox notifications as read.\n *\n * @example\n * const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();\n * markAllInboxNotificationsAsRead();\n */\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\n\n/**\n * Returns a function that marks an inbox notification as read for the current user.\n *\n * @example\n * const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();\n * markInboxNotificationAsRead(\"in_xxx\");\n */\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\n\n/**\n * Returns a function that deletes all of the current user's inbox notifications.\n *\n * @example\n * const deleteAllInboxNotifications = useDeleteAllInboxNotifications();\n * deleteAllInboxNotifications();\n */\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\n\n/**\n * Returns a function that deletes an inbox notification for the current user.\n *\n * @example\n * const deleteInboxNotification = useDeleteInboxNotification();\n * deleteInboxNotification(\"in_xxx\");\n */\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\n\n/**\n * Returns the number of unread inbox notifications for the current user.\n *\n * @example\n * const { count, error, isLoading } = useUnreadInboxNotificationsCount();\n */\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\n\n/**\n * Returns the number of unread inbox notifications for the current user.\n *\n * @example\n * const { count } = useUnreadInboxNotificationsCount();\n */\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\n\nfunction useUser<U extends BaseUserMeta>(userId: string) {\n  const client = useClient<U>();\n  return useUser_withClient(client, userId);\n}\n\nfunction useUserSuspense<U extends BaseUserMeta>(\n  userId: string\n): UserAsyncSuccess<U[\"info\"]> {\n  const client = useClient<U>();\n  return useUserSuspense_withClient(client, userId);\n}\n\n/**\n * Returns room info from a given room ID.\n *\n * @example\n * const { info, error, isLoading } = useRoomInfo(\"room-id\");\n */\nfunction useRoomInfo(roomId: string): RoomInfoAsyncResult {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\n\n/**\n * Returns room info from a given room ID.\n *\n * @example\n * const { info } = useRoomInfo(\"room-id\");\n */\nfunction useRoomInfoSuspense(roomId: string): RoomInfoAsyncSuccess {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\n\ntype TypedBundle = LiveblocksContextBundle<DU, DM>;\n\n/**\n * Returns the thread associated with a `\"thread\"` inbox notification.\n *\n * It can **only** be called with IDs of `\"thread\"` inbox notifications,\n * so we recommend only using it when customizing the rendering or in other\n * situations where you can guarantee the kind of the notification.\n *\n * When `useInboxNotifications` returns `\"thread\"` inbox notifications,\n * it also receives the associated threads and caches them behind the scenes.\n * When you call `useInboxNotificationThread`, it simply returns the cached thread\n * for the inbox notification ID you passed to it, without any fetching or waterfalls.\n *\n * @example\n * const thread = useInboxNotificationThread(\"in_xxx\");\n */\nconst _useInboxNotificationThread: TypedBundle[\"useInboxNotificationThread\"] =\n  useInboxNotificationThread;\n\n/**\n * Returns user info from a given user ID.\n *\n * @example\n * const { user, error, isLoading } = useUser(\"user-id\");\n */\nconst _useUser: TypedBundle[\"useUser\"] = useUser;\n\n/**\n * Returns user info from a given user ID.\n *\n * @example\n * const { user } = useUser(\"user-id\");\n */\nconst _useUserSuspense: TypedBundle[\"suspense\"][\"useUser\"] = useUserSuspense;\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nconst _useUserThreads_experimental: TypedBundle[\"useUserThreads_experimental\"] =\n  useUserThreads_experimental;\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nconst _useUserThreadsSuspense_experimental: TypedBundle[\"suspense\"][\"useUserThreads_experimental\"] =\n  useUserThreadsSuspense_experimental;\n\nfunction useSyncStatus_withClient(\n  client: OpaqueClient,\n  options?: UseSyncStatusOptions\n): SyncStatus {\n  // Normally the Rules of Hooks™ dictate that you should not call hooks\n  // conditionally. In this case, we're good here, because the same code path\n  // will always be taken on every subsequent render here, because we've frozen\n  // the value.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useSyncStatusSmooth_withClient(client);\n  } else {\n    return useSyncStatusImmediate_withClient(client);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n}\n\nfunction useSyncStatusImmediate_withClient(client: OpaqueClient): SyncStatus {\n  return useSyncExternalStore(\n    client.events.syncStatus.subscribe,\n    client.getSyncStatus,\n    client.getSyncStatus\n  );\n}\n\nfunction useSyncStatusSmooth_withClient(client: OpaqueClient): SyncStatus {\n  const getter = client.getSyncStatus;\n  const [status, setStatus] = useState(getter);\n  const oldStatus = useLatest(getter());\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const unsub = client.events.syncStatus.subscribe(() => {\n      const newStatus = getter();\n      if (\n        oldStatus.current === \"synchronizing\" &&\n        newStatus === \"synchronized\"\n      ) {\n        // Delay delivery of the \"synchronized\" event\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n\n    // Clean up\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [client, getter, oldStatus]);\n\n  return status;\n}\n\n/**\n * Returns the current Liveblocks sync status, and triggers a re-render\n * whenever it changes. Can be used to render a \"Saving...\" indicator, or for\n * preventing that a browser tab can be closed until all changes have been\n * synchronized with the server.\n *\n * @example\n * const syncStatus = useSyncStatus();  // \"synchronizing\" | \"synchronized\"\n * const syncStatus = useSyncStatus({ smooth: true });\n */\nfunction useSyncStatus(options?: UseSyncStatusOptions): SyncStatus {\n  return useSyncStatus_withClient(useClient(), options);\n}\n\n/**\n * useErrorListener is a React hook that allows you to respond to any\n * Liveblocks error, for example room connection errors, errors\n * creating/editing/deleting threads, etc.\n *\n * @example\n * useErrorListener(err => {\n *   console.error(err);\n * })\n */\nfunction useErrorListener(callback: (err: LiveblocksError) => void): void {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () => client.events.error.subscribe((e) => savedCallback.current(e)),\n    [client, savedCallback]\n  );\n}\n\n// eslint-disable-next-line simple-import-sort/exports\nexport {\n  _useInboxNotificationThread as useInboxNotificationThread,\n  _useUser as useUser,\n  _useUserSuspense as useUserSuspense,\n  useInboxNotifications,\n  useInboxNotificationsSuspense,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useDeleteAllInboxNotifications,\n  useDeleteInboxNotification,\n  useErrorListener,\n  useRoomInfo,\n  useRoomInfoSuspense,\n  useSyncStatus,\n  useUnreadInboxNotificationsCount,\n  useUnreadInboxNotificationsCountSuspense,\n  _useUserThreads_experimental as useUserThreads_experimental,\n  _useUserThreadsSuspense_experimental as useUserThreadsSuspense_experimental,\n};\n","const SECONDS = 1000;\nconst MINUTES = 60 * SECONDS;\n\n// Poller config\nexport const config = {\n  SMOOTH_DELAY: 1 * SECONDS,\n\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n\n  NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,\n};\n","import type { AsyncError, AsyncLoading, AsyncSuccess } from \"@liveblocks/core\";\n\n// TODO Maybe move these into @liveblocks/core if they are useful?\n\nexport const ASYNC_LOADING: AsyncLoading = Object.freeze({ isLoading: true });\n\nexport const ASYNC_ERR = (error: Error): AsyncError =>\n  Object.freeze({ isLoading: false, error });\n\nexport function ASYNC_OK<T>(data: T): AsyncSuccess<T>;\nexport function ASYNC_OK<T, F extends string>(\n  field: F,\n  data: T\n): AsyncSuccess<T, F>;\nexport function ASYNC_OK<T, F extends string>(\n  fieldOrData: F | T,\n  data?: T\n): AsyncSuccess<T, F> {\n  if (arguments.length === 1) {\n    // @ts-expect-error too dynamic to type\n    return Object.freeze({ isLoading: false, data: fieldOrData });\n  } else {\n    // @ts-expect-error too dynamic to type\n    return Object.freeze({ isLoading: false, [fieldOrData as F]: data });\n  }\n}\n","/**\n * Like Array.prototype.find(), but for iterables.\n *\n * Returns the first item in the iterable for which the predicate holds.\n * Returns undefined if item matches the predicate.\n */\nexport function find<T>(\n  it: Iterable<T>,\n  predicate: (value: T) => boolean\n): T | undefined {\n  for (const item of it) {\n    if (predicate(item)) return item;\n  }\n  return undefined;\n}\n\n/**\n * Counts the number of items in an iterable that match the predicate.\n */\nexport function count<T>(\n  it: Iterable<T>,\n  predicate: (value: T) => boolean\n): number {\n  let total = 0;\n  for (const item of it) {\n    if (predicate(item)) total++;\n  }\n  return total;\n}\n","export function ensureNotServerSide(): void {\n  // Error early if suspense is used in a server-side context\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense\"\n    );\n  }\n}\n","import type { Reducer } from \"react\";\nimport { useCallback, useReducer } from \"react\";\n\nimport { useLatest } from \"./use-latest\";\n\nconst noop = <T>(state: T) => state;\n\n/**\n * \"Freezes\" a given value, so that it will return the same value/instance on\n * each subsequent render. This can be used to freeze \"initial\" values for\n * custom hooks, much like how `useState(initialState)` or\n * `useRef(initialValue)` works.\n */\nexport function useInitial<T>(value: T): T {\n  // Equivalent to useState(() => value)[0], but slightly more low-level\n  return useReducer<Reducer<T, unknown>>(noop, value)[0];\n}\n\n/**\n * Like `useInitial`, but if the provided value is a function instance, will\n * instead return a stable wrapper that _is_ a stable reference itself between\n * re-renders, but one which will always call the _latest_ provided callback\n * instance.\n */\nexport function useInitialUnlessFunction<T>(latestValue: T): T {\n  const frozenValue = useInitial(latestValue);\n\n  // Normally the Rules of Hooks™ dictate that you should not call hooks\n  // conditionally. In this case, we're good here, because the same code path\n  // will always be taken on every subsequent render here, because we've frozen\n  // the value.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (typeof frozenValue === \"function\") {\n    type Fn = T & ((...args: unknown[]) => unknown);\n    const ref = useLatest(latestValue as Fn);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return useCallback(((...args: unknown[]) => ref.current(...args)) as Fn, [\n      ref,\n    ]);\n  } else {\n    return frozenValue;\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n}\n","import type { MutableRefObject } from \"react\";\nimport { useEffect, useRef } from \"react\";\n\n/**\n * Keeps a ref in sync with a given value that may or may not change on\n * every render.\n *\n * The purpose of this hook is to return a stable ref that can be passed\n * to a callback function so the callback can be registered but still can\n * access the latest value at a later point in time.\n */\nexport function useLatest<T>(value: T): MutableRefObject<T> {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n","/**\n * Drop-in replacement for React 19's `use` hook.\n */\nexport const use =\n  // React.use ||\n  <T>(\n    promise: Promise<T> & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\";\n      value?: T;\n      reason?: unknown;\n    }\n  ): T => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value as T;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  };\n","import type {\n  AsyncResult,\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  CommentData,\n  CommentReaction,\n  CommentUserReaction,\n  DistributiveOmit,\n  HistoryVersion,\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n  ISignal,\n  OpaqueClient,\n  Patchable,\n  Permission,\n  Resolve,\n  RoomNotificationSettings,\n  ThreadData,\n  ThreadDataWithDeleteInfo,\n  ThreadDeleteInfo,\n} from \"@liveblocks/core\";\nimport {\n  autoRetry,\n  batch,\n  compactObject,\n  console,\n  DefaultMap,\n  DerivedSignal,\n  kInternal,\n  MutableSignal,\n  nanoid,\n  nn,\n  shallow,\n  Signal,\n  stringify,\n} from \"@liveblocks/core\";\n\nimport { ASYNC_ERR, ASYNC_LOADING, ASYNC_OK } from \"./lib/AsyncResult\";\nimport { autobind } from \"./lib/autobind\";\nimport { find } from \"./lib/itertools\";\nimport { shallow2 } from \"./lib/shallow2\";\nimport type { ReadonlyThreadDB } from \"./ThreadDB\";\nimport { ThreadDB } from \"./ThreadDB\";\nimport type {\n  HistoryVersionsAsyncResult,\n  InboxNotificationsAsyncResult,\n  RoomNotificationSettingsAsyncResult,\n  ThreadsAsyncResult,\n  ThreadsQuery,\n} from \"./types\";\n\ntype OptimisticUpdate<M extends BaseMetadata> =\n  | CreateThreadOptimisticUpdate<M>\n  | DeleteThreadOptimisticUpdate\n  | EditThreadMetadataOptimisticUpdate<M>\n  | MarkThreadAsResolvedOptimisticUpdate\n  | MarkThreadAsUnresolvedOptimisticUpdate\n  | CreateCommentOptimisticUpdate\n  | EditCommentOptimisticUpdate\n  | DeleteCommentOptimisticUpdate\n  | AddReactionOptimisticUpdate\n  | RemoveReactionOptimisticUpdate\n  | MarkInboxNotificationAsReadOptimisticUpdate\n  | MarkAllInboxNotificationsAsReadOptimisticUpdate\n  | DeleteInboxNotificationOptimisticUpdate\n  | DeleteAllInboxNotificationsOptimisticUpdate\n  | UpdateNotificationSettingsOptimisticUpdate;\n\ntype CreateThreadOptimisticUpdate<M extends BaseMetadata> = {\n  type: \"create-thread\";\n  id: string;\n  roomId: string;\n  thread: ThreadData<M>;\n};\n\ntype DeleteThreadOptimisticUpdate = {\n  type: \"delete-thread\";\n  id: string;\n  roomId: string;\n  threadId: string;\n  deletedAt: Date;\n};\n\ntype EditThreadMetadataOptimisticUpdate<M extends BaseMetadata> = {\n  type: \"edit-thread-metadata\";\n  id: string;\n  threadId: string;\n  metadata: Resolve<Patchable<M>>;\n  updatedAt: Date;\n};\n\ntype MarkThreadAsResolvedOptimisticUpdate = {\n  type: \"mark-thread-as-resolved\";\n  id: string;\n  threadId: string;\n  updatedAt: Date;\n};\n\ntype MarkThreadAsUnresolvedOptimisticUpdate = {\n  type: \"mark-thread-as-unresolved\";\n  id: string;\n  threadId: string;\n  updatedAt: Date;\n};\n\ntype CreateCommentOptimisticUpdate = {\n  type: \"create-comment\";\n  id: string;\n  comment: CommentData;\n};\n\ntype EditCommentOptimisticUpdate = {\n  type: \"edit-comment\";\n  id: string;\n  comment: CommentData;\n};\n\ntype DeleteCommentOptimisticUpdate = {\n  type: \"delete-comment\";\n  id: string;\n  roomId: string;\n  threadId: string;\n  deletedAt: Date;\n  commentId: string;\n};\n\ntype AddReactionOptimisticUpdate = {\n  type: \"add-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  reaction: CommentUserReaction;\n};\n\ntype RemoveReactionOptimisticUpdate = {\n  type: \"remove-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n  userId: string;\n  removedAt: Date;\n};\n\ntype MarkInboxNotificationAsReadOptimisticUpdate = {\n  type: \"mark-inbox-notification-as-read\";\n  id: string;\n  inboxNotificationId: string;\n  readAt: Date;\n};\n\ntype MarkAllInboxNotificationsAsReadOptimisticUpdate = {\n  type: \"mark-all-inbox-notifications-as-read\";\n  id: string;\n  readAt: Date;\n};\n\ntype DeleteInboxNotificationOptimisticUpdate = {\n  type: \"delete-inbox-notification\";\n  id: string;\n  inboxNotificationId: string;\n  deletedAt: Date;\n};\n\ntype DeleteAllInboxNotificationsOptimisticUpdate = {\n  type: \"delete-all-inbox-notifications\";\n  id: string;\n  deletedAt: Date;\n};\n\ntype UpdateNotificationSettingsOptimisticUpdate = {\n  type: \"update-notification-settings\";\n  id: string;\n  roomId: string;\n  settings: Partial<RoomNotificationSettings>;\n};\n\ntype PaginationState = {\n  cursor: string | null; // If `null`, it's the last page\n  hasFetchedAll: boolean;\n  isFetchingMore: boolean;\n  fetchMoreError?: Error;\n  fetchMore: () => void;\n};\n\n/**\n * Valid combinations of field patches to the pagination state.\n */\ntype PaginationStatePatch =\n  | { isFetchingMore: true }\n  | {\n      hasFetchedAll: boolean;\n      isFetchingMore: false;\n      cursor: string | null;\n      fetchMoreError: undefined;\n    }\n  | { isFetchingMore: false; fetchMoreError: Error };\n\n/**\n * Example:\n * makeRoomThreadsQueryKey('room-abc', { xyz: 123, abc: \"red\" })\n * → '[\"room-abc\",{\"color\":\"red\",\"xyz\":123}]'\n */\nexport function makeRoomThreadsQueryKey(\n  roomId: string,\n  query: ThreadsQuery<BaseMetadata> | undefined\n) {\n  return stringify([roomId, query ?? {}]);\n}\n\nexport function makeUserThreadsQueryKey(\n  query: ThreadsQuery<BaseMetadata> | undefined\n) {\n  return stringify(query ?? {});\n}\n\n/**\n * Like Promise<T>, except it will have a synchronously readable `status`\n * field, indicating the status of the promise.\n * This is compatible with React's `use()` promises, hence the name.\n */\ntype UsablePromise<T> = Promise<T> &\n  (\n    | { status: \"pending\" }\n    | { status: \"rejected\"; reason: Error }\n    | { status: \"fulfilled\"; value: T }\n  );\n\n/**\n * Given any Promise<T>, monkey-patches it to a UsablePromise<T>, whose\n * asynchronous status can be synchronously observed.\n */\nfunction usify<T>(promise: Promise<T>): UsablePromise<T> {\n  if (\"status\" in promise) {\n    // Already a usable promise\n    return promise as UsablePromise<T>;\n  }\n\n  const usable: UsablePromise<T> = promise as UsablePromise<T>;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      (usable as UsablePromise<T> & { status: \"fulfilled\" }).value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      (usable as UsablePromise<T> & { status: \"rejected\" }).reason =\n        err as Error;\n    }\n  );\n  return usable;\n}\n\nconst noop = Promise.resolve();\n\n/**\n * The PaginatedResource helper class is responsible for and abstracts away the\n * following:\n *\n * - It receives a \"page fetch\" function of the following signature:\n *     (cursor?: Cursor) => Promise<Cursor | null>\n *\n * - Note that there is no data in the returned value!!! Storing or handling\n *   the data is NOT the responsibility of this helper class. This may be a bit\n *   counter-intuitive at first. The provided page fetcher callback function\n *   should store the data elsewhere, outside of the PaginatedResource state\n *   machine, as a side-effect of this \"page fetch\" function, but it can always\n *   assume the happy path. This class will deal with all the required\n *   complexity for handling the non-happy path conditions.\n *\n * - This class exposes a \"getter\" that you can call synchronously to get the\n *   current fetching/paginationo status for this resource. It will look like\n *   the pagination hooks, except it will not contain any data. In other words,\n *   it can return any of these shapes:\n *\n *   - { isLoading: true }\n *   - {\n *       isLoading: false,\n *       error: new Error('error while fetching'),\n *     }\n *   - {\n *       isLoading: false,\n *       data: {\n *         cursor: string | null;\n *         isFetchingMore: boolean;\n *         fetchMoreError?: Error;\n *       }\n *     }\n *\n * - When calling the getter multiple times, the return value is always\n *   referentially equal to the previous call.\n *\n * - When in this error state, the error will remain in error state for\n *   5 seconds. After those 5 seconds, the resource status gets reset, and the\n *   next time the \"getter\" is accessed, the resource will re-initiate the\n *   initial fetching process.\n *\n * - This class exposes an Observable that is notified whenever the state\n *   changes. For now, this observable can be used to call a no-op update to\n *   the Store (eg `.set(state => ({...state})`), to trigger a re-render for\n *   all React components.\n *\n * - This class will also expose a function that can be exposed as the\n *   `fetchMore` function which can be called externally.\n *\n * - This nicely bundles the internal state that should always be mutated\n *   together to manage all the pagination state.\n *\n * - For InboxNotifications we will have one instance of this class.\n *\n * - For Threads we will have one for each query.\n *\n * ---------------------------------------------------------------------------\n *\n * NOT 100% SURE ABOUT THE FOLLOWING YET:\n *\n * - Maybe we could eventually also let this manage the \"delta updates\" and the\n *   \"last requested at\" for this resource? Seems nice to add it here somehow.\n *   Need to think about the exact implications though.\n *\n * @internal Only exported for unit tests.\n */\nexport class PaginatedResource {\n  readonly #signal: Signal<AsyncResult<PaginationState>>;\n  public readonly signal: ISignal<AsyncResult<PaginationState>>;\n\n  #fetchPage: (cursor?: string) => Promise<string | null>;\n  #pendingFetchMore: Promise<void> | null;\n\n  constructor(fetchPage: (cursor?: string) => Promise<string | null>) {\n    this.#signal = new Signal<AsyncResult<PaginationState>>(ASYNC_LOADING);\n    this.#fetchPage = fetchPage;\n    this.#pendingFetchMore = null;\n    this.signal = this.#signal.asReadonly();\n\n    autobind(this);\n  }\n\n  get(): AsyncResult<PaginationState> {\n    return this.#signal.get();\n  }\n\n  #patch(patch: PaginationStatePatch): void {\n    const state = this.#signal.get();\n    if (state.data === undefined) return;\n    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));\n  }\n\n  async #fetchMore(): Promise<void> {\n    const state = this.#signal.get();\n    if (!state.data?.cursor || state.data.isFetchingMore) {\n      // Either:\n      // - We don't have a cursor yet (first fetch not happened successfully yet)\n      // - We don't have a cursor any longer (we're on the last page)\n      return;\n    }\n\n    this.#patch({ isFetchingMore: true });\n    try {\n      const nextCursor = await this.#fetchPage(state.data.cursor);\n      this.#patch({\n        cursor: nextCursor,\n        hasFetchedAll: nextCursor === null,\n        fetchMoreError: undefined,\n        isFetchingMore: false,\n      });\n    } catch (err) {\n      this.#patch({\n        isFetchingMore: false,\n        fetchMoreError: err as Error,\n      });\n    }\n  }\n\n  public fetchMore(): Promise<void> {\n    // We do not proceed with fetching more if any of the following is true:\n    // 1) the pagination state has not be initialized\n    // 2) the cursor is null, i.e., there are no more pages to fetch\n    // 3) a request to fetch more is currently in progress\n    const state = this.#signal.get();\n    if (!state.data?.cursor) return noop;\n\n    // Case (3)\n    if (!this.#pendingFetchMore) {\n      this.#pendingFetchMore = this.#fetchMore().finally(() => {\n        this.#pendingFetchMore = null;\n      });\n    }\n    return this.#pendingFetchMore;\n  }\n\n  #cachedPromise: UsablePromise<void> | null = null;\n\n  public waitUntilLoaded(): UsablePromise<void> {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n\n    // Wrap the request to load room threads (and notifications) in an auto-retry function so that if the request fails,\n    // we retry for at most 5 times with incremental backoff delays. If all retries fail, the auto-retry function throws an error\n    const initialPageFetch$ = autoRetry(\n      () => this.#fetchPage(/* cursor */ undefined),\n      5,\n      [5000, 5000, 10000, 15000]\n    );\n\n    const promise = usify(initialPageFetch$);\n\n    // NOTE: However tempting it may be, we cannot simply move this block into\n    // the promise definition above. The reason is that we should not call\n    // notify() before the UsablePromise is actually in resolved status. While\n    // still inside the .then() block, the UsablePromise is still in pending status.\n    promise.then(\n      (cursor) => {\n        this.#signal.set(\n          ASYNC_OK({\n            cursor,\n            hasFetchedAll: cursor === null,\n            isFetchingMore: false,\n            fetchMoreError: undefined,\n            fetchMore: this.fetchMore,\n          })\n        );\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err as Error));\n\n        // Wait for 5 seconds before removing the request\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5_000);\n      }\n    );\n\n    this.#cachedPromise =\n      promise as UsablePromise<unknown> as UsablePromise<void>;\n    return this.#cachedPromise;\n  }\n}\n\n// TODO Find better name?\ntype LoadableResource<T> = {\n  signal: ISignal<T>;\n  waitUntilLoaded: () => UsablePromise<void>;\n};\n\nclass SinglePageResource {\n  readonly #signal: Signal<AsyncResult<void>>;\n  public readonly signal: ISignal<AsyncResult<void>>;\n\n  #fetchPage: () => Promise<void>;\n\n  constructor(fetchPage: () => Promise<void>) {\n    this.#signal = new Signal<AsyncResult<void>>(ASYNC_LOADING);\n    this.signal = this.#signal.asReadonly();\n    this.#fetchPage = fetchPage;\n\n    autobind(this);\n  }\n\n  get(): AsyncResult<void> {\n    return this.#signal.get();\n  }\n\n  #cachedPromise: UsablePromise<void> | null = null;\n\n  public waitUntilLoaded(): UsablePromise<void> {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n\n    // Wrap the request to load room threads (and notifications) in an auto-retry function so that if the request fails,\n    // we retry for at most 5 times with incremental backoff delays. If all retries fail, the auto-retry function throws an error\n    const initialFetcher$ = autoRetry(\n      () => this.#fetchPage(),\n      5,\n      [5000, 5000, 10000, 15000]\n    );\n\n    const promise = usify(initialFetcher$);\n\n    // NOTE: However tempting it may be, we cannot simply move this block into\n    // the promise definition above. The reason is that we should not call\n    // notify() before the UsablePromise is actually in resolved status. While\n    // still inside the .then() block, the UsablePromise is still in pending status.\n    promise.then(\n      () => {\n        this.#signal.set(ASYNC_OK(undefined));\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err as Error));\n\n        // Wait for 5 seconds before removing the request\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5_000);\n      }\n    );\n\n    this.#cachedPromise = promise;\n    return promise;\n  }\n}\n\ntype RoomId = string;\ntype UserQueryKey = string;\ntype RoomQueryKey = string;\n\n/**\n * A lookup table (LUT) for all the history versions.\n */\ntype VersionsLUT = DefaultMap<RoomId, Map<string, HistoryVersion>>;\n\n/**\n * A lookup table (LUT) for all the inbox notifications.\n */\ntype NotificationsLUT = Map<string, InboxNotificationData>;\n\n/**\n * A lookup table (LUT) for all the room notification settings.\n */\ntype SettingsLUT = Map<RoomId, RoomNotificationSettings>;\n\n/**\n * Notification settings by room ID.\n * e.g. { 'room-abc': { threads: \"all\" },\n *        'room-def': { threads: \"replies_and_mentions\" },\n *        'room-xyz': { threads: \"none\" },\n *      }\n */\ntype SettingsByRoomId = Record<RoomId, RoomNotificationSettings>;\n\ntype PermissionHintsLUT = DefaultMap<RoomId, Set<Permission>>;\n\nexport type CleanThreadifications<M extends BaseMetadata> =\n  // Threads + Notifications = Threadifications\n  CleanThreads<M> &\n    //\n    CleanNotifications;\n\nexport type CleanThreads<M extends BaseMetadata> = {\n  /**\n   * Keep track of loading and error status of all the queries made by the client.\n   * e.g. 'room-abc-{\"color\":\"red\"}'  - ok\n   * e.g. 'room-abc-{}'               - loading\n   */\n  threadsDB: ReadonlyThreadDB<M>;\n};\n\nexport type CleanNotifications = {\n  /**\n   * All inbox notifications in a sorted array, optimistic updates applied.\n   */\n  sortedNotifications: InboxNotificationData[];\n\n  /**\n   * Inbox notifications by ID.\n   * e.g. `in_${string}`\n   */\n  notificationsById: Record<string, InboxNotificationData>;\n};\n\nfunction createStore_forNotifications() {\n  const signal = new MutableSignal<NotificationsLUT>(new Map());\n\n  function markRead(notificationId: string, readAt: Date) {\n    signal.mutate((lut) => {\n      const existing = lut.get(notificationId);\n      if (!existing) {\n        return false;\n      }\n      lut.set(notificationId, { ...existing, readAt });\n      return true;\n    });\n  }\n\n  function markAllRead(readAt: Date) {\n    signal.mutate((lut) => {\n      for (const n of lut.values()) {\n        n.readAt = readAt;\n      }\n    });\n  }\n\n  function deleteOne(inboxNotificationId: string) {\n    signal.mutate((lut) => lut.delete(inboxNotificationId));\n  }\n\n  function clear() {\n    signal.mutate((lut) => lut.clear());\n  }\n\n  function applyDelta(\n    newNotifications: InboxNotificationData[],\n    deletedNotifications: InboxNotificationDeleteInfo[]\n  ) {\n    signal.mutate((lut) => {\n      let mutated = false;\n\n      // Add new notifications or update existing notifications if the existing notification is older than the new notification.\n      for (const n of newNotifications) {\n        const existing = lut.get(n.id);\n        // If the notification already exists, we need to compare the two notifications to determine which one is newer.\n        if (existing) {\n          const result = compareInboxNotifications(existing, n);\n          // If the existing notification is newer than the new notification, we do not update the existing notification.\n          if (result === 1) continue;\n        }\n\n        // If the new notification is newer than the existing notification, we update the existing notification.\n        lut.set(n.id, n);\n        mutated = true;\n      }\n\n      for (const n of deletedNotifications) {\n        lut.delete(n.id);\n        mutated = true;\n      }\n      return mutated;\n    });\n  }\n\n  function updateAssociatedNotification(newComment: CommentData) {\n    signal.mutate((lut) => {\n      const existing = find(\n        lut.values(),\n        (notification) =>\n          notification.kind === \"thread\" &&\n          notification.threadId === newComment.threadId\n      );\n      if (!existing) return false; // Nothing to udate here\n\n      // If the thread has an inbox notification associated with it, we update the notification's `notifiedAt` and `readAt` values\n      lut.set(existing.id, {\n        ...existing,\n        notifiedAt: newComment.createdAt,\n        readAt: newComment.createdAt,\n      });\n      return true;\n    });\n  }\n\n  function upsert(notification: InboxNotificationData) {\n    signal.mutate((lut) => {\n      lut.set(notification.id, notification);\n    });\n  }\n\n  return {\n    signal: signal.asReadonly(),\n\n    // Mutations\n    markAllRead,\n    markRead,\n    delete: deleteOne,\n    applyDelta,\n    clear,\n    updateAssociatedNotification,\n    upsert,\n  };\n}\n\nfunction createStore_forRoomNotificationSettings(\n  updates: ISignal<readonly OptimisticUpdate<BaseMetadata>[]>\n) {\n  const baseSignal = new MutableSignal<SettingsLUT>(new Map());\n\n  function update(roomId: string, settings: RoomNotificationSettings): void {\n    baseSignal.mutate((lut) => {\n      lut.set(roomId, settings);\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, updates, (base, updates) =>\n      applyOptimisticUpdates_forSettings(base, updates)\n    ),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forHistoryVersions() {\n  const baseSignal = new MutableSignal(\n    new DefaultMap(() => new Map()) as VersionsLUT\n  );\n\n  function update(roomId: string, versions: HistoryVersion[]): void {\n    baseSignal.mutate((lut) => {\n      const versionsById = lut.getOrCreate(roomId);\n      for (const version of versions) {\n        versionsById.set(version.id, version);\n      }\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, (hv) =>\n      Object.fromEntries(\n        [...hv].map(([roomId, versions]) => [\n          roomId,\n          Object.fromEntries(versions),\n        ])\n      )\n    ),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forPermissionHints() {\n  const signal = new MutableSignal<PermissionHintsLUT>(\n    new DefaultMap(() => new Set())\n  );\n\n  function update(newHints: Record<string, Permission[]>) {\n    signal.mutate((lut) => {\n      for (const [roomId, newPermissions] of Object.entries(newHints)) {\n        // Get the existing set of permissions for the room and only ever add permission to this set\n        const existing = lut.getOrCreate(roomId);\n        // Add the new permissions to the set of existing permissions\n        for (const permission of newPermissions) {\n          existing.add(permission);\n        }\n      }\n    });\n  }\n\n  return {\n    signal: signal.asReadonly(),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forOptimistic<M extends BaseMetadata>(\n  client: Client<BaseUserMeta, M>\n) {\n  const signal = new Signal<readonly OptimisticUpdate<M>[]>([]);\n  const syncSource = client[kInternal].createSyncSource();\n\n  // Automatically update the global sync status as an effect whenever there\n  // are any optimistic updates\n  signal.subscribe(() =>\n    syncSource.setSyncStatus(\n      signal.get().length > 0 ? \"synchronizing\" : \"synchronized\"\n    )\n  );\n\n  function add(\n    optimisticUpdate: DistributiveOmit<OptimisticUpdate<M>, \"id\">\n  ): string {\n    const id = nanoid();\n    const newUpdate: OptimisticUpdate<M> = { ...optimisticUpdate, id };\n    signal.set((state) => [...state, newUpdate]);\n    return id;\n  }\n\n  function remove(optimisticId: string): void {\n    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));\n  }\n\n  return {\n    signal: signal.asReadonly(),\n\n    // Mutations\n    add,\n    remove,\n  };\n}\n\nexport class UmbrellaStore<M extends BaseMetadata> {\n  #client: Client<BaseUserMeta, M>;\n\n  //\n  // Internally, the UmbrellaStore keeps track of a few source signals that can\n  // be set and mutated individually. When any of those are mutated then the\n  // clean \"external state\" is recomputed.\n  //\n  //   Mutate inputs...                                             ...observe clean/consistent output!\n  //\n  //            .-> Base ThreadDB ---------+                 +----> Clean threads by ID       (Part 1)\n  //           /                           |                 |\n  //   mutate ----> Base Notifications --+ |                 | +--> Clean notifications       (Part 1)\n  //          \\                          | |                 | |    & notifications by ID\n  //         | \\                         | |      Apply      | |\n  //         |   `-> OptimisticUpdates --+--+--> Optimistic --+-+--> Notification Settings    (Part 2)\n  //          \\                          |        Updates       |\n  //           `------- etc etc ---------+                      +--> History Versions         (Part 3)\n  //                       ^\n  //                       |\n  //                       |                        ^                  ^\n  //                    Signal                      |                  |\n  //                      or                   DerivedSignal      DerivedSignals\n  //                  MutableSignal\n  //\n\n  //\n  // Input signals.\n  // (Can be mutated directly.)\n  //\n  // XXX_vincent Now that we have createStore_forX, we should probably also change\n  // `threads` to this pattern, ie create a createStore_forThreads helper as\n  // well. It almost works like that already anyway!\n  readonly threads: ThreadDB<M>; // Exposes its signal under `.signal` prop\n  readonly notifications: ReturnType<typeof createStore_forNotifications>;\n  readonly roomNotificationSettings: ReturnType<typeof createStore_forRoomNotificationSettings>; // prettier-ignore\n  readonly historyVersions: ReturnType<typeof createStore_forHistoryVersions>;\n  readonly permissionHints: ReturnType<typeof createStore_forPermissionHints>;\n  readonly optimisticUpdates: ReturnType<typeof createStore_forOptimistic<M>>;\n\n  //\n  // Output signals.\n  // (Readonly, clean, consistent. With optimistic updates applied.)\n  //\n  // Note that the output of threadifications signal is the same as the ones for\n  // threads and notifications separately, but the threadifications signal will\n  // be updated whenever either of them change.\n  //\n  readonly outputs: {\n    readonly threadifications: DerivedSignal<CleanThreadifications<M>>;\n    readonly threads: DerivedSignal<ReadonlyThreadDB<M>>;\n    readonly loadingRoomThreads: DefaultMap<\n      RoomQueryKey,\n      LoadableResource<ThreadsAsyncResult<M>>\n    >;\n    readonly loadingUserThreads: DefaultMap<\n      UserQueryKey,\n      LoadableResource<ThreadsAsyncResult<M>>\n    >;\n    readonly notifications: DerivedSignal<CleanNotifications>;\n\n    readonly loadingNotifications: LoadableResource<InboxNotificationsAsyncResult>;\n    readonly settingsByRoomId: DefaultMap<\n      RoomId,\n      LoadableResource<RoomNotificationSettingsAsyncResult>\n    >;\n    readonly versionsByRoomId: DefaultMap<\n      RoomId,\n      LoadableResource<HistoryVersionsAsyncResult>\n    >;\n  };\n\n  // Notifications\n  #notificationsLastRequestedAt: Date | null = null; // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.\n  #notificationsPaginationState: PaginatedResource;\n\n  // Room Threads\n  #roomThreadsLastRequestedAtByRoom = new Map<RoomId, Date>();\n\n  // User Threads\n  #userThreadsLastRequestedAt: Date | null = null;\n\n  // Room versions\n  #roomVersionsLastRequestedAtByRoom = new Map<RoomId, Date>();\n\n  constructor(client: OpaqueClient) {\n    this.#client = client[kInternal].as<M>();\n\n    this.optimisticUpdates = createStore_forOptimistic<M>(this.#client);\n    this.permissionHints = createStore_forPermissionHints();\n\n    this.#notificationsPaginationState = new PaginatedResource(\n      async (cursor?: string) => {\n        const result = await this.#client.getInboxNotifications({ cursor });\n\n        this.updateThreadifications(result.threads, result.inboxNotifications);\n\n        // We initialize the `_lastRequestedNotificationsAt` date using the server timestamp after we've loaded the first page of inbox notifications.\n        if (this.#notificationsLastRequestedAt === null) {\n          this.#notificationsLastRequestedAt = result.requestedAt;\n        }\n\n        const nextCursor = result.nextCursor;\n        return nextCursor;\n      }\n    );\n\n    this.threads = new ThreadDB();\n\n    this.notifications = createStore_forNotifications();\n    this.roomNotificationSettings = createStore_forRoomNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n    this.historyVersions = createStore_forHistoryVersions();\n\n    const threadifications = DerivedSignal.from(\n      this.threads.signal,\n      this.notifications.signal,\n      this.optimisticUpdates.signal,\n      (ts, ns, updates) =>\n        applyOptimisticUpdates_forThreadifications(ts, ns, updates)\n    );\n\n    const threads = DerivedSignal.from(threadifications, (s) => s.threadsDB);\n\n    const notifications = DerivedSignal.from(\n      threadifications,\n      (s) => ({\n        sortedNotifications: s.sortedNotifications,\n        notificationsById: s.notificationsById,\n      }),\n      shallow\n    );\n\n    const loadingUserThreads = new DefaultMap(\n      (queryKey: UserQueryKey): LoadableResource<ThreadsAsyncResult<M>> => {\n        const query = JSON.parse(queryKey) as ThreadsQuery<M>;\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[\n            kInternal\n          ].httpClient.getUserThreads_experimental({\n            cursor,\n            query,\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications\n          );\n\n          this.permissionHints.update(result.permissionHints);\n\n          // We initialize the `_userThreadsLastRequestedAt` date using the server timestamp after we've loaded the first page of inbox notifications.\n          if (this.#userThreadsLastRequestedAt === null) {\n            this.#userThreadsLastRequestedAt = result.requestedAt;\n          }\n\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): ThreadsAsyncResult<M> => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const threads = this.outputs.threads.get().findMany(\n            undefined, // Do _not_ filter by roomId\n            query ?? {},\n            \"desc\"\n          );\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const loadingRoomThreads = new DefaultMap(\n      (queryKey: RoomQueryKey): LoadableResource<ThreadsAsyncResult<M>> => {\n        const [roomId, query] = JSON.parse(queryKey) as [\n          roomId: RoomId,\n          query: ThreadsQuery<M>,\n        ];\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[kInternal].httpClient.getThreads({\n            roomId,\n            cursor,\n            query,\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications\n          );\n\n          this.permissionHints.update(result.permissionHints);\n\n          const lastRequestedAt =\n            this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n\n          /**\n           * We set the `lastRequestedAt` value for the room to the timestamp returned by the current request if:\n           * 1. The `lastRequestedAt` value for the room has not been set\n           * OR\n           * 2. The `lastRequestedAt` value for the room is older than the timestamp returned by the current request\n           */\n          if (\n            lastRequestedAt === undefined ||\n            lastRequestedAt > result.requestedAt\n          ) {\n            this.#roomThreadsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): ThreadsAsyncResult<M> => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const threads = this.outputs.threads\n            .get()\n            .findMany(roomId, query ?? {}, \"asc\");\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const loadingNotifications = {\n      signal: DerivedSignal.from((): InboxNotificationsAsyncResult => {\n        const resource = this.#notificationsPaginationState;\n\n        const result = resource.get();\n        if (result.isLoading || result.error) {\n          return result;\n        }\n\n        const page = result.data;\n        return {\n          isLoading: false,\n          inboxNotifications:\n            this.outputs.notifications.get().sortedNotifications,\n          hasFetchedAll: page.hasFetchedAll,\n          isFetchingMore: page.isFetchingMore,\n          fetchMoreError: page.fetchMoreError,\n          fetchMore: page.fetchMore,\n        };\n      }),\n\n      waitUntilLoaded: this.#notificationsPaginationState.waitUntilLoaded,\n    };\n\n    const settingsByRoomId = new DefaultMap((roomId: RoomId) => {\n      const resource = new SinglePageResource(async () => {\n        const room = this.#client.getRoom(roomId);\n        if (room === null) {\n          throw new Error(`Room '${roomId}' is not available on client`);\n        }\n\n        const result = await room.getNotificationSettings();\n        this.roomNotificationSettings.update(roomId, result);\n      });\n\n      const signal = DerivedSignal.from(() => {\n        const result = resource.get();\n        if (result.isLoading || result.error) {\n          return result;\n        } else {\n          return ASYNC_OK(\n            \"settings\",\n            nn(this.roomNotificationSettings.signal.get()[roomId])\n          );\n        }\n      }, shallow);\n\n      return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n    });\n\n    const versionsByRoomId = new DefaultMap(\n      (roomId: RoomId): LoadableResource<HistoryVersionsAsyncResult> => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n\n          const result = await room[kInternal].listTextVersions();\n          this.historyVersions.update(roomId, result.versions);\n\n          const lastRequestedAt =\n            this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n\n          if (\n            lastRequestedAt === undefined ||\n            lastRequestedAt > result.requestedAt\n          ) {\n            this.#roomVersionsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n        });\n\n        const signal = DerivedSignal.from((): HistoryVersionsAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"versions\",\n              Object.values(this.historyVersions.signal.get()[roomId] ?? {})\n            );\n          }\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    this.outputs = {\n      threadifications,\n      threads,\n      loadingRoomThreads,\n      loadingUserThreads,\n      notifications,\n      loadingNotifications,\n      settingsByRoomId,\n      versionsByRoomId,\n    };\n\n    // Auto-bind all of this class’ methods here, so we can use stable\n    // references to them (most important for use in useSyncExternalStore)\n    autobind(this);\n  }\n\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found.\n   */\n  public markInboxNotificationRead(\n    inboxNotificationId: string,\n    readAt: Date,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markRead(inboxNotificationId, readAt);\n    });\n  }\n\n  public markAllInboxNotificationsRead(\n    optimisticId: string,\n    readAt: Date\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markAllRead(readAt);\n    });\n  }\n\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  public deleteInboxNotification(\n    inboxNotificationId: string,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.delete(inboxNotificationId);\n    });\n  }\n\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  public deleteAllInboxNotifications(optimisticId: string): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.clear();\n    });\n  }\n\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  public createThread(\n    optimisticId: string,\n    thread: Readonly<ThreadDataWithDeleteInfo<M>>\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.threads.upsert(thread);\n    });\n  }\n\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted; or\n   * - The thread ID was updated more recently than the optimistic update's\n   *   timestamp (if given)\n   */\n  #updateThread(\n    threadId: string,\n    optimisticId: string | null,\n    callback: (\n      thread: Readonly<ThreadDataWithDeleteInfo<M>>\n    ) => Readonly<ThreadDataWithDeleteInfo<M>>,\n    updatedAt?: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    batch(() => {\n      if (optimisticId !== null) {\n        this.optimisticUpdates.remove(optimisticId);\n      }\n\n      const db = this.threads;\n      const existing = db.get(threadId);\n      if (!existing) return;\n      if (!!updatedAt && existing.updatedAt > updatedAt) return;\n      db.upsert(callback(existing));\n    });\n  }\n\n  public patchThread(\n    threadId: string,\n    optimisticId: string | null,\n    patch: {\n      // Only these fields are currently supported to patch\n      metadata?: M;\n      resolved?: boolean;\n    },\n    updatedAt: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => ({ ...thread, ...compactObject(patch) }),\n      updatedAt\n    );\n  }\n\n  public addReaction(\n    threadId: string,\n    optimisticId: string | null,\n    commentId: string,\n    reaction: CommentUserReaction,\n    createdAt: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n\n  public removeReaction(\n    threadId: string,\n    optimisticId: string | null,\n    commentId: string,\n    emoji: string,\n    userId: string,\n    removedAt: Date\n  ): void {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) =>\n        applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted\n   */\n  public deleteThread(threadId: string, optimisticId: string | null): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: new Date(), deletedAt: new Date() })\n    );\n  }\n\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  public createComment(newComment: CommentData, optimisticId: string): void {\n    // Batch 1️⃣ + 2️⃣ + 3️⃣\n    batch(() => {\n      // 1️⃣\n      this.optimisticUpdates.remove(optimisticId);\n\n      // If the associated thread is not found, we cannot create a comment under it\n      const existingThread = this.threads.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n\n      // 2️⃣ Update the thread instance by adding a comment under it\n      this.threads.upsert(applyUpsertComment(existingThread, newComment));\n\n      // 3️⃣ Update the associated inbox notification (if any)\n      this.notifications.updateAssociatedNotification(newComment);\n    });\n  }\n\n  public editComment(\n    threadId: string,\n    optimisticId: string,\n    editedComment: CommentData\n  ): void {\n    return this.#updateThread(threadId, optimisticId, (thread) =>\n      applyUpsertComment(thread, editedComment)\n    );\n  }\n\n  public deleteComment(\n    threadId: string,\n    optimisticId: string,\n    commentId: string,\n    deletedAt: Date\n  ): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n\n  public updateThreadifications(\n    threads: ThreadData<M>[],\n    notifications: InboxNotificationData[],\n    deletedThreads: ThreadDeleteInfo[] = [],\n    deletedNotifications: InboxNotificationDeleteInfo[] = []\n  ): void {\n    batch(() => {\n      this.threads.applyDelta(threads, deletedThreads);\n      this.notifications.applyDelta(notifications, deletedNotifications);\n    });\n  }\n\n  /**\n   * Updates existing notification setting for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  public updateRoomNotificationSettings(\n    roomId: string,\n    optimisticId: string,\n    settings: Readonly<RoomNotificationSettings>\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.roomNotificationSettings.update(roomId, settings);\n    });\n  }\n\n  public async fetchNotificationsDeltaUpdate(signal: AbortSignal) {\n    const lastRequestedAt = this.#notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n\n    const result = await this.#client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n\n  public async fetchRoomThreadsDeltaUpdate(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === undefined) {\n      return;\n    }\n\n    const updates = await this.#client[kInternal].httpClient.getThreadsSince({\n      roomId,\n      since: lastRequestedAt,\n      signal,\n    });\n\n    this.updateThreadifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted\n    );\n\n    this.permissionHints.update(updates.permissionHints);\n\n    if (lastRequestedAt < updates.requestedAt) {\n      // Update the `lastRequestedAt` value for the room to the timestamp returned by the current request\n      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n\n  public async fetchUserThreadsDeltaUpdate(signal: AbortSignal) {\n    const lastRequestedAt = this.#userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n\n    const result = await this.#client[\n      kInternal\n    ].httpClient.getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n\n    this.permissionHints.update(result.permissionHints);\n  }\n\n  public async fetchRoomVersionsDeltaUpdate(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === undefined) {\n      return;\n    }\n\n    const room = nn(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n\n    const updates = await room[kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    this.historyVersions.update(roomId, updates.versions);\n\n    if (lastRequestedAt < updates.requestedAt) {\n      // Update the `lastRequestedAt` value for the room to the timestamp returned by the current request\n      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n\n  public async refreshRoomNotificationSettings(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const room = nn(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getNotificationSettings({ signal });\n    this.roomNotificationSettings.update(roomId, result);\n  }\n}\n\n/**\n * Applies optimistic updates, removes deleted threads, sorts results in\n * a stable way, removes internal fields that should not be exposed publicly.\n */\nfunction applyOptimisticUpdates_forThreadifications<M extends BaseMetadata>(\n  baseThreadsDB: ThreadDB<M>,\n  notificationsLUT: NotificationsLUT,\n  optimisticUpdates: readonly OptimisticUpdate<M>[]\n): CleanThreadifications<M> {\n  const threadsDB = baseThreadsDB.clone();\n  let notificationsById = Object.fromEntries(notificationsLUT);\n\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        // If the thread has been updated since the optimistic update, we do not apply the update\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata,\n          },\n        });\n        break;\n      }\n\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n\n        const inboxNotification = Object.values(notificationsById).find(\n          (notification) =>\n            notification.kind === \"thread\" &&\n            notification.threadId === thread.id\n        );\n\n        if (inboxNotification === undefined) {\n          break;\n        }\n\n        notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt,\n        };\n\n        break;\n      }\n\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: [],\n        });\n        break;\n      }\n\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];\n\n        // If the inbox notification doesn't exist, we do not apply the update\n        if (ibn === undefined) {\n          break;\n        }\n\n        notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt,\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in notificationsById) {\n          const ibn = notificationsById[id];\n\n          // If the inbox notification doesn't exist, we do not apply the update\n          if (ibn === undefined) {\n            break;\n          }\n\n          notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt,\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        notificationsById = {};\n        break;\n      }\n    }\n  }\n\n  // TODO Maybe consider also removing these from the inboxNotificationsById registry?\n  const sortedNotifications =\n    // Sort so that the most recent notifications are first\n    Object.values(notificationsById)\n      .filter((ibn) =>\n        ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== undefined : true\n      )\n      .sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime());\n\n  return {\n    sortedNotifications,\n    notificationsById,\n    threadsDB,\n  };\n}\n\n/**\n * Applies optimistic updates, removes deleted threads, sorts results in\n * a stable way, removes internal fields that should not be exposed publicly.\n */\nfunction applyOptimisticUpdates_forSettings(\n  settingsLUT: SettingsLUT,\n  optimisticUpdates: readonly OptimisticUpdate<BaseMetadata>[]\n): SettingsByRoomId {\n  const settingsByRoomId = Object.fromEntries(settingsLUT);\n\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"update-notification-settings\": {\n        const settings = settingsByRoomId[optimisticUpdate.roomId];\n\n        // If the inbox notification doesn't exist, we do not apply the update\n        if (settings === undefined) {\n          break;\n        }\n\n        settingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings,\n        };\n      }\n    }\n  }\n  return settingsByRoomId;\n}\n\n/**\n * Compares two inbox notifications to determine which one is newer.\n * @param inboxNotificationA The first inbox notification to compare.\n * @param inboxNotificationB The second inbox notification to compare.\n * @returns 1 if inboxNotificationA is newer, -1 if inboxNotificationB is newer, or 0 if they are the same age or can't be compared.\n */\nexport function compareInboxNotifications(\n  inboxNotificationA: InboxNotificationData,\n  inboxNotificationB: InboxNotificationData\n): number {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n\n  // notifiedAt times are the same, compare readAt times if both are not null\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt\n      ? 1\n      : inboxNotificationA.readAt < inboxNotificationB.readAt\n        ? -1\n        : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n\n  // If all dates are equal, return 0\n  return 0;\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyUpsertComment<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  comment: CommentData\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not apply the update\n  if (thread.deletedAt !== undefined) {\n    // Note: only the unit tests are passing in deleted threads here. In all\n    // production code, this is never invoked for deleted threads.\n    return thread;\n  }\n\n  // Validate that the comment belongs to the thread\n  if (comment.threadId !== thread.id) {\n    console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (existingComment) => existingComment.id === comment.id\n  );\n\n  // If the comment doesn't exist in the thread, add the comment\n  if (existingComment === undefined) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment],\n    };\n\n    return updatedThread;\n  }\n\n  // If the comment exists in the thread and has been deleted, do not apply the update\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  // Proceed to update the comment if:\n  // 1. The existing comment has not been edited\n  // 2. The incoming comment has not been edited (i.e. it's a new comment)\n  // 3. The incoming comment has been edited more recently than the existing comment\n  if (\n    existingComment.editedAt === undefined ||\n    comment.editedAt === undefined ||\n    existingComment.editedAt <= comment.editedAt\n  ) {\n    const updatedComments = thread.comments.map((existingComment) =>\n      existingComment.id === comment.id ? comment : existingComment\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments,\n    };\n    return updatedThread;\n  }\n\n  return thread;\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyDeleteComment<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  commentId: string,\n  deletedAt: Date\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not delete the comment\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we cannot perform the deletion\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the deletion request, we do not delete the comment\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          deletedAt,\n          // We optimistically remove the comment body and attachments when marking it as deleted\n          body: undefined,\n          attachments: [],\n        }\n      : comment\n  );\n\n  // If all comments have been deleted (or there are no comments in the first\n  // place), we mark the thread as deleted.\n  if (updatedComments.every((comment) => comment.deletedAt !== undefined)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n    };\n  }\n\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments,\n  };\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyAddReaction<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  commentId: string,\n  reaction: CommentUserReaction\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not add the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not add the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction addition request, we do not add the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: upsertReaction(comment.reactions, reaction),\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments,\n  };\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyRemoveReaction<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  commentId: string,\n  emoji: string,\n  userId: string,\n  removedAt: Date\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not remove the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not remove the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction removal request, we do not remove the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: comment.reactions\n            .map((reaction) =>\n              reaction.emoji === emoji\n                ? {\n                    ...reaction,\n                    users: reaction.users.filter((user) => user.id !== userId),\n                  }\n                : reaction\n            )\n            .filter((reaction) => reaction.users.length > 0), // Remove reactions with no users left\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments,\n  };\n}\n\nfunction upsertReaction(\n  reactions: CommentReaction[],\n  reaction: CommentUserReaction\n): CommentReaction[] {\n  const existingReaction = reactions.find(\n    (existingReaction) => existingReaction.emoji === reaction.emoji\n  );\n\n  // If the reaction doesn't exist in the comment, we add it\n  if (existingReaction === undefined) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }],\n      },\n    ];\n  }\n\n  // If the reaction exists in the comment, we add the user to the reaction if they are not already in it\n  if (\n    existingReaction.users.some((user) => user.id === reaction.userId) === false\n  ) {\n    return reactions.map((existingReaction) =>\n      existingReaction.emoji === reaction.emoji\n        ? {\n            ...existingReaction,\n            users: [...existingReaction.users, { id: reaction.userId }],\n          }\n        : existingReaction\n    );\n  }\n\n  return reactions;\n}\n","/**\n * Binds all methods on a class instance to \"this\". Call this from the\n * constructor if you want to be able to reference the methods like this:\n *\n * ------------------------------------------------------------------------\n *\n *   class MyClass {}\n *   const thing = new MyClass();\n *   const getter1 = thing.someMethod;     // ❌ Cannot refer to someMethod this way, because \"this\" will not be bound to \"thing\" here\n *   const getter2 = thing.anotherMethod;  // ❌\n *\n * ------------------------------------------------------------------------\n *\n *   class MyClass {\n *     constructor() {\n *       // ...\n *       autobind(this);                   // 👈\n *     }\n *   }\n *   const thing = new MyClass();\n *   const getter1 = thing.someMethod;     // ✅ Now \"this\" will be correctly bound to \"thing\" inside someMethod()\n *   const getter2 = thing.anotherMethod;  // ✅ Now\n *\n */\nexport function autobind(self: object): void {\n  const seen = new Set<string | symbol>();\n  seen.add(\"constructor\"); // We'll never want to bind the constructor\n\n  let obj = self.constructor.prototype as object;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n        (self as any)[key] = (self as any)[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)!) && obj !== Object.prototype);\n}\n","import { isPlainObject, shallow } from \"@liveblocks/core\";\n\n/**\n * Two-level deep shallow check.\n * Useful for checking equality of { isLoading: false, myData: [ ... ] } like\n * data structures, where you want to do a shallow comparison on the \"data\"\n * key.\n *\n * NOTE: Works on objects only, not on arrays!\n */\n// TODO Ideally we won't need this shallow2 helper anymore, so let's aim to remove it!\nexport function shallow2(a: unknown, b: unknown): boolean {\n  if (!isPlainObject(a) || !isPlainObject(b)) {\n    return shallow(a, b);\n  }\n\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])\n  );\n}\n","import type {\n  BaseMetadata,\n  ThreadData,\n  ThreadDataWithDeleteInfo,\n  ThreadDeleteInfo,\n} from \"@liveblocks/core\";\nimport { batch, MutableSignal, SortedList } from \"@liveblocks/core\";\n\nimport { makeThreadsFilter } from \"./lib/querying\";\nimport type { ThreadsQuery } from \"./types\";\n\nfunction sanitizeThread<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>\n): ThreadDataWithDeleteInfo<M> {\n  // First, if a thread has a deletedAt date, it should not have any comments\n  if (thread.deletedAt) {\n    // Thread is deleted, it should wipe all comments\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n\n  // Otherwise, if a thread is not deleted, it _should_ have at least one non-deleted comment\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    // Delete it after all if it doesn't have at least one comment\n    return { ...thread, deletedAt: new Date(), comments: [] };\n  }\n\n  return thread;\n}\n\nexport type ReadonlyThreadDB<M extends BaseMetadata> = Omit<\n  ThreadDB<M>,\n  \"upsert\" | \"delete\" | \"signal\"\n>;\n\n/**\n * This class implements a lightweight, in-memory, \"database\" for all Thread\n * instances.\n *\n * It exposes the following methods:\n *\n * - upsert: To add/update a thread\n * - upsertIfNewer: To add/update a thread. Only update an existing thread if\n *                  its newer\n * - delete: To mark existing threads as deleted\n * - get: To get any non-deleted thread\n * - getEvenIfDeleted: To get a thread which is possibly deleted\n * - findMany: To filter an ordered list of non-deleted threads\n * - clone: To clone the DB to mutate it further. This is used to mix in\n *          optimistic updates without losing the original thread contents.\n *\n */\nexport class ThreadDB<M extends BaseMetadata> {\n  #byId: Map<string, ThreadDataWithDeleteInfo<M>>;\n  #asc: SortedList<ThreadData<M>>;\n  #desc: SortedList<ThreadData<M>>;\n\n  // This signal will be notified on every mutation\n  public readonly signal: MutableSignal<this>;\n\n  constructor() {\n    this.#asc = SortedList.from<ThreadData<M>>([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n\n    this.#desc = SortedList.from<ThreadData<M>>([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n\n    this.#byId = new Map();\n\n    this.signal = new MutableSignal(this);\n  }\n\n  //\n  // Public APIs\n  //\n\n  public clone(): ThreadDB<M> {\n    const newPool = new ThreadDB<M>();\n    newPool.#byId = new Map(this.#byId);\n    newPool.#asc = this.#asc.clone();\n    newPool.#desc = this.#desc.clone();\n    return newPool;\n  }\n\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  public get(threadId: string): ThreadData<M> | undefined {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? undefined : thread;\n  }\n\n  /** Returns the (possibly deleted) thread by ID. */\n  public getEvenIfDeleted(\n    threadId: string\n  ): ThreadDataWithDeleteInfo<M> | undefined {\n    return this.#byId.get(threadId);\n  }\n\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  public upsert(thread: ThreadDataWithDeleteInfo<M>): void {\n    this.signal.mutate(() => {\n      thread = sanitizeThread(thread);\n\n      const id = thread.id;\n\n      const toRemove = this.#byId.get(id);\n      if (toRemove) {\n        // Don't do anything if the existing thread is already deleted!\n        if (toRemove.deletedAt) return false;\n\n        this.#asc.remove(toRemove);\n        this.#desc.remove(toRemove);\n      }\n\n      if (!thread.deletedAt) {\n        this.#asc.add(thread);\n        this.#desc.add(thread);\n      }\n      this.#byId.set(id, thread);\n      return true;\n    });\n  }\n\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  public upsertIfNewer(thread: ThreadDataWithDeleteInfo<M>): void {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n\n  public applyDelta(\n    newThreads: ThreadData<M>[],\n    deletedThreads: ThreadDeleteInfo[]\n  ): void {\n    batch(() => {\n      // Add new threads or update existing threads if the existing thread is older than the new thread.\n      for (const thread of newThreads) {\n        this.upsertIfNewer(thread);\n      }\n\n      // Mark threads in the deletedThreads list as deleted\n      for (const { id, deletedAt } of deletedThreads) {\n        const existing = this.getEvenIfDeleted(id);\n        if (!existing) continue;\n        this.delete(id, deletedAt);\n      }\n    });\n  }\n\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  public delete(threadId: string, deletedAt: Date): void {\n    const existing = this.#byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   */\n  public findMany(\n    // TODO: Implement caching here\n    roomId: string | undefined,\n    query: ThreadsQuery<M>,\n    direction: \"asc\" | \"desc\"\n  ): ThreadData<M>[] {\n    const index = direction === \"desc\" ? this.#desc : this.#asc;\n    const crit: ((thread: ThreadData<M>) => boolean)[] = [];\n    if (roomId !== undefined) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    crit.push(makeThreadsFilter(query));\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n}\n","import type { BaseMetadata, ThreadData } from \"@liveblocks/client\";\nimport { isStartsWithOperator } from \"@liveblocks/core\";\n\nimport type { ThreadsQuery } from \"../types\";\n\n/**\n * Creates a predicate function that will filter all ThreadData instances that\n * match the given query.\n */\nexport function makeThreadsFilter<M extends BaseMetadata>(\n  query: ThreadsQuery<M>\n): (thread: ThreadData<M>) => boolean {\n  return (thread: ThreadData<M>) =>\n    matchesQuery(thread, query) && matchesMetadata(thread, query);\n}\n\nfunction matchesQuery(\n  thread: ThreadData<BaseMetadata>,\n  q: ThreadsQuery<BaseMetadata>\n) {\n  // Boolean logic: query.resolved? => q.resolved === t.resolved\n  return q.resolved === undefined || thread.resolved === q.resolved;\n}\n\nfunction matchesMetadata(\n  thread: ThreadData<BaseMetadata>,\n  q: ThreadsQuery<BaseMetadata>\n) {\n  // Boolean logic: query.metadata? => all metadata matches\n  const metadata = thread.metadata;\n  return (\n    q.metadata === undefined ||\n    Object.entries(q.metadata).every(\n      ([key, op]) =>\n        // Ignore explicit-undefined filters\n        // Boolean logic: op? => value matches the operator\n        op === undefined || matchesOperator(metadata[key], op)\n    )\n  );\n}\n\nfunction matchesOperator(\n  value: BaseMetadata[string],\n  op: Exclude<BaseMetadata[string], undefined> | { startsWith: string } | null\n) {\n  if (op === null) {\n    // If the operator is `null`, we're doing an explicit query for absence\n    return value === undefined;\n  } else if (isStartsWithOperator(op)) {\n    return typeof value === \"string\" && value.startsWith(op.startsWith);\n  } else {\n    return value === op;\n  }\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  BroadcastOptions,\n  Client,\n  CommentData,\n  History,\n  Json,\n  JsonObject,\n  LiveObject,\n  LostConnectionEvent,\n  LsonObject,\n  OthersEvent,\n  Room,\n  RoomNotificationSettings,\n  Status,\n  StorageStatus,\n  ThreadData,\n  User,\n} from \"@liveblocks/client\";\nimport { shallow } from \"@liveblocks/client\";\nimport type {\n  AsyncResult,\n  CommentsEventServerMsg,\n  DE,\n  DM,\n  DP,\n  DS,\n  DU,\n  EnterOptions,\n  IYjsProvider,\n  LiveblocksErrorContext,\n  OpaqueClient,\n  RoomEventMessage,\n  SignalType,\n  TextEditorType,\n  ToImmutable,\n  UnsubscribeCallback,\n} from \"@liveblocks/core\";\nimport {\n  assert,\n  console,\n  createCommentId,\n  createThreadId,\n  DefaultMap,\n  errorIf,\n  HttpError,\n  kInternal,\n  makePoller,\n  ServerMsgCode,\n} from \"@liveblocks/core\";\nimport type { Context } from \"react\";\nimport {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  useSyncExternalStore,\n  version as reactVersion,\n} from \"react\";\n\nimport { config } from \"./config\";\nimport { RoomContext, useIsInsideRoom, useRoomOrNull } from \"./contexts\";\nimport { ensureNotServerSide } from \"./lib/ssr\";\nimport { useInitial } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { use } from \"./lib/use-polyfill\";\nimport {\n  createSharedContext,\n  getUmbrellaStoreForClient,\n  LiveblocksProviderWithClient,\n  useClient,\n  useClientOrNull,\n} from \"./liveblocks\";\nimport type {\n  AttachmentUrlAsyncResult,\n  CommentReactionOptions,\n  CreateCommentOptions,\n  CreateThreadOptions,\n  DeleteCommentOptions,\n  EditCommentOptions,\n  EditThreadMetadataOptions,\n  HistoryVersionDataAsyncResult,\n  HistoryVersionsAsyncResult,\n  HistoryVersionsAsyncSuccess,\n  MutationContext,\n  OmitFirstArg,\n  RoomContextBundle,\n  RoomNotificationSettingsAsyncResult,\n  RoomNotificationSettingsAsyncSuccess,\n  RoomProviderProps,\n  StorageStatusSuccess,\n  ThreadsAsyncResult,\n  ThreadsAsyncSuccess,\n  ThreadSubscription,\n  UseStorageStatusOptions,\n  UseThreadsOptions,\n} from \"./types\";\nimport type { UmbrellaStore } from \"./umbrella-store\";\nimport { makeRoomThreadsQueryKey } from \"./umbrella-store\";\nimport { useScrollToCommentOnLoadEffect } from \"./use-scroll-to-comment-on-load-effect\";\nimport { useSignal } from \"./use-signal\";\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nconst noop = () => {};\nconst identity: <T>(x: T) => T = (x) => x;\n\nconst STABLE_EMPTY_LIST = Object.freeze([]);\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a useCallback() wrapper.\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a useCallback() wrapper.\nfunction alwaysNull() {\n  return null;\n}\n\nfunction selectorFor_useOthersConnectionIds(\n  others: readonly User<JsonObject, BaseUserMeta>[]\n): number[] {\n  return others.map((user) => user.connectionId);\n}\n\nfunction makeMutationContext<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(room: Room<P, S, U, E, M>): MutationContext<P, S, U> {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n\n    setMyPresence: room.updatePresence,\n  };\n}\n\nfunction getCurrentUserId(client: Client): string {\n  const userId = client[kInternal].currentUserId.get();\n  if (userId === undefined) {\n    return \"anonymous\";\n  }\n  return userId;\n}\n\nconst _extras = new WeakMap<\n  OpaqueClient,\n  ReturnType<typeof makeRoomExtrasForClient>\n>();\nconst _bundles = new WeakMap<\n  OpaqueClient,\n  RoomContextBundle<JsonObject, LsonObject, BaseUserMeta, Json, BaseMetadata>\n>();\n\nfunction getOrCreateRoomContextBundle<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(client: OpaqueClient): RoomContextBundle<P, S, U, E, M> {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle as unknown as RoomContextBundle<P, S, U, E, M>;\n}\n\n// TODO: Likely a better / more clear name for this helper will arise. I'll\n// rename this later. All of these are implementation details to support inbox\n// notifications on a per-client basis.\nfunction getRoomExtrasForClient<M extends BaseMetadata>(client: OpaqueClient) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n\n  return extras as unknown as Omit<typeof extras, \"store\"> & {\n    store: UmbrellaStore<M>;\n  };\n}\n\nfunction makeRoomExtrasForClient(client: OpaqueClient) {\n  const store = getUmbrellaStoreForClient(client);\n\n  function onMutationFailure(\n    optimisticId: string,\n    context: LiveblocksErrorContext & { roomId: string },\n    innerError: Error\n  ): void {\n    store.optimisticUpdates.remove(optimisticId);\n\n    // All mutation failures are expected to be HTTP errors ultimately - only\n    // ever notify the user about those.\n    if (innerError instanceof HttpError) {\n      // Always log details about 403 Forbidden errors to the console as well\n      if (innerError.status === 403) {\n        const detailedMessage = [\n          innerError.message,\n          innerError.details?.suggestion,\n          innerError.details?.docs,\n        ]\n          .filter(Boolean)\n          .join(\"\\n\");\n\n        console.error(detailedMessage);\n      }\n\n      client[kInternal].emitError(context, innerError);\n    } else {\n      // In this context, a non-HTTP error is unexpected and should be\n      // considered a bug we should get fixed. Don't notify the user about it.\n      throw innerError;\n    }\n  }\n\n  const threadsPollersByRoomId = new DefaultMap((roomId: string) =>\n    makePoller(\n      async (signal) => {\n        try {\n          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n          throw err;\n        }\n      },\n      config.ROOM_THREADS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n    )\n  );\n\n  const versionsPollersByRoomId = new DefaultMap((roomId: string) =>\n    makePoller(\n      async (signal) => {\n        try {\n          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n          throw err;\n        }\n      },\n      config.HISTORY_VERSIONS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n    )\n  );\n\n  const roomNotificationSettingsPollersByRoomId = new DefaultMap(\n    (roomId: string) =>\n      makePoller(\n        async (signal) => {\n          try {\n            return await store.refreshRoomNotificationSettings(roomId, signal);\n          } catch (err) {\n            console.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n            throw err;\n          }\n        },\n        config.NOTIFICATION_SETTINGS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n      )\n  );\n\n  return {\n    store,\n    onMutationFailure,\n    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(\n      threadsPollersByRoomId\n    ),\n    getOrCreateVersionsPollerForRoomId:\n      versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),\n    getOrCreateNotificationsSettingsPollerForRoomId:\n      roomNotificationSettingsPollersByRoomId.getOrCreate.bind(\n        roomNotificationSettingsPollersByRoomId\n      ),\n  };\n}\n\ntype RoomLeavePair<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n> = {\n  room: Room<P, S, U, E, M>;\n  leave: () => void;\n};\n\nfunction makeRoomContextBundle<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(client: Client<U>): RoomContextBundle<P, S, U, E, M> {\n  type TRoom = Room<P, S, U, E, M>;\n\n  function RoomProvider_withImplicitLiveblocksProvider(\n    props: RoomProviderProps<P, S>\n  ) {\n    // NOTE: Normally, nesting LiveblocksProvider is not allowed. This\n    // factory-bound version of the RoomProvider will create an implicit\n    // LiveblocksProvider. This means that if an end user nests this\n    // RoomProvider under a LiveblocksProvider context, that would be an error.\n    // However, we'll allow that nesting only in this specific situation, and\n    // only because this wrapper will keep the Liveblocks context and the Room\n    // context consistent internally.\n    return (\n      <LiveblocksProviderWithClient client={client} allowNesting>\n        {/* @ts-expect-error {...props} is the same type as props */}\n        <RoomProvider {...props} />\n      </LiveblocksProviderWithClient>\n    );\n  }\n\n  const shared = createSharedContext<U>(client);\n\n  const bundle: RoomContextBundle<P, S, U, E, M> = {\n    RoomContext: RoomContext as Context<TRoom | null>,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n\n    useRoom,\n    useStatus,\n    useStorageStatus,\n\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useEventListener,\n\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n\n    useStorageRoot,\n    useStorage,\n\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n\n    useMutation: useMutation as RoomContextBundle<P, S, U, E, M>[\"useMutation\"],\n\n    useThreads,\n\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n\n    useHistoryVersions,\n    useHistoryVersionData,\n\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n\n    ...shared.classic,\n\n    suspense: {\n      RoomContext: RoomContext as Context<TRoom | null>,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useEventListener,\n\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n\n      useMutation: useMutation as RoomContextBundle<\n        P,\n        S,\n        U,\n        E,\n        M\n      >[\"suspense\"][\"useMutation\"],\n\n      useThreads: useThreadsSuspense,\n\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n\n      ...shared.suspense,\n    },\n  };\n\n  return Object.defineProperty(bundle, kInternal, {\n    enumerable: false,\n  });\n}\n\nfunction RoomProvider<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(props: RoomProviderProps<P, S>) {\n  const client = useClient<U>();\n  const [cache] = useState(\n    () => new Map<string, RoomLeavePair<P, S, U, E, M>>()\n  );\n\n  // Produce a version of client.enterRoom() that when called for the same\n  // room ID multiple times, will not keep producing multiple leave\n  // functions, but instead return the cached one.\n  const stableEnterRoom: typeof client.enterRoom<P, S, E, M> = useCallback(\n    (\n      roomId: string,\n      options: EnterOptions<P, S>\n    ): RoomLeavePair<P, S, U, E, M> => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n\n      const rv = client.enterRoom<P, S, E, M>(roomId, options);\n\n      // Wrap the leave function to also delete the cached value\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n\n  //\n  // RATIONALE:\n  // At the \"Outer\" RoomProvider level, we keep a cache and produce\n  // a stableEnterRoom function, which we pass down to the real \"Inner\"\n  // RoomProvider level.\n  //\n  // The purpose is to ensure that if `stableEnterRoom(\"my-room\")` is called\n  // multiple times for the same room ID, it will always return the exact same\n  // (cached) value, so that in total only a single \"leave\" function gets\n  // produced and registered in the client.\n  //\n  // If we didn't use this cache, then in React StrictMode\n  // stableEnterRoom(\"my-room\") might get called multiple (at least 4) times,\n  // causing more leave functions to be produced in the client, some of which\n  // we cannot get a hold on (because StrictMode would discard those results by\n  // design). This would make it appear to the Client that the Room is still in\n  // use by some party that hasn't called `leave()` on it yet, thus causing the\n  // Room to not be freed and destroyed when the component unmounts later.\n  //\n  return (\n    <RoomProviderInner<P, S, U, E, M>\n      {...(props as any)}\n      stableEnterRoom={stableEnterRoom}\n    />\n  );\n}\n\ntype EnterRoomType<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n> = (\n  roomId: string,\n  options: EnterOptions<P, S>\n) => RoomLeavePair<P, S, U, E, M>;\n\n/** @internal */\nfunction RoomProviderInner<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(\n  props: RoomProviderProps<P, S> & {\n    stableEnterRoom: EnterRoomType<P, S, U, E, M>;\n  }\n) {\n  const client = useClient<U>();\n  const { id: roomId, stableEnterRoom } = props;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n\n    const majorReactVersion = parseInt(reactVersion) || 1;\n    const requiredVersion = 18;\n    errorIf(\n      majorReactVersion < requiredVersion,\n      `React ${requiredVersion} or higher is required (you’re on ${reactVersion})`\n    );\n  }\n\n  // Note: We'll hold on to the initial value given here, and ignore any\n  // changes to this argument in subsequent renders\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\",\n  }) as EnterOptions<P, S>;\n\n  const [{ room }, setRoomLeavePair] = useState(() =>\n    stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false, // Deliberately using false here on the first render, see below\n    })\n  );\n\n  useEffect(() => {\n    const { store } = getRoomExtrasForClient(client);\n\n    async function handleCommentEvent(message: CommentsEventServerMsg) {\n      // If thread deleted event is received, we remove the thread from the local cache\n      // no need for more processing\n      if (message.type === ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n\n      // TODO: Error handling\n      const info = await room.getThread(message.threadId);\n\n      // If no thread info was returned (i.e., 404), we remove the thread and relevant inbox notifications from local cache.\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const { thread, inboxNotification: maybeNotification } = info;\n\n      const existingThread = store.outputs.threads\n        .get()\n        .getEvenIfDeleted(message.threadId);\n\n      switch (message.type) {\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.THREAD_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_DELETED:\n          // If the thread doesn't exist in the local cache, we do not update it with the server data as an optimistic update could have deleted the thread locally.\n          if (!existingThread) break;\n\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : []\n          );\n          break;\n\n        case ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : []\n          );\n          break;\n        default:\n          break;\n      }\n    }\n\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n\n  useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n\n    setRoomLeavePair(pair);\n    const { room, leave } = pair;\n\n    // In React, it's important to start connecting to the room as an effect,\n    // rather than doing this during the initial render. This means that\n    // during the initial render (both on the server-side, and on the first\n    // hydration on the client-side), the value of the `useStatus()` hook\n    // will correctly be \"initial\", and transition to \"connecting\" as an\n    // effect.\n    if (frozenProps.autoConnect) {\n      room.connect();\n    }\n\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n\n  return (\n    <RoomContext.Provider value={room}>{props.children}</RoomContext.Provider>\n  );\n}\n\nfunction useRoom<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n>(): Room<P, S, U, E, M> {\n  const room = useRoomOrNull<P, S, U, E, M>();\n  if (room === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\n\n/**\n * Returns the current connection status for the Room, and triggers\n * a re-render whenever it changes. Can be used to render a status badge.\n */\nfunction useStatus(): Status {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useReportTextEditor(editor: TextEditorType, rootKey: string): void {\n  const isReported = useRef<boolean>(false);\n  const room = useRoom();\n\n  useEffect(() => {\n    // We use a \"locker\" reference to avoid to spam / harass our backend\n    // and to not add / remove subscribers in case when the text editor type\n    // has been already reported.\n    if (isReported.current) {\n      return;\n    }\n\n    const unsubscribe = room.events.status.subscribe((status: Status): void => {\n      if (status === \"connected\" && !isReported.current) {\n        isReported.current = true;\n        // We do not catch because this method never throw (e.g `rawPost`)\n        void room[kInternal].reportTextEditor(editor, rootKey);\n      }\n    });\n\n    return unsubscribe;\n  }, [room, editor, rootKey]);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useYjsProvider(): IYjsProvider | undefined {\n  const room = useRoom();\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void): UnsubscribeCallback => {\n      return room[kInternal].yjsProviderDidChange.subscribe(onStoreChange);\n    },\n    [room]\n  );\n\n  const getSnapshot = useCallback((): IYjsProvider | undefined => {\n    return room[kInternal].getYjsProvider();\n  }, [room]);\n\n  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useCreateTextMention(): (userId: string, mentionId: string) => void {\n  const room = useRoom();\n  return useCallback(\n    (userId: string, mentionId: string): void => {\n      room[kInternal]\n        .createTextMention(userId, mentionId)\n        .catch((err): void => {\n          console.error(\n            `Cannot create text mention for user '${userId}' and mention '${mentionId}'`,\n            err\n          );\n        });\n    },\n    [room]\n  );\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useDeleteTextMention(): (mentionId: string) => void {\n  const room = useRoom();\n  return useCallback(\n    (mentionId: string): void => {\n      room[kInternal].deleteTextMention(mentionId).catch((err): void => {\n        console.error(`Cannot delete text mention '${mentionId}'`, err);\n      });\n    },\n    [room]\n  );\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useResolveMentionSuggestions() {\n  const client = useClient();\n  return client[kInternal].resolveMentionSuggestions;\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useMentionSuggestionsCache() {\n  const client = useClient();\n  return client[kInternal].mentionSuggestionsCache;\n}\n\n/**\n * Returns the current storage status for the Room, and triggers\n * a re-render whenever it changes. Can be used to render a \"Saving...\"\n * indicator.\n *\n * @deprecated Prefer useSyncStatus()\n */\nfunction useStorageStatus(options?: UseStorageStatusOptions): StorageStatus {\n  // Normally the Rules of Hooks™ dictate that you should not call hooks\n  // conditionally. In this case, we're good here, because the same code path\n  // will always be taken on every subsequent render here, because we've frozen\n  // the value.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useStorageStatusSmooth();\n  } else {\n    return useStorageStatusImmediate();\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n}\n\nfunction useStorageStatusImmediate(): StorageStatus {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\nfunction useStorageStatusSmooth(): StorageStatus {\n  const room = useRoom();\n  const [status, setStatus] = useState(room.getStorageStatus);\n  const oldStatus = useLatest(room.getStorageStatus());\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const unsub = room.events.storageStatus.subscribe((newStatus) => {\n      if (\n        oldStatus.current === \"synchronizing\" &&\n        newStatus === \"synchronized\"\n      ) {\n        // Delay delivery of the \"synchronized\" event\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n\n    // Clean up\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [room, oldStatus]);\n\n  return status;\n}\n\n/**\n * @deprecated It's recommended to use `useMutation` for writing to Storage,\n * which will automatically batch all mutations.\n *\n * Returns a function that batches modifications made during the given function.\n * All the modifications are sent to other clients in a single message.\n * All the modifications are merged in a single history item (undo/redo).\n * All the subscribers are called only after the batch is over.\n */\nfunction useBatch<T>(): (callback: () => T) => T {\n  return useRoom().batch;\n}\n\nfunction useBroadcastEvent<E extends Json>(): (\n  event: E,\n  options?: BroadcastOptions\n) => void {\n  const room = useRoom<never, never, never, E, never>();\n  return useCallback(\n    (\n      event: E,\n      options: BroadcastOptions = { shouldQueueEventIfNotReady: false }\n    ) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\n\nfunction useOthersListener<P extends JsonObject, U extends BaseUserMeta>(\n  callback: (event: OthersEvent<P, U>) => void\n) {\n  const room = useRoom<P, never, U, never, never>();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\n\n/**\n * Get informed when reconnecting to the Liveblocks servers is taking\n * longer than usual. This typically is a sign of a client that has lost\n * internet connectivity.\n *\n * This isn't problematic (because the Liveblocks client is still trying to\n * reconnect), but it's typically a good idea to inform users about it if\n * the connection takes too long to recover.\n *\n * @example\n * useLostConnectionListener(event => {\n *   if (event === 'lost') {\n *     toast.warn('Reconnecting to the Liveblocks servers is taking longer than usual...')\n *   } else if (event === 'failed') {\n *     toast.warn('Reconnecting to the Liveblocks servers failed.')\n *   } else if (event === 'restored') {\n *     toast.clear();\n *   }\n * })\n */\nfunction useLostConnectionListener(\n  callback: (event: LostConnectionEvent) => void\n): void {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () =>\n      room.events.lostConnection.subscribe((event) =>\n        savedCallback.current(event)\n      ),\n    [room, savedCallback]\n  );\n}\n\nfunction useEventListener<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n>(callback: (data: RoomEventMessage<P, U, E>) => void): void {\n  const room = useRoom<P, never, U, E, never>();\n  const savedCallback = useLatest(callback);\n  useEffect(() => {\n    const listener = (eventData: RoomEventMessage<P, U, E>) => {\n      savedCallback.current(eventData);\n    };\n\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\n\n/**\n * Returns the room.history\n */\nfunction useHistory(): History {\n  return useRoom().history;\n}\n\n/**\n * Returns a function that undoes the last operation executed by the current\n * client. It does not impact operations made by other clients.\n */\nfunction useUndo(): () => void {\n  return useHistory().undo;\n}\n\n/**\n * Returns a function that redoes the last operation executed by the current\n * client. It does not impact operations made by other clients.\n */\nfunction useRedo(): () => void {\n  return useHistory().redo;\n}\n\n/**\n * Returns whether there are any operations to undo.\n */\nfunction useCanUndo(): boolean {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore(subscribe, canUndo, canUndo);\n}\n\n/**\n * Returns whether there are any operations to redo.\n */\nfunction useCanRedo(): boolean {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore(subscribe, canRedo, canRedo);\n}\n\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta>(): User<\n  P,\n  U\n> | null;\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (me: User<P, U>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | null;\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta, T>(\n  maybeSelector?: (me: User<P, U>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | User<P, U> | null {\n  type Snapshot = User<P, U> | null;\n  type Selection = T | null;\n\n  const room = useRoom<P, never, U, never, never>();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot: () => Snapshot = room.getSelf;\n\n  const selector = maybeSelector ?? (identity as (me: User<P, U>) => T);\n  const wrappedSelector = useCallback(\n    (me: Snapshot): Selection => (me !== null ? selector(me) : null),\n    [selector]\n  );\n\n  const getServerSnapshot = alwaysNull;\n\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\n\nfunction useMyPresence<P extends JsonObject>(): [\n  P,\n  (patch: Partial<P>, options?: { addToHistory: boolean }) => void,\n] {\n  const room = useRoom<P, never, never, never, never>();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\n\nfunction useUpdateMyPresence<P extends JsonObject>(): (\n  patch: Partial<P>,\n  options?: { addToHistory: boolean }\n) => void {\n  return useRoom<P, never, never, never, never>().updatePresence;\n}\n\nfunction useOthers<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n>(): readonly User<P, U>[];\nfunction useOthers<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useOthers<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | readonly User<P, U>[] {\n  const room = useRoom<P, never, U, never, never>();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? (identity as (others: readonly User<P, U>[]) => T),\n    isEqual\n  );\n}\n\nfunction useOthersMapped<P extends JsonObject, U extends BaseUserMeta, T>(\n  itemSelector: (other: User<P, U>) => T,\n  itemIsEqual?: (prev: T, curr: T) => boolean\n): ReadonlyArray<readonly [connectionId: number, data: T]> {\n  const wrappedSelector = useCallback(\n    (others: readonly User<P, U>[]) =>\n      others.map((other) => [other.connectionId, itemSelector(other)] as const),\n    [itemSelector]\n  );\n\n  const wrappedIsEqual = useCallback(\n    (\n      a: ReadonlyArray<readonly [connectionId: number, data: T]>,\n      b: ReadonlyArray<readonly [connectionId: number, data: T]>\n    ): boolean => {\n      const eq = itemIsEqual ?? Object.is;\n      return (\n        a.length === b.length &&\n        a.every((atuple, index) => {\n          // We know btuple always exist because we checked the array length on the previous line\n          const btuple = b[index]!;\n          return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n        })\n      );\n    },\n    [itemIsEqual]\n  );\n\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\n\n/**\n * Returns an array of connection IDs. This matches the values you'll get by\n * using the `useOthers()` hook.\n *\n * Roughly equivalent to:\n *   useOthers((others) => others.map(other => other.connectionId), shallow)\n *\n * This is useful in particular to implement efficiently rendering components\n * for each user in the room, e.g. cursors.\n *\n * @example\n * const ids = useOthersConnectionIds();\n * // [2, 4, 7]\n */\nfunction useOthersConnectionIds(): readonly number[] {\n  return useOthers(selectorFor_useOthersConnectionIds, shallow);\n}\n\nconst NOT_FOUND = Symbol();\n\ntype NotFound = typeof NOT_FOUND;\n\nfunction useOther<P extends JsonObject, U extends BaseUserMeta, T>(\n  connectionId: number,\n  selector: (other: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  const wrappedSelector = useCallback(\n    (others: readonly User<P, U>[]) => {\n      // TODO: Make this O(1) instead of O(n)?\n      const other = others.find((other) => other.connectionId === connectionId);\n      return other !== undefined ? selector(other) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n\n  const wrappedIsEqual = useCallback(\n    (prev: T | NotFound, curr: T | NotFound): boolean => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n\n  return other;\n}\n\n/** @internal */\nfunction useMutableStorageRoot<S extends LsonObject>(): LiveObject<S> | null {\n  const room = useRoom<never, S, never, never, never>();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n// NOTE: This API exists for backward compatible reasons\nfunction useStorageRoot<S extends LsonObject>(): [root: LiveObject<S> | null] {\n  return [useMutableStorageRoot<S>()];\n}\n\nfunction useStorage<S extends LsonObject, T>(\n  selector: (root: ToImmutable<S>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | null {\n  type Snapshot = ToImmutable<S> | null;\n  type Selection = T | null;\n\n  const room = useRoom<never, S, never, never, never>();\n  const rootOrNull = useMutableStorageRoot<S>();\n\n  const wrappedSelector = useCallback(\n    (rootOrNull: Snapshot): Selection =>\n      rootOrNull !== null ? selector(rootOrNull) : null,\n    [selector]\n  );\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void) =>\n      rootOrNull !== null\n        ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true })\n        : noop,\n    [room, rootOrNull]\n  );\n\n  const getSnapshot = useCallback((): Snapshot => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n\n  const getServerSnapshot = alwaysNull;\n\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\n\nfunction useMutation<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n  F extends (context: MutationContext<P, S, U>, ...args: any[]) => any,\n>(callback: F, deps: readonly unknown[]): OmitFirstArg<F> {\n  const room = useRoom<P, S, U, E, M>();\n  return useMemo(\n    () => {\n      return ((...args) =>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(() =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          callback(\n            makeMutationContext<P, S, U, E, M>(room),\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            ...args\n          )\n        )) as OmitFirstArg<F>;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\n\nfunction useThreads<M extends BaseMetadata>(\n  options: UseThreadsOptions<M> = {}\n): ThreadsAsyncResult<M> {\n  const { scrollOnLoad = true } = options;\n\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } =\n    getRoomExtrasForClient<M>(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n\n  useEffect(\n    () =>\n      void store.outputs.loadingRoomThreads\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n\n  const result = useSignal(\n    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal\n  );\n\n  useScrollToCommentOnLoadEffect(scrollOnLoad, result);\n  return result;\n}\n\nfunction useCreateThread<M extends BaseMetadata>(): (\n  options: CreateThreadOptions<M>\n) => ThreadData<M> {\n  return useCreateRoomThread(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useCreateRoomThread<M extends BaseMetadata>(\n  roomId: string\n): (options: CreateThreadOptions<M>) => ThreadData<M> {\n  const client = useClient();\n\n  return useCallback(\n    (options: CreateThreadOptions<M>): ThreadData<M> => {\n      const body = options.body;\n      const metadata = options.metadata ?? ({} as M);\n      const attachments = options.attachments;\n\n      const threadId = createThreadId();\n      const commentId = createCommentId();\n      const createdAt = new Date();\n\n      const newComment: CommentData = {\n        id: commentId,\n        threadId,\n        roomId,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? [],\n      };\n      const newThread: ThreadData<M> = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId,\n        metadata,\n        comments: [newComment],\n        resolved: false,\n      };\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId,\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .createThread({\n          roomId,\n          threadId,\n          commentId,\n          body,\n          metadata,\n          attachmentIds,\n        })\n        .then(\n          (thread) => {\n            // Replace the optimistic update by the real thing\n            store.createThread(optimisticId, thread);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"CREATE_THREAD_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                body,\n                metadata,\n              },\n              err\n            )\n        );\n\n      return newThread;\n    },\n    [client, roomId]\n  );\n}\n\nfunction useDeleteThread(): (threadId: string) => void {\n  return useDeleteRoomThread(useRoom().id);\n}\n\nfunction useDeleteRoomThread(roomId: string): (threadId: string) => void {\n  const client = useClient();\n  return useCallback(\n    (threadId: string): void => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n\n      const userId = getCurrentUserId(client);\n\n      const existing = store.outputs.threads.get().get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-thread\",\n        roomId,\n        threadId,\n        deletedAt: new Date(),\n      });\n\n      client[kInternal].httpClient.deleteThread({ roomId, threadId }).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.deleteThread(threadId, optimisticId);\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            { type: \"DELETE_THREAD_ERROR\", roomId, threadId },\n            err\n          )\n      );\n    },\n    [client, roomId]\n  );\n}\n\nfunction useEditThreadMetadata<M extends BaseMetadata>() {\n  return useEditRoomThreadMetadata<M>(useRoom().id);\n}\n\nfunction useEditRoomThreadMetadata<M extends BaseMetadata>(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (options: EditThreadMetadataOptions<M>): void => {\n      if (!options.metadata) {\n        return;\n      }\n\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .editThreadMetadata({ roomId, threadId, metadata })\n        .then(\n          (metadata) =>\n            // Replace the optimistic update by the real thing\n            store.patchThread(threadId, optimisticId, { metadata }, updatedAt),\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"EDIT_THREAD_METADATA_ERROR\",\n                roomId,\n                threadId,\n                metadata,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that adds a comment to a thread.\n *\n * @example\n * const createComment = useCreateComment();\n * createComment({ threadId: \"th_xxx\", body: {} });\n */\nfunction useCreateComment(): (options: CreateCommentOptions) => CommentData {\n  return useCreateRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useCreateRoomComment(\n  roomId: string\n): (options: CreateCommentOptions) => CommentData {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, body, attachments }: CreateCommentOptions): CommentData => {\n      const commentId = createCommentId();\n      const createdAt = new Date();\n\n      const comment: CommentData = {\n        id: commentId,\n        threadId,\n        roomId,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? [],\n      };\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-comment\",\n        comment,\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .createComment({ roomId, threadId, commentId, body, attachmentIds })\n        .then(\n          (newComment) => {\n            // Replace the optimistic update by the real thing\n            store.createComment(newComment, optimisticId);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"CREATE_COMMENT_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                body,\n              },\n              err\n            )\n        );\n\n      return comment;\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that edits a comment's body.\n *\n * @example\n * const editComment = useEditComment()\n * editComment({ threadId: \"th_xxx\", commentId: \"cm_xxx\", body: {} })\n */\nfunction useEditComment(): (options: EditCommentOptions) => void {\n  return useEditRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useEditRoomComment(\n  roomId: string\n): (options: EditCommentOptions) => void {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, body, attachments }: EditCommentOptions): void => {\n      const editedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);\n\n      if (existing === undefined) {\n        console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n\n      const comment = existing.comments.find(\n        (comment) => comment.id === commentId\n      );\n\n      if (comment === undefined || comment.deletedAt !== undefined) {\n        console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? [],\n        },\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .editComment({ roomId, threadId, commentId, body, attachmentIds })\n        .then(\n          (editedComment) => {\n            // Replace the optimistic update by the real thing\n            store.editComment(threadId, optimisticId, editedComment);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"EDIT_COMMENT_ERROR\", roomId, threadId, commentId, body },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that deletes a comment.\n * If it is the last non-deleted comment, the thread also gets deleted.\n *\n * @example\n * const deleteComment = useDeleteComment();\n * deleteComment({ threadId: \"th_xxx\", commentId: \"cm_xxx\" })\n */\nfunction useDeleteComment() {\n  return useDeleteRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useDeleteRoomComment(roomId: string) {\n  const client = useClient();\n\n  return useCallback(\n    ({ threadId, commentId }: DeleteCommentOptions): void => {\n      const deletedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId,\n      });\n\n      client[kInternal].httpClient\n        .deleteComment({ roomId, threadId, commentId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.deleteComment(threadId, optimisticId, commentId, deletedAt);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"DELETE_COMMENT_ERROR\", roomId, threadId, commentId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\nfunction useAddReaction<M extends BaseMetadata>() {\n  return useAddRoomCommentReaction<M>(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useAddRoomCommentReaction<M extends BaseMetadata>(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n      const createdAt = new Date();\n      const userId = getCurrentUserId(client);\n\n      const { store, onMutationFailure } = getRoomExtrasForClient<M>(client);\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt,\n        },\n      });\n\n      client[kInternal].httpClient\n        .addReaction({ roomId, threadId, commentId, emoji })\n        .then(\n          (addedReaction) => {\n            // Replace the optimistic update by the real thing\n            store.addReaction(\n              threadId,\n              optimisticId,\n              commentId,\n              addedReaction,\n              createdAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"ADD_REACTION_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                emoji,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that removes a reaction on a comment.\n *\n * @example\n * const removeReaction = useRemoveReaction();\n * removeReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n */\nfunction useRemoveReaction() {\n  return useRemoveRoomCommentReaction(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useRemoveRoomCommentReaction(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n      const userId = getCurrentUserId(client);\n\n      const removedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt,\n      });\n\n      client[kInternal].httpClient\n        .removeReaction({ roomId, threadId, commentId, emoji })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.removeReaction(\n              threadId,\n              optimisticId,\n              commentId,\n              emoji,\n              userId,\n              removedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"REMOVE_REACTION_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                emoji,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n/**\n * Returns a function that marks a thread as read.\n *\n * @example\n * const markThreadAsRead = useMarkThreadAsRead();\n * markThreadAsRead(\"th_xxx\");\n */\nfunction useMarkThreadAsRead() {\n  return useMarkRoomThreadAsRead(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsRead(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.outputs.notifications.get().notificationsById\n      ).find(\n        (inboxNotification) =>\n          inboxNotification.kind === \"thread\" &&\n          inboxNotification.threadId === threadId\n      );\n\n      if (!inboxNotification) return;\n\n      const now = new Date();\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now,\n      });\n\n      client[kInternal].httpClient\n        .markRoomInboxNotificationAsRead({\n          roomId,\n          inboxNotificationId: inboxNotification.id,\n        })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.markInboxNotificationRead(\n              inboxNotification.id,\n              now,\n              optimisticId\n            );\n          },\n          (err: Error) => {\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n                roomId,\n                inboxNotificationId: inboxNotification.id,\n              },\n              err\n            );\n            return;\n          }\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that marks a thread as resolved.\n *\n * @example\n * const markThreadAsResolved = useMarkThreadAsResolved();\n * markThreadAsResolved(\"th_xxx\");\n */\nfunction useMarkThreadAsResolved() {\n  return useMarkRoomThreadAsResolved(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsResolved(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .markThreadAsResolved({ roomId, threadId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.patchThread(\n              threadId,\n              optimisticId,\n              { resolved: true },\n              updatedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"MARK_THREAD_AS_RESOLVED_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that marks a thread as unresolved.\n *\n * @example\n * const markThreadAsUnresolved = useMarkThreadAsUnresolved();\n * markThreadAsUnresolved(\"th_xxx\");\n */\nfunction useMarkThreadAsUnresolved() {\n  return useMarkRoomThreadAsUnresolved(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsUnresolved(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .markThreadAsUnresolved({ roomId, threadId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.patchThread(\n              threadId,\n              optimisticId,\n              { resolved: false },\n              updatedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"MARK_THREAD_AS_UNRESOLVED_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns the subscription status of a thread.\n *\n * @example\n * const { status, unreadSince } = useThreadSubscription(\"th_xxx\");\n */\nfunction useThreadSubscription(threadId: string): ThreadSubscription {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n\n  const signal = store.outputs.threadifications;\n\n  const selector = useCallback(\n    (state: SignalType<typeof signal>): ThreadSubscription => {\n      const notification = state.sortedNotifications.find(\n        (inboxNotification) =>\n          inboxNotification.kind === \"thread\" &&\n          inboxNotification.threadId === threadId\n      );\n\n      const thread = state.threadsDB.get(threadId);\n      if (notification === undefined || thread === undefined) {\n        return { status: \"not-subscribed\" };\n      }\n\n      return {\n        status: \"subscribed\",\n        unreadSince: notification.readAt,\n      };\n    },\n    [threadId]\n  );\n\n  return useSignal(signal, selector, shallow);\n}\n\n/**\n * Returns the user's notification settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomNotificationSettings();\n */\nfunction useRoomNotificationSettings(): [\n  RoomNotificationSettingsAsyncResult,\n  (settings: Partial<RoomNotificationSettings>) => void,\n] {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateNotificationsSettingsPollerForRoomId } =\n    getRoomExtrasForClient(client);\n\n  const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);\n\n  useEffect(\n    () =>\n      void store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  const settings = useSignal(\n    store.outputs.settingsByRoomId.getOrCreate(room.id).signal\n  );\n\n  return useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\n\n/**\n * Returns the user's notification settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomNotificationSettings();\n */\nfunction useRoomNotificationSettingsSuspense(): [\n  RoomNotificationSettingsAsyncSuccess,\n  (settings: Partial<RoomNotificationSettings>) => void,\n] {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n\n  // Suspend until there are at least some inbox notifications\n  use(store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n\n  // We're in a Suspense world here, and as such, the useRoomNotificationSettings()\n  // hook is expected to only return success results when we're here.\n  const [settings, updateRoomNotificationSettings] =\n    useRoomNotificationSettings();\n  assert(!settings.error, \"Did not expect error\");\n  assert(!settings.isLoading, \"Did not expect loading\");\n\n  return useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\n\n/**\n * Returns the version data bianry for a given version\n *\n * @example\n * const {data} = useHistoryVersionData(versionId);\n */\nfunction useHistoryVersionData(\n  versionId: string\n): HistoryVersionDataAsyncResult {\n  const [state, setState] = useState<HistoryVersionDataAsyncResult>({\n    isLoading: true,\n  });\n  const room = useRoom();\n  useEffect(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data,\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error:\n            error instanceof Error\n              ? error\n              : new Error(\n                  \"An unknown error occurred while loading this version\"\n                ),\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions, error, isLoading } = useHistoryVersions();\n */\nfunction useHistoryVersions(): HistoryVersionsAsyncResult {\n  const client = useClient();\n  const room = useRoom();\n\n  const { store, getOrCreateVersionsPollerForRoomId } =\n    getRoomExtrasForClient(client);\n\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n\n  useEffect(\n    () =>\n      void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);\n}\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions } = useHistoryVersions();\n */\nfunction useHistoryVersionsSuspense(): HistoryVersionsAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n\n  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n\n  const result = useHistoryVersions();\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns a function that updates the user's notification settings\n * for the current room.\n *\n * @example\n * const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n * updateRoomNotificationSettings({ threads: \"all\" });\n */\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return useCallback(\n    (settings: Partial<RoomNotificationSettings>) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings,\n      });\n\n      room.updateNotificationSettings(settings).then(\n        (settings) => {\n          // Replace the optimistic update by the real thing\n          store.updateRoomNotificationSettings(room.id, optimisticId, settings);\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            { type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\", roomId: room.id },\n            err\n          )\n      );\n    },\n    [client, room]\n  );\n}\n\nfunction useSuspendUntilPresenceReady(): void {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\n\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta>(): User<\n  P,\n  U\n>;\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (me: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (me: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | User<P, U> {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector as (me: User<P, U>) => T,\n    isEqual as (prev: T | null, curr: T | null) => boolean\n  ) as T | User<P, U>;\n}\n\nfunction useOthersSuspense<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n>(): readonly User<P, U>[];\nfunction useOthersSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useOthersSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | readonly User<P, U>[] {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector as (others: readonly User<P, U>[]) => T,\n    isEqual as (prev: T, curr: T) => boolean\n  ) as T | readonly User<P, U>[];\n}\n\n/**\n * Returns an array of connection IDs. This matches the values you'll get by\n * using the `useOthers()` hook.\n *\n * Roughly equivalent to:\n *   useOthers((others) => others.map(other => other.connectionId), shallow)\n *\n * This is useful in particular to implement efficiently rendering components\n * for each user in the room, e.g. cursors.\n *\n * @example\n * const ids = useOthersConnectionIds();\n * // [2, 4, 7]\n */\nfunction useOthersConnectionIdsSuspense(): readonly number[] {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\n\nfunction useOthersMappedSuspense<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  T,\n>(\n  itemSelector: (other: User<P, U>) => T,\n  itemIsEqual?: (prev: T, curr: T) => boolean\n): ReadonlyArray<readonly [connectionId: number, data: T]> {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\n\nfunction useOtherSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  connectionId: number,\n  selector: (other: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\n\nfunction useSuspendUntilStorageReady(): void {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\n\nfunction useStorageSuspense<S extends LsonObject, T>(\n  selector: (root: ToImmutable<S>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual as (prev: T | null, curr: T | null) => boolean\n  ) as T;\n}\n\n/**\n * Returns the current storage status for the Room, and triggers\n * a re-render whenever it changes. Can be used to render a \"Saving...\"\n * indicator.\n *\n * @deprecated Prefer useSyncStatus()\n */\nfunction useStorageStatusSuspense(\n  options?: UseStorageStatusOptions\n): StorageStatusSuccess {\n  useSuspendUntilStorageReady();\n  return useStorageStatus(options) as StorageStatusSuccess;\n}\n\nfunction useThreadsSuspense<M extends BaseMetadata>(\n  options: UseThreadsOptions<M> = {}\n): ThreadsAsyncSuccess<M> {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const room = useRoom();\n\n  const { store } = getRoomExtrasForClient<M>(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n\n  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useThreads(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction selectorFor_useAttachmentUrl(\n  state: AsyncResult<string | undefined> | undefined\n): AttachmentUrlAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // For now `useAttachmentUrl` doesn't support a custom resolver so this case\n  // will never happen as `getAttachmentUrl` will either return a URL or throw.\n  // But we might decide to offer a custom resolver in the future to allow\n  // self-hosting attachments.\n  assert(state.data !== undefined, \"Unexpected missing attachment URL\");\n\n  return {\n    isLoading: false,\n    url: state.data,\n  };\n}\n\n/**\n * Returns a presigned URL for an attachment by its ID.\n *\n * @example\n * const { url, error, isLoading } = useAttachmentUrl(\"at_xxx\");\n */\nfunction useAttachmentUrl(attachmentId: string): AttachmentUrlAsyncResult {\n  const room = useRoom();\n  return useRoomAttachmentUrl(attachmentId, room.id);\n}\n\n/**\n * @private For internal use only. Do not rely on this hook. Use `useAttachmentUrl` instead.\n */\nfunction useRoomAttachmentUrl(\n  attachmentId: string,\n  roomId: string\n): AttachmentUrlAsyncResult {\n  const client = useClient();\n  const store =\n    client[kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);\n\n  const getAttachmentUrlState = useCallback(\n    () => store.getItemState(attachmentId),\n    [store, attachmentId]\n  );\n\n  useEffect(() => {\n    void store.enqueue(attachmentId);\n  }, [store, attachmentId]);\n\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    shallow\n  );\n}\n\n/**\n * Returns a presigned URL for an attachment by its ID.\n *\n * @example\n * const { url } = useAttachmentUrl(\"at_xxx\");\n */\nfunction useAttachmentUrlSuspense(attachmentId: string) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[kInternal];\n\n  const getAttachmentUrlState = useCallback(\n    () => attachmentUrlsStore.getItemState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.enqueue(attachmentId);\n  }\n\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n\n  const state = useSyncExternalStore(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: undefined,\n  } as const;\n}\n\nconst NO_PERMISSIONS = new Set();\n\n/**\n * @private For internal use only. Do not rely on this hook.\n */\nfunction useRoomPermissions(roomId: string) {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  return useSignal(\n    store.permissionHints.signal,\n    (hints) => hints.get(roomId) ?? NO_PERMISSIONS\n  );\n}\n\n/**\n * @private\n *\n * This is an internal API, use `createRoomContext` instead.\n */\nexport function useRoomContextBundleOrNull(): RoomContextBundle<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  Json,\n  BaseMetadata\n> | null {\n  const client = useClientOrNull();\n  const room = useRoomOrNull<never, never, never, never, never>();\n  return client && room ? getOrCreateRoomContextBundle(client) : null;\n}\n\n/**\n * @private\n *\n * This is an internal API, use `createRoomContext` instead.\n */\nexport function useRoomContextBundle(): RoomContextBundle<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  Json,\n  BaseMetadata\n> {\n  const client = useClient();\n  return getOrCreateRoomContextBundle(client);\n}\n\n/**\n * Creates a RoomProvider and a set of typed hooks to use in your app. Note\n * that any RoomProvider created in this way does not need to be nested in\n * LiveblocksProvider, as it already has access to the client.\n */\nexport function createRoomContext<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n>(client: OpaqueClient): RoomContextBundle<P, S, U, E, M> {\n  return getOrCreateRoomContextBundle<P, S, U, E, M>(client);\n}\n\ntype TypedBundle = RoomContextBundle<DP, DS, DU, DE, DM>;\n\n/**\n * Makes a Room available in the component hierarchy below.\n * Joins the room when the component is mounted, and automatically leaves\n * the room when the component is unmounted.\n */\nconst _RoomProvider: TypedBundle[\"RoomProvider\"] = RoomProvider;\n\n/**\n * Returns a callback that lets you broadcast custom events to other users in the room\n *\n * @example\n * const broadcast = useBroadcastEvent();\n *\n * broadcast({ type: \"CUSTOM_EVENT\", data: { x: 0, y: 0 } });\n */\nconst _useBroadcastEvent: TypedBundle[\"useBroadcastEvent\"] = useBroadcastEvent;\n\n/**\n * Get informed when users enter or leave the room, as an event.\n *\n * @example\n * useOthersListener({ type, user, others }) => {\n *   if (type === 'enter') {\n *     // `user` has joined the room\n *   } else if (type === 'leave') {\n *     // `user` has left the room\n *   }\n * })\n */\nconst _useOthersListener: TypedBundle[\"useOthersListener\"] = useOthersListener;\n\n/**\n * Returns the Room of the nearest RoomProvider above in the React component\n * tree.\n */\nconst _useRoom: TypedBundle[\"useRoom\"] = useRoom;\n\n/**\n * Returns whether the hook is called within a RoomProvider context.\n *\n * @example\n * const isInsideRoom = useIsInsideRoom();\n */\nconst _useIsInsideRoom: TypedBundle[\"useIsInsideRoom\"] = useIsInsideRoom;\n\n/**\n * Returns a function that adds a reaction from a comment.\n *\n * @example\n * const addReaction = useAddReaction();\n * addReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n */\nconst _useAddReaction: TypedBundle[\"useAddReaction\"] = useAddReaction;\n\n/**\n * Create a callback function that lets you mutate Liveblocks state.\n *\n * The first argument that gets passed into your callback will be\n * a \"mutation context\", which exposes the following:\n *\n *   - `storage` - The mutable Storage root.\n *                 You can mutate any Live structures with this, for example:\n *                 `storage.get('layers').get('layer1').set('fill', 'red')`\n *\n *   - `setMyPresence` - Call this with a new (partial) Presence value.\n *\n *   - `self` - A read-only version of the latest self, if you need it to\n *              compute the next state.\n *\n *   - `others` - A read-only version of the latest others list, if you\n *                need it to compute the next state.\n *\n * useMutation is like React's useCallback, except that the first argument\n * that gets passed into your callback will be a \"mutation context\".\n *\n * If you want get access to the immutable root somewhere in your mutation,\n * you can use `storage.ToImmutable()`.\n *\n * @example\n * const fillLayers = useMutation(\n *   ({ storage }, color: Color) => {\n *     ...\n *   },\n *   [],\n * );\n *\n * fillLayers('red');\n *\n * const deleteLayers = useMutation(\n *   ({ storage }) => {\n *     ...\n *   },\n *   [],\n * );\n *\n * deleteLayers();\n */\nconst _useMutation: TypedBundle[\"useMutation\"] = useMutation;\n\n/**\n * Returns a function that creates a thread with an initial comment, and optionally some metadata.\n *\n * @example\n * const createThread = useCreateThread();\n * createThread({ body: {}, metadata: {} });\n */\nconst _useCreateThread: TypedBundle[\"useCreateThread\"] = useCreateThread;\n\n/**\n * Returns a function that deletes a thread and its associated comments.\n * Only the thread creator can delete a thread, it will throw otherwise.\n *\n * @example\n * const deleteThread = useDeleteThread();\n * deleteThread(\"th_xxx\");\n */\nconst _useDeleteThread: TypedBundle[\"useDeleteThread\"] = useDeleteThread;\n\n/**\n * Returns a function that edits a thread's metadata.\n * To delete an existing metadata property, set its value to `null`.\n *\n * @example\n * const editThreadMetadata = useEditThreadMetadata();\n * editThreadMetadata({ threadId: \"th_xxx\", metadata: {} })\n */\nconst _useEditThreadMetadata: TypedBundle[\"useEditThreadMetadata\"] =\n  useEditThreadMetadata;\n\n/**\n * useEventListener is a React hook that allows you to respond to events broadcast\n * by other users in the room.\n *\n * The `user` argument will indicate which `User` instance sent the message.\n * This will be equal to one of the others in the room, but it can be `null`\n * in case this event was broadcasted from the server.\n *\n * @example\n * useEventListener(({ event, user, connectionId }) => {\n * //                         ^^^^ Will be Client A\n *   if (event.type === \"CUSTOM_EVENT\") {\n *     // Do something\n *   }\n * });\n */\nconst _useEventListener: TypedBundle[\"useEventListener\"] = useEventListener;\n\n/**\n * Returns the presence of the current user of the current room, and a function to update it.\n * It is different from the setState function returned by the useState hook from\n * You don't need to pass the full presence object to update it.\n *\n * @example\n * const [myPresence, updateMyPresence] = useMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, \"myPresence\" will be equal to \"{ x: 0, y: 0 }\"\n */\nconst _useMyPresence: TypedBundle[\"useMyPresence\"] = useMyPresence;\n\n/**\n * Related to useOthers(), but optimized for selecting only \"subsets\" of\n * others. This is useful for performance reasons in particular, because\n * selecting only a subset of users also means limiting the number of\n * re-renders that will be triggered.\n *\n * @example\n * const avatars = useOthersMapped(user => user.info.avatar);\n * //    ^^^^^^^\n * //    { connectionId: number; data: string }[]\n *\n * The selector function you pass to useOthersMapped() is called an \"item\n * selector\", and operates on a single user at a time. If you provide an\n * (optional) \"item comparison\" function, it will be used to compare each\n * item pairwise.\n *\n * For example, to select multiple properties:\n *\n * @example\n * const avatarsAndCursors = useOthersMapped(\n *   user => [u.info.avatar, u.presence.cursor],\n *   shallow,  // 👈\n * );\n */\nconst _useOthersMapped: TypedBundle[\"useOthersMapped\"] = useOthersMapped;\n\n/**\n * Related to useOthers(), but optimized for selecting only \"subsets\" of\n * others. This is useful for performance reasons in particular, because\n * selecting only a subset of users also means limiting the number of\n * re-renders that will be triggered.\n *\n * @example\n * const avatars = useOthersMapped(user => user.info.avatar);\n * //    ^^^^^^^\n * //    { connectionId: number; data: string }[]\n *\n * The selector function you pass to useOthersMapped() is called an \"item\n * selector\", and operates on a single user at a time. If you provide an\n * (optional) \"item comparison\" function, it will be used to compare each\n * item pairwise.\n *\n * For example, to select multiple properties:\n *\n * @example\n * const avatarsAndCursors = useOthersMapped(\n *   user => [u.info.avatar, u.presence.cursor],\n *   shallow,  // 👈\n * );\n */\nconst _useOthersMappedSuspense: TypedBundle[\"suspense\"][\"useOthersMapped\"] =\n  useOthersMappedSuspense;\n\n/**\n * Returns the threads within the current room.\n *\n * @example\n * const { threads, error, isLoading } = useThreads();\n */\nconst _useThreads: TypedBundle[\"useThreads\"] = useThreads;\n\n/**\n * Returns the threads within the current room.\n *\n * @example\n * const { threads } = useThreads();\n */\nconst _useThreadsSuspense: TypedBundle[\"suspense\"][\"useThreads\"] =\n  useThreadsSuspense;\n\n/**\n * Returns the user's notification settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomNotificationSettings();\n */\nconst _useRoomNotificationSettings: TypedBundle[\"useRoomNotificationSettings\"] =\n  useRoomNotificationSettings;\n\n/**\n * Returns the user's notification settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomNotificationSettings();\n */\nconst _useRoomNotificationSettingsSuspense: TypedBundle[\"suspense\"][\"useRoomNotificationSettings\"] =\n  useRoomNotificationSettingsSuspense;\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions, error, isLoading } = useHistoryVersions();\n */\nconst _useHistoryVersions: TypedBundle[\"useHistoryVersions\"] =\n  useHistoryVersions;\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions } = useHistoryVersions();\n */\nconst _useHistoryVersionsSuspense: TypedBundle[\"suspense\"][\"useHistoryVersions\"] =\n  useHistoryVersionsSuspense;\n\n/**\n * Given a connection ID (as obtained by using `useOthersConnectionIds`), you\n * can call this selector deep down in your component stack to only have the\n * component re-render if properties for this particular user change.\n *\n * @example\n * // Returns only the selected values re-renders whenever that selection changes)\n * const { x, y } = useOther(2, user => user.presence.cursor);\n */\nconst _useOther: TypedBundle[\"useOther\"] = useOther;\n\n/**\n * Returns an array with information about all the users currently connected in\n * the room (except yourself).\n *\n * @example\n * const others = useOthers();\n *\n * // Example to map all cursors in JSX\n * return (\n *   <>\n *     {others.map((user) => {\n *        if (user.presence.cursor == null) {\n *          return null;\n *        }\n *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />\n *      })}\n *   </>\n * )\n */\nfunction _useOthers(): readonly User<DP, DU>[];\n/**\n * Extract arbitrary data based on all the users currently connected in the\n * room (except yourself).\n *\n * The selector function will get re-evaluated any time a user enters or\n * leaves the room, as well as whenever their presence data changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useOthers()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);\n * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);\n * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));\n *\n */\nfunction _useOthers<T>(\n  selector: (others: readonly User<DP, DU>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useOthers(...args: any[]) {\n  return useOthers(...(args as []));\n}\n\n/**\n * Given a connection ID (as obtained by using `useOthersConnectionIds`), you\n * can call this selector deep down in your component stack to only have the\n * component re-render if properties for this particular user change.\n *\n * @example\n * // Returns only the selected values re-renders whenever that selection changes)\n * const { x, y } = useOther(2, user => user.presence.cursor);\n */\nconst _useOtherSuspense: TypedBundle[\"suspense\"][\"useOther\"] = useOtherSuspense;\n\n/**\n * Returns an array with information about all the users currently connected in\n * the room (except yourself).\n *\n * @example\n * const others = useOthers();\n *\n * // Example to map all cursors in JSX\n * return (\n *   <>\n *     {others.map((user) => {\n *        if (user.presence.cursor == null) {\n *          return null;\n *        }\n *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />\n *      })}\n *   </>\n * )\n */\nfunction _useOthersSuspense(): readonly User<DP, DU>[];\n/**\n * Extract arbitrary data based on all the users currently connected in the\n * room (except yourself).\n *\n * The selector function will get re-evaluated any time a user enters or\n * leaves the room, as well as whenever their presence data changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useOthers()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);\n * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);\n * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));\n *\n */\nfunction _useOthersSuspense<T>(\n  selector: (others: readonly User<DP, DU>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useOthersSuspense(...args: any[]) {\n  return useOthersSuspense(...(args as []));\n}\n\n/**\n * Extract arbitrary data from the Liveblocks Storage state, using an\n * arbitrary selector function.\n *\n * The selector function will get re-evaluated any time something changes in\n * Storage. The value returned by your selector function will also be the\n * value returned by the hook.\n *\n * The `root` value that gets passed to your selector function is\n * a immutable/readonly version of your Liveblocks storage root.\n *\n * The component that uses this hook will automatically re-render if the\n * returned value changes.\n *\n * By default `useStorage()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n */\nconst _useStorage: TypedBundle[\"useStorage\"] = useStorage;\n\n/**\n * Extract arbitrary data from the Liveblocks Storage state, using an\n * arbitrary selector function.\n *\n * The selector function will get re-evaluated any time something changes in\n * Storage. The value returned by your selector function will also be the\n * value returned by the hook.\n *\n * The `root` value that gets passed to your selector function is\n * a immutable/readonly version of your Liveblocks storage root.\n *\n * The component that uses this hook will automatically re-render if the\n * returned value changes.\n *\n * By default `useStorage()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n */\nconst _useStorageSuspense: TypedBundle[\"suspense\"][\"useStorage\"] =\n  useStorageSuspense;\n\n/**\n * Gets the current user once it is connected to the room.\n *\n * @example\n * const me = useSelf();\n * if (me !== null) {\n *   const { x, y } = me.presence.cursor;\n * }\n */\nfunction _useSelf(): User<DP, DU> | null;\n/**\n * Extract arbitrary data based on the current user.\n *\n * The selector function will get re-evaluated any time your presence data\n * changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useSelf()` uses strict `===` to check for equality. Take extra\n * care when returning a computed object or list, for example when you return\n * the result of a .map() or .filter() call from the selector. In those\n * cases, you'll probably want to use a `shallow` comparison check.\n *\n * Will return `null` while Liveblocks isn't connected to a room yet.\n *\n * @example\n * const cursor = useSelf(me => me.presence.cursor);\n * if (cursor !== null) {\n *   const { x, y } = cursor;\n * }\n *\n */\nfunction _useSelf<T>(\n  selector: (me: User<DP, DU>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | null;\nfunction _useSelf(...args: any[]) {\n  return useSelf(...(args as []));\n}\n\n/**\n * Gets the current user once it is connected to the room.\n *\n * @example\n * const me = useSelf();\n * const { x, y } = me.presence.cursor;\n */\nfunction _useSelfSuspense(): User<DP, DU>;\n/**\n * Extract arbitrary data based on the current user.\n *\n * The selector function will get re-evaluated any time your presence data\n * changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useSelf()` uses strict `===` to check for equality. Take extra\n * care when returning a computed object or list, for example when you return\n * the result of a .map() or .filter() call from the selector. In those\n * cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const cursor = useSelf(me => me.presence.cursor);\n * const { x, y } = cursor;\n *\n */\nfunction _useSelfSuspense<T>(\n  selector: (me: User<DP, DU>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useSelfSuspense(...args: any[]) {\n  return useSelfSuspense(...(args as []));\n}\n\n/**\n * Returns the mutable (!) Storage root. This hook exists for\n * backward-compatible reasons.\n *\n * @example\n * const [root] = useStorageRoot();\n */\nconst _useStorageRoot: TypedBundle[\"useStorageRoot\"] = useStorageRoot;\n\n/**\n * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.\n * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.\n *\n * @example\n * const updateMyPresence = useUpdateMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, the presence of the current user will be equal to \"{ x: 0, y: 0 }\"\n */\nconst _useUpdateMyPresence: TypedBundle[\"useUpdateMyPresence\"] =\n  useUpdateMyPresence;\n\nexport {\n  RoomContext,\n  _RoomProvider as RoomProvider,\n  _useAddReaction as useAddReaction,\n  useAddRoomCommentReaction,\n  useAttachmentUrl,\n  useAttachmentUrlSuspense,\n  useBatch,\n  _useBroadcastEvent as useBroadcastEvent,\n  useCanRedo,\n  useCanUndo,\n  useCreateComment,\n  useCreateRoomComment,\n  useCreateRoomThread,\n  useCreateTextMention,\n  _useCreateThread as useCreateThread,\n  useDeleteComment,\n  useDeleteRoomComment,\n  useDeleteRoomThread,\n  useDeleteTextMention,\n  _useDeleteThread as useDeleteThread,\n  useEditComment,\n  useEditRoomComment,\n  useEditRoomThreadMetadata,\n  _useEditThreadMetadata as useEditThreadMetadata,\n  _useEventListener as useEventListener,\n  useHistory,\n  useHistoryVersionData,\n  _useHistoryVersions as useHistoryVersions,\n  _useHistoryVersionsSuspense as useHistoryVersionsSuspense,\n  _useIsInsideRoom as useIsInsideRoom,\n  useLostConnectionListener,\n  useMarkRoomThreadAsRead,\n  useMarkRoomThreadAsResolved,\n  useMarkRoomThreadAsUnresolved,\n  useMarkThreadAsRead,\n  useMarkThreadAsResolved,\n  useMarkThreadAsUnresolved,\n  useMentionSuggestionsCache,\n  _useMutation as useMutation,\n  _useMyPresence as useMyPresence,\n  _useOther as useOther,\n  _useOthers as useOthers,\n  useOthersConnectionIds,\n  useOthersConnectionIdsSuspense,\n  _useOthersListener as useOthersListener,\n  _useOthersMapped as useOthersMapped,\n  _useOthersMappedSuspense as useOthersMappedSuspense,\n  _useOthersSuspense as useOthersSuspense,\n  _useOtherSuspense as useOtherSuspense,\n  useRedo,\n  useRemoveReaction,\n  useRemoveRoomCommentReaction,\n  useReportTextEditor,\n  useResolveMentionSuggestions,\n  _useRoom as useRoom,\n  useRoomAttachmentUrl,\n  _useRoomNotificationSettings as useRoomNotificationSettings,\n  _useRoomNotificationSettingsSuspense as useRoomNotificationSettingsSuspense,\n  useRoomPermissions,\n  _useSelf as useSelf,\n  _useSelfSuspense as useSelfSuspense,\n  useStatus,\n  _useStorage as useStorage,\n  _useStorageRoot as useStorageRoot,\n  useStorageStatus,\n  useStorageStatusSuspense,\n  _useStorageSuspense as useStorageSuspense,\n  _useThreads as useThreads,\n  _useThreadsSuspense as useThreadsSuspense,\n  useThreadSubscription,\n  useUndo,\n  _useUpdateMyPresence as useUpdateMyPresence,\n  useUpdateRoomNotificationSettings,\n  useYjsProvider,\n};\n","import type { BaseMetadata } from \"@liveblocks/client\";\nimport { useEffect } from \"react\";\n\nimport type { ThreadsAsyncResult } from \"./types\";\n\nfunction handleScrollToCommentOnLoad(\n  shouldScrollOnLoad: boolean,\n  state: ThreadsAsyncResult<BaseMetadata>\n) {\n  if (shouldScrollOnLoad === false) return;\n\n  if (!state.threads) return;\n\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n\n  // If the hash is not a comment ID, we do not scroll to it\n  if (!commentId.startsWith(\"cm_\")) return;\n\n  // If a comment with the ID does not exist in the DOM, we do not scroll to it\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment is not in the threads for this hook, we do not scroll to it\n  if (!isCommentInThreads) return;\n\n  comment.scrollIntoView();\n}\n\n/**\n * Scroll to the comment with the ID in the hash of the URL based on whether\n * the query is loading and whether the hook should scroll to the comment on load.\n */\nexport function useScrollToCommentOnLoadEffect(\n  shouldScrollOnLoad: boolean,\n  state: ThreadsAsyncResult<BaseMetadata>\n) {\n  useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n"],"names":["nextSelection","kInternal","shallow","createContext","useCallback","useContext","useEffect","useMemo","useSyncExternalStore","useEffect","useRef","batch","console","MutableSignal","shallow","noop","MutableSignal","updates","shallow","threads","batch","console","existingComment","existingReaction","createContext","identity","useInboxNotificationThread","useMarkInboxNotificationAsRead","useMarkAllInboxNotificationsAsRead","useDeleteInboxNotification","useDeleteAllInboxNotifications","LiveblocksProvider","shallow","useEffect","useCallback","kInternal","useSyncExternalStore","useClient","useSyncStatus","useContext","useMemo","shallow","assert","console","DefaultMap","kInternal","makePoller","useCallback","useEffect","useMemo","useRef","useState","useSyncExternalStore","useEffect","comment","jsx","noop","identity","kInternal","_extras","_bundles","console","DefaultMap","makePoller","useState","useCallback","useEffect","room","useSyncExternalStore","useRef","shallow","other","rootOrNull","useMemo","metadata","comment","inboxNotification","assert","settings"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]}},
    {"offset": {"line": 3811, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3897, "column": 0}, "map": {"version":3,"sources":["file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/version.ts","file:///home/abhijeet/repos/contextCanvas/node_modules/%40liveblocks/react/src/ClientSideSuspense.tsx"],"sourcesContent":["declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/react\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import type { ReactNode } from \"react\";\nimport { Suspense, useEffect, useState } from \"react\";\n\ntype Props = {\n  fallback: ReactNode;\n  children: (() => ReactNode | undefined) | ReactNode | undefined;\n};\n\n/**\n * Almost like a normal <Suspense> component, except that for server-side\n * renders, the fallback will be used.\n *\n * The child props will have to be provided in a function, i.e. change:\n *\n *   <Suspense fallback={<Loading />}>\n *     <MyRealComponent a={1} />\n *   </Suspense>\n *\n * To:\n *\n *   <ClientSideSuspense fallback={<Loading />}>\n *     <MyRealComponent a={1} />\n *   </ClientSideSuspense>\n *\n */\nexport function ClientSideSuspense(props: Props) {\n  const [mounted, setMounted] = useState(false);\n\n  useEffect(() => {\n    // Effects are never executed on the server side. The point of this is to\n    // delay the flipping of this boolean until after hydration has happened.\n    setMounted(true);\n  }, []);\n\n  return (\n    <Suspense fallback={props.fallback}>\n      {mounted\n        ? typeof props.children === \"function\"\n          ? props.children()\n          : props.children\n        : props.fallback}\n    </Suspense>\n  );\n}\n"],"names":[],"mappings":";;;;;;;;ACCA,SAAS,UAAU,WAAW,gBAAgB;AAkC1C;ADhCG,IAAM,WAAW;AACjB,IAAM,cAAiD;AACvD,IAAM,aAAgD;;;ACoBtD,SAAS,mBAAmB,KAAA,EAAc;IAC/C,MAAM,CAAC,SAAS,UAAU,CAAA,qKAAI,WAAA,EAAS,KAAK;IAE5C,CAAA,GAAA,6JAAA,CAAA,YAAA;wCAAU,MAAM;YAGd,WAAW,IAAI;QACjB;uCAAG,CAAC,CAAC;IAEL,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,gKAAC,WAAA,EAAA;QAAS,UAAU,MAAM,QAAA;QACvB,UAAA,UACG,OAAO,MAAM,QAAA,KAAa,aACxB,MAAM,QAAA,CAAS,IACf,MAAM,QAAA,GACR,MAAM,QAAA;IAAA,CACZ;AAEJ","ignoreList":[0,1]}},
    {"offset": {"line": 3926, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}