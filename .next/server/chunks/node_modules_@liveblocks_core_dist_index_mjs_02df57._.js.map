{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/version.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/dupe-detection.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/convert-plain-data.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/fancy-console.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/guards.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/utils.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/autoRetry.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/controlledPromise.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/EventSource.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/freeze.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/signals.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/stringify.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/batch.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/chunk.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/nanoid.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/createIds.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/DefaultMap.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/objectToQuery.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/url.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/api-client.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/assert.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/fsm.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/protocol/ServerMsg.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/types/IWebSocket.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/connection.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/protocol/AuthToken.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/auth-manager.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/constants.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/internal.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/devtools/bridge.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/devtools/index.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/position.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/protocol/Op.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/crdts/AbstractCrdt.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/protocol/SerializedCrdt.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/crdts/LiveRegister.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/crdts/LiveList.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/crdts/LiveMap.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/crdts/LiveObject.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/crdts/liveblocks-helpers.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/debug.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/Json.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/protocol/ClientMsg.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/refs/ManagedOthers.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/types/LiveblocksError.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/room.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/client.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/comments/comment-body.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/comments/comment-url.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/crdts/utils.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/immutable.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/deprecation.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/Poller.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/shallow.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/lib/SortedList.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/types/Others.ts","file://C%3A/CodeRelay/main/contextCanvas/node_modules/%40liveblocks/core/src/index.ts"],"sourcesContent":["declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/core\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import { PKG_NAME, PKG_VERSION } from \"./version\";\n\nconst g = (\n  typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof window !== \"undefined\"\n      ? window\n      : typeof global !== \"undefined\"\n        ? global\n        : {}\n) as { [key: symbol]: string };\n\nconst crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nconst dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nconst SPACE = \" \"; // Important space to make sure links in errors are clickable in all browsers\n\nfunction error(msg: string): void {\n  if (process.env.NODE_ENV === \"production\") {\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\n\n/**\n * Throws an error if multiple copies of a Liveblocks package are being loaded\n * at runtime. This likely indicates a packaging issue with the project.\n */\nexport function detectDupes(\n  pkgName: string,\n  pkgVersion: string | false, // false if not built yet\n  pkgFormat: string | false // false if not built yet\n): void {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat\n    ? `${pkgVersion || \"dev\"} (${pkgFormat})`\n    : pkgVersion || \"dev\";\n\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n    // Allow it, see https://github.com/liveblocks/liveblocks/pull/1004\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${\n        dupesDocs + SPACE\n      }`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`,\n    ].join(\"\\n\");\n    error(msg);\n  }\n\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${\n          crossLinkedDocs + SPACE\n        }`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\",\n      ].join(\"\\n\")\n    );\n  }\n}\n","import type {\n  BaseMetadata,\n  CommentData,\n  CommentDataPlain,\n  CommentUserReaction,\n  CommentUserReactionPlain,\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./protocol/InboxNotifications\";\n\n/**\n * Converts a plain comment data object (usually returned by the API) to a comment data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment data object (usually returned by the API)\n * @returns The rich comment data object that can be used by the client.\n */\nexport function convertToCommentData(data: CommentDataPlain): CommentData {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : undefined;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt),\n  }));\n\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt,\n    };\n  }\n}\n\n/**\n * Converts a plain thread data object (usually returned by the API) to a thread data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain thread data object (usually returned by the API)\n * @returns The rich thread data object that can be used by the client.\n */\nexport function convertToThreadData<M extends BaseMetadata>(\n  data: ThreadDataPlain<M>\n): ThreadData<M> {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n\n  const comments = data.comments.map((comment) =>\n    convertToCommentData(comment)\n  );\n\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments,\n  };\n}\n\n/**\n * Converts a plain comment reaction object (usually returned by the API) to a comment reaction object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment reaction object (usually returned by the API)\n * @returns The rich comment reaction object that can be used by the client.\n */\nexport function convertToCommentUserReaction(\n  data: CommentUserReactionPlain\n): CommentUserReaction {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt),\n  };\n}\n\n/**\n * Converts a plain inbox notification data object (usually returned by the API) to an inbox notification data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain inbox notification data object (usually returned by the API)\n * @returns The rich inbox notification data object that can be used by the client.\n */\nexport function convertToInboxNotificationData(\n  data: InboxNotificationDataPlain\n): InboxNotificationData {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt),\n    }));\n\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities,\n    };\n  }\n\n  return {\n    ...data,\n    notifiedAt,\n    readAt,\n  };\n}\n\nexport function convertToThreadDeleteInfo(\n  data: ThreadDeleteInfoPlain\n): ThreadDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToInboxNotificationDeleteInfo(\n  data: InboxNotificationDeleteInfoPlain\n): InboxNotificationDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n","/* eslint-disable rulesdir/console-must-be-fancy */\n\nconst badge =\n  \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nconst bold = \"font-weight:600\";\n\nfunction wrap(\n  method: \"log\" | \"warn\" | \"error\"\n): (message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (message, ...args) =>\n        console[method](\"%cLiveblocks\", badge, message, ...args);\n}\n\n// export const log = wrap(\"log\");\nexport const warn = wrap(\"warn\");\nexport const error = wrap(\"error\");\n\nfunction wrapWithTitle(\n  method: \"log\" | \"warn\" | \"error\"\n): (title: string, message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (title, message, ...args) =>\n        console[method](\n          `%cLiveblocks%c ${title}`,\n          badge,\n          bold,\n          message,\n          ...args\n        );\n}\n\n// export const logWithTitle = wrapWithTitle(\"log\");\nexport const warnWithTitle = wrapWithTitle(\"warn\");\nexport const errorWithTitle = wrapWithTitle(\"error\");\n","export function isPlainObject(\n  blob: unknown\n): blob is { [key: string]: unknown } {\n  // Implementation borrowed from pojo decoder, see\n  // https://github.com/nvie/decoders/blob/78849f843193647eb6b5307240387bdcff7161fb/src/lib/objects.js#L10-L41\n  return (\n    blob !== null &&\n    typeof blob === \"object\" &&\n    Object.prototype.toString.call(blob) === \"[object Object]\"\n  );\n}\n\n/**\n * Check if value is of shape { startsWith: string }\n */\nexport function isStartsWithOperator(\n  blob: unknown\n): blob is { startsWith: string } {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\n","import type { Json } from \"./Json\";\n\ndeclare const brand: unique symbol;\nexport type Brand<T, TBrand extends string> = T & { [brand]: TBrand };\n\nexport type DistributiveOmit<T, K extends PropertyKey> = T extends any\n  ? Omit<T, K>\n  : never;\n\n// export type DistributivePick<T, K extends keyof T> = T extends any\n//   ? Pick<T, K>\n//   : never;\n\n/**\n * Throw an error, but as an expression instead of a statement.\n */\nexport function raise(msg: string): never {\n  throw new Error(msg);\n}\n\n/**\n * Drop-in replacement for Object.entries() that retains better types.\n */\nexport function entries<\n  O extends { [key: string]: unknown },\n  K extends keyof O,\n>(obj: O): [K, O[K]][] {\n  return Object.entries(obj) as [K, O[K]][];\n}\n\n/**\n * Drop-in replacement for Object.keys() that retains better types.\n */\nexport function keys<O extends { [key: string]: unknown }, K extends keyof O>(\n  obj: O\n): K[] {\n  return Object.keys(obj) as K[];\n}\n\n/**\n * Drop-in replacement for Object.values() that retains better types.\n */\nexport function values<O extends Record<string, unknown>>(\n  obj: O\n): O[keyof O][] {\n  return Object.values(obj) as O[keyof O][];\n}\n\n/**\n * Creates a new object by mapping a function over all values. Keys remain the\n * same. Think Array.prototype.map(), but for values in an object.\n */\nexport function mapValues<V, O extends Record<string, unknown>>(\n  obj: O,\n  mapFn: (value: O[keyof O], key: keyof O) => V\n): { [K in keyof O]: V } {\n  const result = {} as { [K in keyof O]: V };\n  for (const pair of Object.entries(obj)) {\n    const key: keyof O = pair[0];\n    if (key === \"__proto__\") {\n      // Avoid setting dangerous __proto__ keys\n      continue;\n    }\n    const value = pair[1] as O[keyof O];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\n\n/**\n * Alternative to JSON.parse() that will not throw in production. If the passed\n * string cannot be parsed, this will return `undefined`.\n */\nexport function tryParseJson(rawMessage: string): Json | undefined {\n  try {\n    // eslint-disable-next-line no-restricted-syntax\n    return JSON.parse(rawMessage) as Json;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Deep-clones a JSON-serializable value.\n *\n * NOTE: We should be able to replace `deepClone` by `structuredClone` once\n * we've upgraded to Node 18.\n */\nexport function deepClone<T extends Json>(value: T): T {\n  // NOTE: In this case, the combination of JSON.parse() and JSON.stringify\n  // won't lead to type unsafety, so this use case is okay.\n  // eslint-disable-next-line no-restricted-syntax\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n\n/**\n * Decode base64 string.\n */\nexport function b64decode(b64value: string): string {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue)\n        .split(\"\")\n        .map(function (c) {\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\n\n/**\n * Mutates the array in-place by removing the first occurrence of `item` from\n * the array.\n */\nexport function remove<T>(array: T[], item: T): void {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n      break;\n    }\n  }\n}\n\n/**\n * Removes null and undefined values from the array, and reflects this in the\n * output type.\n */\nexport function compact<T>(items: readonly T[]): NonNullable<T>[] {\n  return items.filter(\n    (item: T): item is NonNullable<T> => item !== null && item !== undefined\n  );\n}\n\nexport type RemoveUndefinedValues<T> = {\n  [K in keyof T]-?: Exclude<T[K], undefined>;\n};\n\n/**\n * Returns a new object instance where all explictly-undefined values are\n * removed.\n */\nexport function compactObject<O extends Record<string, unknown>>(\n  obj: O\n): RemoveUndefinedValues<O> {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k as keyof O;\n    if (newObj[key] === undefined) {\n      delete newObj[key];\n    }\n  });\n  return newObj as RemoveUndefinedValues<O>;\n}\n\n/**\n * Returns a promise that resolves after the given number of milliseconds.\n */\nexport function wait(millis: number): Promise<void> {\n  return new Promise((res) => setTimeout(res, millis));\n}\n\n/**\n * Returns whatever the given promise returns, but will be rejected with\n * a \"Timed out\" error if the given promise does not return or reject within\n * the given timeout period (in milliseconds).\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  millis: number,\n  errmsg: string\n): Promise<T> {\n  let timerID: ReturnType<typeof setTimeout> | undefined;\n  const timer$ = new Promise<never>((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return (\n    Promise\n      // Race the given promise against the timer. Whichever one finishes\n      // first wins the race.\n      .race([promise, timer$])\n\n      // Either way, clear the timeout, no matter who won\n      .finally(() => clearTimeout(timerID))\n  );\n}\n\n/**\n * Memoize a promise factory, so that each subsequent call will return the same\n * pending or success promise. If the promise rejects, will retain that failed\n * promise for a small time period, after which the next attempt will reset the\n * memoized value.\n */\nexport function memoizeOnSuccess<T>(\n  factoryFn: () => Promise<T>\n): () => Promise<T> {\n  let cached: Promise<T> | null = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        //\n        // Keep returning the failed promise for any calls to the memoized\n        // promise for the next 5 seconds. This time period is a bit arbitrary,\n        // but exists to make this play nicely with frameworks like React.\n        //\n        // In React, after a component is suspended and its promise is\n        // rejected, React will re-render the component, and expect the next\n        // call to this function to return the rejected promise, so its error\n        // can be shown. If we immediately reset this value, then such next\n        // render would instantly trigger a new promise which would trigger an\n        // infinite loop and keeping the component in loading state forever.\n        //\n        setTimeout(() => {\n          cached = null;\n        }, 5_000);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n","import * as console from \"./fancy-console\";\nimport { isPlainObject } from \"./guards\";\nimport type { JsonObject } from \"./Json\";\nimport { tryParseJson, wait } from \"./utils\";\n\nexport class HttpError extends Error {\n  public response: Response;\n  public details?: JsonObject;\n\n  private constructor(\n    message: string,\n    response: Response,\n    details?: JsonObject\n  ) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n\n  static async fromResponse(response: Response): Promise<HttpError> {\n    // Try to extract `message` and `details` from the response, and\n    // construct the HttpError instance\n    let bodyAsText: string | undefined;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n      // Ignore\n    }\n\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : undefined;\n\n    let bodyAsJsonObject: JsonObject | undefined;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n\n    let message = \"\";\n    message ||=\n      typeof bodyAsJsonObject?.message === \"string\"\n        ? bodyAsJsonObject.message\n        : \"\";\n    message ||=\n      typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === undefined) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n\n    let path: string | undefined;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n      // Ignore\n    }\n    message +=\n      path !== undefined\n        ? ` (got status ${response.status} from ${path})`\n        : ` (got status ${response.status})`;\n\n    const details = bodyAsJsonObject;\n    return new HttpError(message, response, details);\n  }\n\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status(): number {\n    return this.response.status;\n  }\n}\n\nconst DONT_RETRY_4XX = (x: unknown) =>\n  x instanceof HttpError && x.status >= 400 && x.status < 500;\n\n/**\n * Wraps a promise factory. Will create promises until one succeeds. If\n * a promise rejects, it will retry calling the factory for at most `maxTries`\n * times. Between each attempt, it will inject a a backoff delay (in millis)\n * from the given array. If the array contains fewer items then `maxTries`,\n * then the last backoff number will be used indefinitely.\n *\n * If the last attempt is rejected too, the returned promise will fail too.\n *\n * @param promiseFn The promise factory to execute\n * @param maxTries The number of total tries (must be >=1)\n * @param backoff An array of timings to inject between each promise attempt\n * @param shouldStopRetrying An optional function to not auto-retry on certain errors\n */\nexport async function autoRetry<T>(\n  promiseFn: () => Promise<T>,\n  maxTries: number,\n  backoff: number[],\n  shouldStopRetrying: (err: any) => boolean = DONT_RETRY_4XX\n): Promise<T> {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n\n  let attempt = 0;\n\n  while (true) {\n    attempt++;\n\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n\n      if (attempt >= maxTries) {\n        // Fail the entire promise right now\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n\n    // Do another retry\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n\n    console.warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n","/**\n * Returns a pair of a Promise, and a resolve function that can be passed\n * around to resolve the promise \"from anywhere\".\n *\n * The Promise will remain unresolved, until the resolve function is called.\n * Once the resolve function is called with a value, the Promise will resolve\n * to that value.\n *\n * Calling the resolve function beyond the first time is a no-op.\n */\nexport function controlledPromise<T>(): [\n  promise: Promise<T>,\n  resolve: (value: T) => void,\n  reject: (reason: unknown) => void,\n] {\n  let resolve: ((value: T) => void) | undefined;\n  let reject: ((reason: unknown) => void) | undefined;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  // eslint-disable-next-line no-restricted-syntax\n  return [promise, resolve!, reject!];\n}\n\n/**\n * Drop-in replacement for the ES2024 Promise.withResolvers() API.\n */\nexport function Promise_withResolvers<T>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: unknown) => void;\n} {\n  const [promise, resolve, reject] = controlledPromise<T>();\n  return { promise, resolve, reject };\n}\n","export type Callback<T> = (event: T) => void;\nexport type UnsubscribeCallback = () => void;\n\nexport type Observable<T> = {\n  /**\n   * Register a callback function to be called whenever the event source emits\n   * an event.\n   */\n  subscribe(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Register a one-time callback function to be called whenever the event\n   * source emits an event. After the event fires, the callback is\n   * auto-unsubscribed.\n   */\n  subscribeOnce(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Returns a promise that will resolve when an event is emitted by this\n   * event source. Optionally, specify a predicate that has to match. The first\n   * event matching that predicate will then resolve the promise.\n   */\n  waitUntil(predicate?: (event: T) => boolean): Promise<T>;\n};\n\nexport type EventSource<T> = Observable<T> & {\n  /**\n   * Notify all subscribers about the event. Will return `false` if there\n   * weren't any subscribers at the time the .notify() was called, or `true` if\n   * there was at least one subscriber.\n   */\n  notify(event: T): boolean;\n  /**\n   * Returns the number of active subscribers.\n   */\n  count(): number;\n  /**\n   * Observable instance, which can be used to subscribe to this event source\n   * in a readonly fashion. Safe to publicly expose.\n   */\n  observable: Observable<T>;\n  /**\n   * Disposes of this event source.\n   *\n   * Will clears all registered event listeners. None of the registered\n   * functions will ever get called again.\n   *\n   * WARNING!\n   * Be careful when using this API, because the subscribers may not have any\n   * idea they won't be notified anymore.\n   */\n  [Symbol.dispose](): void;\n};\n\nexport type BufferableEventSource<T> = EventSource<T> & {\n  /**\n   * Pauses event delivery until unpaused. Any .notify() calls made while\n   * paused will get buffered into memory and emitted later.\n   */\n  pause(): void;\n  /**\n   * Emits all in-memory buffered events, and unpauses. Any .notify() calls\n   * made after this will be synchronously delivered again.\n   */\n  unpause(): void;\n};\n\nexport type EventEmitter<T> = (event: T) => void;\n\n/**\n * makeEventSource allows you to generate a subscribe/notify pair of functions\n * to make subscribing easy and to get notified about events.\n *\n * The events are anonymous, so you can use it to define events, like so:\n *\n *   const event1 = makeEventSource();\n *   const event2 = makeEventSource();\n *\n *   event1.subscribe(foo);\n *   event1.subscribe(bar);\n *   event2.subscribe(qux);\n *\n *   // Unsubscription is pretty standard\n *   const unsub = event2.subscribe(foo);\n *   unsub();\n *\n *   event1.notify();  // Now foo and bar will get called\n *   event2.notify();  // Now qux will get called (but foo will not, since it's unsubscribed)\n *\n */\nexport function makeEventSource<T>(): EventSource<T> {\n  const _observers = new Set<Callback<T>>();\n\n  function subscribe(callback: Callback<T>): UnsubscribeCallback {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n\n  function subscribeOnce(callback: Callback<T>): UnsubscribeCallback {\n    const unsub = subscribe((event: T) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n\n  async function waitUntil(predicate?: (event: T) => boolean): Promise<T> {\n    let unsub: () => void | undefined;\n    return new Promise<T>((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === undefined || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n\n  function notify(event: T) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n\n  function count() {\n    return _observers.size;\n  }\n\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n\n    waitUntil,\n\n    [Symbol.dispose]: (): void => {\n      _observers.clear();\n    },\n\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil,\n    },\n  };\n}\n\nexport function makeBufferableEventSource<T>(): BufferableEventSource<T> {\n  const eventSource = makeEventSource<T>();\n  let _buffer: T[] | null = null;\n\n  function pause(): void {\n    _buffer = [];\n  }\n\n  function unpause(): void {\n    if (_buffer === null) {\n      // Already unpaused\n      return;\n    }\n\n    for (const event of _buffer) {\n      eventSource.notify(event);\n    }\n    _buffer = null;\n  }\n\n  function notifyOrBuffer(event: T) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource.notify(event);\n    }\n  }\n\n  return {\n    ...eventSource,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n\n    [Symbol.dispose]: (): void => {\n      eventSource[Symbol.dispose]();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    },\n  };\n}\n","/**\n * Freezes the given argument, but only in development builds. In production\n * builds, this is a no-op for performance reasons.\n */\nexport const freeze: typeof Object.freeze =\n  process.env.NODE_ENV === \"production\"\n    ? /* istanbul ignore next */ (((x: unknown) => x) as typeof Object.freeze)\n    : Object.freeze;\n","import type {\n  Callback,\n  EventSource,\n  Observable,\n  UnsubscribeCallback,\n} from \"../lib/EventSource\";\nimport { makeEventSource } from \"../lib/EventSource\";\nimport { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { compactObject, raise } from \"../lib/utils\";\n\nconst kSinks = Symbol(\"kSinks\");\nconst kTrigger = Symbol(\"kTrigger\");\n\n//\n// Before the batch is run, all sinks (recursively all the way down) are marked\n// dirty. This already is enough if we only ever use .get() calls.\n//\n// However, to ensure active subscription notifications also work, we need to\n// keep track of which Signals to notify. Any time the value of a Signal\n// changes, the Signal itself will notify its own subscribers, but \"sinks\" are\n// not \"normal\" subscribers.\n//\n// By treating sinks slightly differently, we can keep track of sink uniqueness\n// across the entire signal network, ensuring a sink will only be notified once\n// if more than one of its dependent Signals have changed.\n//\n// For example:\n//\n//      A\n//    /   \\\n//   B     C\n//    \\   /\n//      D - - - - ( has 1 normal subscriber )\n//\n// Here, B and C are sinks of A, and D is a sink of both B and C.\n//\n// Here's what will happen when A changes:\n//\n// - If A changes, then all sinks (B, C, and D) will be marked dirty.\n//\n// - Because some of A's sinks are being watched (in this case, D has at least\n//   one subscriber), A will trigger B and C that its value has changed.\n//\n// - Both B and C re-evaluate and may or may not have changed. Three\n//   possibilities:\n//   1. Neither B and C have changed → D will *NOT* be triggered\n//   2. Either B or C has changed    → D *will* be triggered\n//   3. Both B and C have changed    → D *will* be triggered (but only once!)\n//\n// - If in the previous step D has been triggered, it will re-evaluate. If it\n//   has changed itself, it will notify its normal subscriber.\n//\nlet signalsToTrigger: Set<AbstractSignal<any>> | null = null;\n\n//\n// If a derived signal is currently being computed, there is a global \"signals\n// that have been read\" registry that every call to `someSignal.get()` will\n// register itself under.\n//\nlet trackedReads: Set<AbstractSignal<any>> | null = null;\n\n/**\n * Runs a callback function that is allowed to change multiple signals. At the\n * end of the batch, all changed signals will be notified (at most once).\n *\n * Nesting batches is supported.\n */\nexport function batch(callback: Callback<void>): void {\n  if (signalsToTrigger !== null) {\n    // Already inside another batch, just run this inner callback\n    callback();\n    return;\n  }\n\n  signalsToTrigger = new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\n\n/**\n * Ensures that the signal will be notified at the end of the current batch.\n * This should only be called within a batch callback. It's safe to call this\n * while notifications are being rolled out.\n */\nfunction enqueueTrigger(signal: AbstractSignal<any>) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\n\n/**\n * Patches a target object by \"merging in\" the provided fields. Patch\n * fields that are explicitly-undefined will delete keys from the target\n * object. Will return a new object.\n *\n * Important guarantee:\n * If the patch effectively did not mutate the target object because the\n * patch fields have the same value as the original, then the original\n * object reference will be returned.\n */\nexport function merge<T>(target: T, patch: Partial<T>): T {\n  let updated = false;\n  const newValue = { ...target };\n\n  Object.keys(patch).forEach((k) => {\n    const key = k as keyof T;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === undefined) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val as T[keyof T];\n      }\n      updated = true;\n    }\n  });\n\n  return updated ? newValue : target;\n}\n\nexport type SignalType<S extends ISignal<any>> =\n  S extends ISignal<infer T> ? T : never;\n\nexport interface ISignal<T> {\n  get(): T;\n  subscribe(callback: Callback<void>): UnsubscribeCallback;\n  addSink(sink: DerivedSignal<unknown>): void;\n  removeSink(sink: DerivedSignal<unknown>): void;\n}\n\n/**\n * Base functionality every Signal implementation needs.\n */\nabstract class AbstractSignal<T> implements ISignal<T>, Observable<void> {\n  /** @internal */\n  protected readonly equals: (a: T, b: T) => boolean;\n  readonly #eventSource: EventSource<void>;\n  /** @internal */\n  public readonly [kSinks]: Set<DerivedSignal<unknown>>;\n\n  constructor(equals?: (a: T, b: T) => boolean) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource<void>();\n    this[kSinks] = new Set();\n\n    // Bind common methods to self\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n\n  [Symbol.dispose](): void {\n    this.#eventSource[Symbol.dispose]();\n\n    // @ts-expect-error make disposed object completely unusable\n    this.#eventSource = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.equals = \"(disposed)\";\n  }\n\n  // Concrete subclasses implement this method in different ways\n  abstract get(): T;\n\n  get hasWatchers(): boolean {\n    if (this.#eventSource.count() > 0) return true;\n\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public [kTrigger](): void {\n    this.#eventSource.notify();\n\n    // While Signals are being triggered in the current unroll, we can enqueue\n    // more signals to trigger (which will get added to the current unroll)\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n\n  subscribe(callback: Callback<void>): UnsubscribeCallback {\n    // If this is the first subscriber, we need to perform an initial .get()\n    // now in case this is a DerivedSignal that has not been evaluated yet. The\n    // reason we need to do this is that the .get() itself will register this\n    // signal as sinks of the dependent signals, so we will actually get\n    // notified here when one of the dependent signals changes.\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n\n  subscribeOnce(callback: Callback<void>): UnsubscribeCallback {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n\n  waitUntil(): never {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n\n  markSinksDirty(): void {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n\n  addSink(sink: DerivedSignal<unknown>): void {\n    this[kSinks].add(sink);\n  }\n\n  removeSink(sink: DerivedSignal<unknown>): void {\n    this[kSinks].delete(sink);\n  }\n\n  asReadonly(): ISignal<T> {\n    return this;\n  }\n}\n\n// NOTE: This class is pretty similar to the Signal.State proposal\nexport class Signal<T> extends AbstractSignal<T> {\n  #value: T;\n\n  constructor(value: T, equals?: (a: T, b: T) => boolean) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n\n  [Symbol.dispose](): void {\n    super[Symbol.dispose]();\n    // @ts-expect-error make disposed object completely unusable\n    this.#value = \"(disposed)\";\n  }\n\n  get(): T {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n\n  set(newValue: T | ((oldValue: T) => T)): void {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = (newValue as (oldValue: T) => T)(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n}\n\nexport class PatchableSignal<J extends JsonObject> extends Signal<J> {\n  constructor(data: J) {\n    super(freeze(compactObject(data)));\n  }\n\n  set(): void {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n\n  /**\n   * Patches the current object.\n   */\n  patch(patch: Partial<J>): void {\n    super.set((old) => merge(old, patch));\n  }\n}\n\n/**\n * Placeholder for a deferred computation that has yet to happen on-demand in\n * the future.\n */\nconst INITIAL = Symbol();\n\n// NOTE: This class is pretty similar to the Signal.Computed proposal\nexport class DerivedSignal<T> extends AbstractSignal<T> {\n  #prevValue: T;\n  #dirty: boolean; // When true, the value in #value may not be up-to-date and needs re-checking\n\n  #sources: Set<ISignal<unknown>>;\n  readonly #deps: readonly ISignal<unknown>[];\n  readonly #transform: (...values: unknown[]) => T;\n\n  // Overload 1\n  static from<Ts extends unknown[], V>(...args: [...signals: { [K in keyof Ts]: ISignal<Ts[K]> }, transform: (...values: Ts) => V]): DerivedSignal<V>; // prettier-ignore\n  // Overload 2\n  static from<Ts extends unknown[], V>(...args: [...signals: { [K in keyof Ts]: ISignal<Ts[K]> }, transform: (...values: Ts) => V, equals: (a: V, b: V) => boolean]): DerivedSignal<V>; // prettier-ignore\n  static from<Ts extends unknown[], V>(\n    // prettier-ignore\n    ...args: [\n      ...signals: { [K in keyof Ts]: ISignal<Ts[K]> },\n      transform: (...values: Ts) => V,\n      equals?: (a: V, b: V) => boolean,\n    ]\n  ): DerivedSignal<V> {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n\n    if (typeof args[args.length - 1] === \"function\") {\n      // Overload 2\n      const equals = last as (a: V, b: V) => boolean;\n      const transform = args.pop() as (...values: unknown[]) => V;\n      return new DerivedSignal(args as ISignal<unknown>[], transform, equals);\n    } else {\n      // Overload 1\n      const transform = last as (...values: unknown[]) => V;\n      return new DerivedSignal(args as ISignal<unknown>[], transform);\n    }\n  }\n\n  private constructor(\n    deps: ISignal<unknown>[],\n    transform: (...values: unknown[]) => T,\n    equals?: (a: T, b: T) => boolean\n  ) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL as unknown as T;\n    this.#deps = deps;\n    this.#sources = new Set();\n    this.#transform = transform;\n  }\n\n  [Symbol.dispose](): void {\n    for (const src of this.#sources) {\n      src.removeSink(this as DerivedSignal<unknown>);\n    }\n\n    // @ts-expect-error make disposed object completely unusable\n    this.#prevValue = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#sources = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#deps = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#transform = \"(disposed)\";\n  }\n\n  get isDirty(): boolean {\n    return this.#dirty;\n  }\n\n  #recompute(): boolean {\n    const oldTrackedReads = trackedReads;\n\n    let derived;\n    trackedReads = new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = new Set();\n\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this as DerivedSignal<unknown>);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this as DerivedSignal<unknown>);\n      }\n\n      trackedReads = oldTrackedReads;\n    }\n\n    this.#dirty = false;\n\n    // Only emit a change to watchers if the value actually changed\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n\n  markDirty(): void {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n\n  get(): T {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  public [kTrigger](): void {\n    if (!this.hasWatchers) {\n      // If there are no watchers for this signal, we don't need to\n      // re-evaluate. We can postpone re-evaluation until the next .get() call.\n      return;\n    }\n\n    // Re-evaluate the current derived signal's value and if needed,\n    // notify sinks. At this point, all sinks should already have been\n    // marked dirty, so we won't have to do that again here now.\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger](); // Actually notify subscribers\n    }\n  }\n}\n\n/**\n * A MutableSignal is a bit like Signal, except its state is managed by\n * a single value whose reference does not change but is mutated.\n *\n * Similar to how useSyncExternalState() works in React, there is a way to read\n * the current state at any point in time synchronously, and a way to update\n * its reference.\n */\nexport class MutableSignal<T extends object> extends AbstractSignal<T> {\n  readonly #state: T;\n\n  constructor(initialState: T) {\n    super();\n    this.#state = initialState;\n  }\n\n  [Symbol.dispose](): void {\n    super[Symbol.dispose]();\n    // @ts-expect-error make disposed object completely unusable\n    this.#state = \"(disposed)\";\n  }\n\n  get(): T {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback?: (state: T) => void | boolean): void {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\n\nfunction replacer(_key: string, value: unknown) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value)\n    ? Object.keys(value)\n        .sort()\n        .reduce((sorted, key) => {\n          // @ts-expect-error this is fine\n          sorted[key] = value[key];\n          return sorted;\n        }, {})\n    : value;\n}\n\n/**\n * Like JSON.stringify(), but returns the same value no matter how keys in any\n * nested objects are ordered.\n */\nexport function stringify(value: unknown): string {\n  return JSON.stringify(value, replacer);\n}\n","import type { AsyncResult } from \"./AsyncResult\";\nimport { Promise_withResolvers } from \"./controlledPromise\";\nimport type { Callback, UnsubscribeCallback } from \"./EventSource\";\nimport { MutableSignal } from \"./signals\";\nimport { stringify } from \"./stringify\";\n\nconst DEFAULT_SIZE = 50;\n\ntype Resolve<T> = (value: T) => void;\ntype Reject = (reason?: unknown) => void;\n\nexport type BatchCallback<O, I> = (\n  inputs: I[]\n) => (O | Error)[] | Promise<(O | Error)[]>;\n\nexport type BatchStore<O, I> = {\n  subscribe: (callback: Callback<void>) => UnsubscribeCallback;\n  enqueue: (input: I) => Promise<void>;\n  getItemState: (input: I) => AsyncResult<O> | undefined;\n  invalidate: (inputs?: I[]) => void;\n\n  /**\n   * @internal\n   */\n  readonly batch: Batch<O, I>;\n\n  /**\n   * @internal\n   *\n   * Only for testing.\n   */\n  _cacheKeys: () => string[];\n};\n\ninterface BatchOptions {\n  /**\n   * How many calls to batch together at most.\n   */\n  size?: number;\n\n  /**\n   * How long to wait before flushing the batch.\n   */\n  delay: number;\n}\n\nclass BatchCall<O, I> {\n  readonly input: I;\n  readonly resolve: Resolve<O>;\n  readonly reject: Reject;\n  readonly promise: Promise<O>;\n\n  constructor(input: I) {\n    this.input = input;\n\n    const { promise, resolve, reject } = Promise_withResolvers<O>();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n}\n\n/**\n * Batch calls to a function, either by number of calls or by a maximum delay.\n */\nexport class Batch<O, I> {\n  #queue: BatchCall<O, I>[] = [];\n  #callback: BatchCallback<O, I>;\n  #size: number;\n  #delay: number;\n  #delayTimeoutId?: ReturnType<typeof setTimeout>;\n  public error = false;\n\n  constructor(callback: BatchCallback<O, I>, options: BatchOptions) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n\n  #clearDelayTimeout(): void {\n    if (this.#delayTimeoutId !== undefined) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = undefined;\n    }\n  }\n\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      // If the queue is full, flush it immediately.\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      // If the call is the first in the queue, schedule a flush.\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n\n  async #flush(): Promise<void> {\n    // If the queue is empty, don't call the callback.\n    if (this.#queue.length === 0) {\n      return;\n    }\n\n    // Empty the queue and get its calls.\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n\n    try {\n      // Call the batch callback with the queued arguments.\n      const results = await this.#callback(inputs);\n      this.error = false;\n\n      // Resolve or reject each call.\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error) {\n      this.error = true;\n\n      // Reject all calls if the whole batch errored or was rejected.\n      calls.forEach((call) => {\n        call.reject(error);\n      });\n    }\n  }\n\n  get(input: I): Promise<O> {\n    // Check if there's already an identical call in the queue.\n    const existingCall = this.#queue.find(\n      (call) => stringify(call.input) === stringify(input)\n    );\n\n    // If an existing call exists, return its promise.\n    if (existingCall) {\n      return existingCall.promise;\n    }\n\n    // If no existing call exists, add the call to the queue and schedule a flush.\n    const call = new BatchCall<O, I>(input);\n    this.#queue.push(call);\n    this.#schedule();\n\n    return call.promise;\n  }\n\n  clear(): void {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n}\n\n/**\n * Create a store around a Batch.\n * Each call will be cached and get its own state in addition to being batched.\n */\nexport function createBatchStore<O, I>(batch: Batch<O, I>): BatchStore<O, I> {\n  const signal = new MutableSignal(new Map<string, AsyncResult<O>>());\n\n  function getCacheKey(args: I): string {\n    return stringify(args);\n  }\n\n  function update(cacheKey: string, state: AsyncResult<O>) {\n    signal.mutate((cache) => {\n      cache.set(cacheKey, state);\n    });\n  }\n\n  function invalidate(inputs?: I[]): void {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        // Invalidate the specific calls.\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        // Invalidate all calls.\n        cache.clear();\n      }\n    });\n  }\n\n  async function enqueue(input: I): Promise<void> {\n    const cacheKey = getCacheKey(input);\n\n    // If this call already has a state, return early.\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n\n    try {\n      // Set the state to loading.\n      update(cacheKey, { isLoading: true });\n\n      // Wait for the batch to process this call.\n      const result = await batch.get(input);\n\n      // Set the state to the result.\n      update(cacheKey, { isLoading: false, data: result });\n    } catch (error) {\n      // // TODO: Differentiate whole batch errors from individual errors.\n      // if (batch.error) {\n      //   // If the whole batch errored, clear the state.\n      //   // TODO: Keep track of retries and only clear the state a few times because it will be retried each time.\n      //   //       Also implement exponential backoff to delay retries to avoid hammering `resolveUsers`.\n      //   update(cacheKey, undefined);\n      // } else {\n      //   // Otherwise, keep individual errors to avoid repeatedly loading the same error.\n      //   update(cacheKey, {\n      //     isLoading: false,\n      //     error: error as Error,\n      //   });\n      // }\n\n      // If there was an error (for various reasons), set the state to the error.\n      update(cacheKey, {\n        isLoading: false,\n        error: error as Error,\n      });\n    }\n  }\n\n  function getItemState(input: I): AsyncResult<O> | undefined {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n\n  /** @internal - Only for testing */\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    getItemState,\n    invalidate,\n\n    batch,\n    _cacheKeys,\n  };\n}\n","export function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n\n  return chunks;\n}\n","// Inlined version of 3.3.7 of nanoid.js\n// https://www.npmjs.com/package/nanoid/v/3.3.7?activeTab=code\nexport const nanoid = (t = 21): string =>\n  crypto\n    .getRandomValues(new Uint8Array(t))\n    .reduce(\n      (t, e) =>\n        (t +=\n          (e &= 63) < 36\n            ? e.toString(36)\n            : e < 62\n              ? (e - 26).toString(36).toUpperCase()\n              : e < 63\n                ? \"_\"\n                : \"-\"),\n      \"\"\n    );\n","import { nanoid } from \"./nanoid\";\n\nconst THREAD_ID_PREFIX = \"th\";\nconst COMMENT_ID_PREFIX = \"cm\";\nconst COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nconst INBOX_NOTIFICATION_ID_PREFIX = \"in\";\n\nfunction createOptimisticId(prefix: string): string {\n  return `${prefix}_${nanoid()}`;\n}\n\nexport function createThreadId(): string {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\n\nexport function createCommentId(): string {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\n\nexport function createCommentAttachmentId(): string {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\n\nexport function createInboxNotificationId(): string {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n","import { raise } from \"./utils\";\n\n/**\n * Like ES6 map, but takes a default (factory) function which will be used\n * to create entries for missing keys on the fly.\n *\n * Useful for code like:\n *\n *   const map = new DefaultMap(() => []);\n *   map.getOrCreate('foo').push('hello');\n *   map.getOrCreate('foo').push('world');\n *   map.getOrCreate('foo')\n *   // ['hello', 'world']\n *\n */\nexport class DefaultMap<K, V> extends Map<K, V> {\n  #defaultFn?: (key: K) => V;\n\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(\n    defaultFn?: (key: K) => V,\n    entries?: readonly (readonly [K, V])[] | null\n  ) {\n    super(entries);\n    this.#defaultFn = defaultFn;\n  }\n\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key: K, defaultFn?: (key: K) => V): V {\n    if (super.has(key)) {\n      // eslint-disable-next-line no-restricted-syntax\n      return super.get(key)!;\n    } else {\n      const fn =\n        defaultFn ??\n        this.#defaultFn ??\n        raise(\"DefaultMap used without a factory function\");\n\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n}\n","import { isPlainObject, isStartsWithOperator } from \"./guards\";\n\n/**\n * Converts an object to a query string\n * Example:\n * ```ts\n * const query = objectToQuery({\n *   resolved: true,\n *   metadata: {\n *     status: \"open\",\n *     priority: 3,\n *     org: {\n *       startsWith: \"liveblocks:\",\n *     },\n *   },\n * });\n *\n * console.log(query);\n * // resolved:true AND metadata[\"status\"]:open AND metadata[\"priority\"]:3 AND metadata[\"org\"]^\"liveblocks:\"\n * ```\n */\ntype SimpleFilterValue = string | number | boolean | null;\ntype OperatorFilterValue = { startsWith: string };\n\ntype FilterValue = SimpleFilterValue | OperatorFilterValue;\n\ntype Filter = NumberFilter | StringFilter | BooleanFilter | NullFilter;\n\ntype NumberFilter = {\n  key: string;\n  operator: \":\";\n  value: number;\n};\n\ntype StringFilter = {\n  key: string;\n  operator: \":\" | \"^\";\n  value: string;\n};\n\ntype BooleanFilter = {\n  key: string;\n  operator: \":\";\n  value: boolean;\n};\n\ntype NullFilter = {\n  key: string;\n  operator: \":\";\n  value: null;\n};\n\n/**\n * Converts an object to a query string\n * @example\n * ```ts\n * const query = objectToQuery({\n *  metadata: {\n *    status: \"open\",\n *    priority: 3,\n *    org: {\n *      startsWith: \"liveblocks:\",\n *    },\n *  },\n * });\n * console.log(query);\n * // metadata[\"status\"]:\"open\" AND metadata[\"priority\"]:3 AND metadata[\"org\"]^\"liveblocks:\"\n * ```\n * @example\n * ```ts\n * const query = objectToQuery({\n *  resolved: true,\n *  roomId: {\n *   startsWith: \"engineering:\",\n *  },\n * });\n * console.log(query);\n * // resolved:true AND roomId^\"engineering:\"\n * ```\n *\n */\n\nconst identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\nexport function objectToQuery(obj: {\n  [key: string]:\n    | FilterValue\n    | { [key: string]: FilterValue | undefined }\n    | undefined;\n}): string {\n  let filterList: Filter[] = [];\n  const entries = Object.entries(obj);\n\n  const keyValuePairs: [string, string | number | boolean | null][] = [];\n  const keyValuePairsWithOperator: [string, Record<\"startsWith\", string>][] =\n    [];\n  const indexedKeys: [string, Record<string, FilterValue | undefined>][] = [];\n\n  entries.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator),\n  ];\n\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs: [string, SimpleFilterValue][] = [];\n    const nKeyValuePairsWithOperator: [string, OperatorFilterValue][] = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue,\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator),\n    ];\n  });\n\n  return filterList\n    .map(({ key, operator, value }) => `${key}${operator}${quote(value)}`)\n    .join(\" \");\n}\n\nconst getFiltersFromKeyValuePairs = (\n  keyValuePairs: [string, string | number | boolean | null][]\n): Filter[] => {\n  const filters: Filter[] = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value,\n    });\n  });\n\n  return filters;\n};\n\nconst getFiltersFromKeyValuePairsWithOperator = (\n  keyValuePairsWithOperator: [string, { startsWith: string }][]\n): Filter[] => {\n  const filters: Filter[] = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith,\n      });\n    }\n  });\n\n  return filters;\n};\n\nconst isSimpleValue = (value: unknown) => {\n  return (\n    typeof value === \"string\" ||\n    typeof value === \"number\" ||\n    typeof value === \"boolean\" ||\n    value === null\n  );\n};\n\nconst formatFilterKey = (key: string, nestedKey?: string) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\n\nconst isStringEmpty = (value: string) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n/**\n * Quotes and escapes a string. Prefer to use single quotes when possible, but\n * falls back to JSON.stringify() (which uses double-quotes) when necessary.\n */\nexport function quote(input: unknown): string {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  if (result.includes(\"'\")) {\n    return result;\n  }\n\n  // See if we can turn this string into a single-quoted string, because those\n  // generally are more readable in URLs\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n","import type { Brand } from \"./utils\";\n\nexport type QueryParams =\n  | Record<string, string | number | null | undefined>\n  | URLSearchParams;\n\n/**\n * Safely but conveniently build a URLSearchParams instance from a given\n * dictionary of values. For example:\n *\n *   {\n *     \"foo\": \"bar+qux/baz\",\n *     \"empty\": \"\",\n *     \"n\": 42,\n *     \"nope\": undefined,\n *     \"alsonope\": null,\n *   }\n *\n * Will produce a value that will get serialized as\n * `foo=bar%2Bqux%2Fbaz&empty=&n=42`.\n *\n * Notice how the number is converted to its string representation\n * automatically and the `null`/`undefined` values simply don't end up in the\n * URL.\n */\nfunction toURLSearchParams(\n  params: Record<string, string | number | null | undefined>\n): URLSearchParams {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== undefined && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\n\n/**\n * Concatenates a path to an existing URL.\n */\nexport function urljoin(\n  baseUrl: string | URL,\n  path: string,\n  params?: QueryParams\n): string {\n  // First, sanitize by removing user/passwd/search/hash parts from the URL\n  const url = new URL(path, baseUrl);\n  if (params !== undefined) {\n    url.search = (\n      params instanceof URLSearchParams ? params : toURLSearchParams(params)\n    ).toString();\n  }\n  return url.toString();\n}\n\n/**\n * A string that is guaranteed to be URL safe (where all arguments are properly\n * encoded), only obtainable as the result of using `url` template strings.\n */\nexport type URLSafeString = Brand<string, \"URLSafeString\">;\n\n/**\n * Builds a URL where each \"hole\" in the template string will automatically be\n * encodeURIComponent()-escaped, so it's impossible to build invalid URLs.\n */\nexport function url(\n  strings: TemplateStringsArray,\n  ...values: string[]\n): URLSafeString {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  ) as URLSafeString;\n}\n","import type { AuthManager, AuthValue } from \"./auth-manager\";\nimport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToInboxNotificationData,\n  convertToInboxNotificationDeleteInfo,\n  convertToThreadData,\n  convertToThreadDeleteInfo,\n} from \"./convert-plain-data\";\nimport { autoRetry, HttpError } from \"./lib/autoRetry\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Batch, createBatchStore } from \"./lib/batch\";\nimport { chunk } from \"./lib/chunk\";\nimport { createCommentId, createThreadId } from \"./lib/createIds\";\nimport type { DateToString } from \"./lib/DateToString\";\nimport { DefaultMap } from \"./lib/DefaultMap\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { objectToQuery } from \"./lib/objectToQuery\";\nimport type { QueryParams, URLSafeString } from \"./lib/url\";\nimport { url, urljoin } from \"./lib/url\";\nimport { raise } from \"./lib/utils\";\nimport type { Permission } from \"./protocol/AuthToken\";\nimport type { ClientMsg } from \"./protocol/ClientMsg\";\nimport type {\n  BaseMetadata,\n  CommentAttachment,\n  CommentBody,\n  CommentData,\n  CommentDataPlain,\n  CommentLocalAttachment,\n  CommentUserReaction,\n  CommentUserReactionPlain,\n  QueryMetadata,\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./protocol/InboxNotifications\";\nimport type { IdTuple, SerializedCrdt } from \"./protocol/SerializedCrdt\";\nimport type { HistoryVersion } from \"./protocol/VersionHistory\";\nimport type { TextEditorType } from \"./types/Others\";\nimport type { Patchable } from \"./types/Patchable\";\nimport type { RoomNotificationSettings } from \"./types/RoomNotificationSettings\";\nimport { PKG_VERSION } from \"./version\";\n\nexport interface RoomHttpApi<M extends BaseMetadata> {\n  getThreads(options: {\n    roomId: string;\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }): Promise<{\n    threads: ThreadData<M>[];\n    inboxNotifications: InboxNotificationData[];\n    requestedAt: Date;\n    nextCursor: string | null;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  getThreadsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  createThread({\n    roomId,\n    metadata,\n    body,\n    commentId,\n    threadId,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<ThreadData<M>>;\n\n  getThread(options: { roomId: string; threadId: string }): Promise<{\n    thread?: ThreadData<M>;\n    inboxNotification?: InboxNotificationData;\n  }>;\n\n  deleteThread({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  editThreadMetadata({\n    roomId,\n    metadata,\n    threadId,\n  }: {\n    roomId: string;\n    metadata: Patchable<M>;\n    threadId: string;\n  }): Promise<M>;\n\n  createComment({\n    roomId,\n    threadId,\n    commentId,\n    body,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  editComment({\n    roomId,\n    threadId,\n    commentId,\n    body,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  deleteComment({\n    roomId,\n    threadId,\n    commentId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  addReaction({\n    roomId,\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<CommentUserReaction>;\n\n  removeReaction({\n    roomId,\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  markThreadAsResolved({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  markThreadAsUnresolved({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  // Notifications\n  markRoomInboxNotificationAsRead({\n    roomId,\n    inboxNotificationId,\n  }: {\n    roomId: string;\n    inboxNotificationId: string;\n  }): Promise<string>;\n\n  getNotificationSettings({\n    roomId,\n    signal,\n  }: {\n    roomId: string;\n    signal?: AbortSignal;\n  }): Promise<RoomNotificationSettings>;\n\n  updateNotificationSettings({\n    roomId,\n    settings,\n  }: {\n    roomId: string;\n    settings: Partial<RoomNotificationSettings>;\n  }): Promise<RoomNotificationSettings>;\n\n  // Attachments\n  getAttachmentUrl(options: {\n    roomId: string;\n    attachmentId: string;\n  }): Promise<string>;\n\n  uploadAttachment({\n    roomId,\n    attachment,\n    signal,\n  }: {\n    roomId: string;\n    attachment: CommentLocalAttachment;\n    signal?: AbortSignal;\n  }): Promise<CommentAttachment>;\n\n  getOrCreateAttachmentUrlsStore(roomId: string): BatchStore<string, string>;\n\n  // Text editor\n  createTextMention({\n    roomId,\n    userId,\n    mentionId,\n  }: {\n    roomId: string;\n    userId: string;\n    mentionId: string;\n  }): Promise<void>;\n\n  deleteTextMention({\n    roomId,\n    mentionId,\n  }: {\n    roomId: string;\n    mentionId: string;\n  }): Promise<void>;\n\n  getTextVersion({\n    roomId,\n    versionId,\n  }: {\n    roomId: string;\n    versionId: string;\n  }): Promise<Response>;\n\n  createTextVersion({ roomId }: { roomId: string }): Promise<void>;\n\n  reportTextEditor({\n    roomId,\n    type,\n    rootKey,\n  }: {\n    roomId: string;\n    type: TextEditorType;\n    rootKey: string;\n  }): Promise<void>;\n\n  listTextVersions({ roomId }: { roomId: string }): Promise<{\n    versions: {\n      type: \"historyVersion\";\n      kind: \"yjs\";\n      id: string;\n      authors: {\n        id: string;\n      }[];\n      createdAt: Date;\n    }[];\n    requestedAt: Date;\n  }>;\n\n  listTextVersionsSince({\n    roomId,\n    since,\n    signal,\n  }: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    versions: {\n      type: \"historyVersion\";\n      kind: \"yjs\";\n      id: string;\n      authors: {\n        id: string;\n      }[];\n      createdAt: Date;\n    }[];\n    requestedAt: Date;\n  }>;\n\n  streamStorage(options: {\n    roomId: string;\n  }): Promise<IdTuple<SerializedCrdt>[]>;\n\n  sendMessages<P extends JsonObject, E extends Json>(options: {\n    roomId: string;\n    nonce: string | undefined;\n    messages: ClientMsg<P, E>[];\n  }): Promise<Response>;\n}\n\nexport interface NotificationHttpApi<M extends BaseMetadata> {\n  getInboxNotifications(options?: { cursor?: string }): Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<M>[];\n    nextCursor: string | null;\n    requestedAt: Date;\n  }>;\n\n  getInboxNotificationsSince(options: {\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    requestedAt: Date;\n  }>;\n\n  getUnreadInboxNotificationsCount(): Promise<number>;\n\n  markAllInboxNotificationsAsRead(): Promise<void>;\n\n  markInboxNotificationAsRead(inboxNotificationId: string): Promise<void>;\n\n  deleteAllInboxNotifications(): Promise<void>;\n\n  deleteInboxNotification(inboxNotificationId: string): Promise<void>;\n}\n\nexport interface LiveblocksHttpApi<M extends BaseMetadata>\n  extends RoomHttpApi<M>,\n    NotificationHttpApi<M> {\n  getUserThreads_experimental(options?: {\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }): Promise<{\n    threads: ThreadData<M>[];\n    inboxNotifications: InboxNotificationData[];\n    nextCursor: string | null;\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  getUserThreadsSince_experimental(options: {\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n}\n\nexport function createApiClient<M extends BaseMetadata>({\n  baseUrl,\n  authManager,\n  fetchPolyfill,\n}: {\n  baseUrl: string;\n  authManager: AuthManager;\n  fetchPolyfill: typeof fetch;\n}): LiveblocksHttpApi<M> {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n\n  /* -------------------------------------------------------------------------------------------------\n   * Threads (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getThreadsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const result = await httpClient.get<{\n      data: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        since: options.since.toISOString(),\n      },\n      { signal: options.signal }\n    );\n\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints,\n    };\n  }\n\n  async function getThreads(options: {\n    roomId: string;\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }) {\n    let query: string | undefined;\n\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const PAGE_SIZE = 50;\n\n    try {\n      const result = await httpClient.get<{\n        data: ThreadDataPlain<M>[];\n        inboxNotifications: InboxNotificationDataPlain[];\n        deletedThreads: ThreadDeleteInfoPlain[];\n        deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n        meta: {\n          requestedAt: string;\n          nextCursor: string | null;\n          permissionHints: Record<string, Permission[]>;\n        };\n      }>(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId,\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE,\n        }\n      );\n\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints,\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        // If the room does (not) yet exist, the response will be a 404 error\n        // response which we'll interpret as an empty list of threads.\n        return {\n          threads: [],\n          inboxNotifications: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1000),\n          permissionHints: {},\n        };\n      }\n\n      throw err;\n    }\n  }\n\n  async function createThread(options: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n\n    const thread = await httpClient.post<ThreadDataPlain<M>>(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          attachmentIds: options.attachmentIds,\n        },\n        metadata: options.metadata,\n      }\n    );\n\n    return convertToThreadData<M>(thread);\n  }\n\n  async function deleteThread(options: { roomId: string; threadId: string }) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function getThread(options: { roomId: string; threadId: string }) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    if (response.ok) {\n      const json = (await response.json()) as {\n        thread: ThreadDataPlain<M>;\n        inboxNotification?: InboxNotificationDataPlain;\n      };\n\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification\n          ? convertToInboxNotificationData(json.inboxNotification)\n          : undefined,\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: undefined,\n        inboxNotification: undefined,\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n\n  async function editThreadMetadata(options: {\n    roomId: string;\n    metadata: Patchable<M>;\n    threadId: string;\n  }) {\n    return await httpClient.post<M>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      options.metadata\n    );\n  }\n\n  async function createComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post<CommentDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        attachmentIds: options.attachmentIds,\n      }\n    );\n    return convertToCommentData(comment);\n  }\n\n  async function editComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    const comment = await httpClient.post<CommentDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds,\n      }\n    );\n\n    return convertToCommentData(comment);\n  }\n\n  async function deleteComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function addReaction(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const reaction = await httpClient.post<CommentUserReactionPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      { emoji: options.emoji }\n    );\n\n    return convertToCommentUserReaction(reaction);\n  }\n\n  async function removeReaction(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    await httpClient.delete<CommentDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function markThreadAsResolved(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function markThreadAsUnresolved(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Attachments (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function uploadAttachment(options: {\n    roomId: string;\n    attachment: CommentLocalAttachment;\n    signal?: AbortSignal;\n  }): Promise<CommentAttachment> {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n\n    const abortError = abortSignal\n      ? new DOMException(\n          `Upload of attachment ${options.attachment.id} was aborted.`,\n          \"AbortError\"\n        )\n      : undefined;\n\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n\n    const handleRetryError = (err: Error) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n\n      return false;\n    };\n\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024; // 5 MB\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,\n    ];\n\n    function splitFileIntoParts(file: File) {\n      const parts: { partNumber: number; part: Blob }[] = [];\n\n      let start = 0;\n\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end),\n        });\n\n        start = end;\n      }\n\n      return parts;\n    }\n\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      // If the file is small enough, upload it in a single request\n      return autoRetry(\n        async () =>\n          httpClient.putBlob<CommentAttachment>(\n            url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            attachment.file,\n            { fileSize: attachment.size },\n            { signal: abortSignal }\n          ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      // Otherwise, upload it in multiple parts\n      let uploadId: string | undefined;\n      const uploadedParts: {\n        etag: string;\n        partNumber: number;\n      }[] = [];\n\n      // Create a multi-part upload\n      const createMultiPartUpload = await autoRetry(\n        async () =>\n          httpClient.post<{\n            uploadId: string;\n            key: string;\n          }>(\n            url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            undefined,\n            { signal: abortSignal },\n            { fileSize: attachment.size }\n          ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n\n        const parts = splitFileIntoParts(attachment.file);\n\n        // Check if the upload was aborted\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n\n        const batches = chunk(parts, 5);\n\n        // Batches are uploaded one after the other\n        for (const parts of batches) {\n          const uploadedPartsPromises: Promise<{\n            partNumber: number;\n            etag: string;\n          }>[] = [];\n\n          for (const { part, partNumber } of parts) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () =>\n                  httpClient.putBlob<{\n                    partNumber: number;\n                    etag: string;\n                  }>(\n                    url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                    await authManager.getAuthValue({\n                      requestedScope: \"comments:read\",\n                      roomId,\n                    }),\n                    part,\n                    undefined,\n                    { signal: abortSignal }\n                  ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n\n          // Parts are uploaded in parallel\n          uploadedParts.push(...(await Promise.all(uploadedPartsPromises)));\n        }\n\n        // Check if the upload was aborted\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n\n        return httpClient.post<CommentAttachment>(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId,\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error) {\n        if (\n          uploadId &&\n          (error as Error)?.name &&\n          ((error as Error).name === \"AbortError\" ||\n            (error as Error).name === \"TimeoutError\")\n        ) {\n          try {\n            // Abort the multi-part upload if it was created\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId,\n              })\n            );\n          } catch (error) {\n            // Ignore the error, we are probably offline\n          }\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap<\n    string,\n    BatchStore<string, string>\n  >((roomId) => {\n    const batch = new Batch<string, string>(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post<{\n          urls: (string | null)[];\n        }>(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId,\n          }),\n          { attachmentIds }\n        );\n\n        return urls.map(\n          (url) =>\n            url ??\n            new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch);\n  });\n\n  function getOrCreateAttachmentUrlsStore(\n    roomId: string\n  ): BatchStore<string, string> {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n\n  function getAttachmentUrl(options: { roomId: string; attachmentId: string }) {\n    const batch = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch.get(options.attachmentId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Notifications (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getNotificationSettings(options: {\n    roomId: string;\n    signal?: AbortSignal;\n  }): Promise<RoomNotificationSettings> {\n    return httpClient.get<RoomNotificationSettings>(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      undefined,\n      {\n        signal: options.signal,\n      }\n    );\n  }\n\n  async function updateNotificationSettings(options: {\n    roomId: string;\n    settings: Partial<RoomNotificationSettings>;\n  }): Promise<RoomNotificationSettings> {\n    return httpClient.post<RoomNotificationSettings>(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      options.settings\n    );\n  }\n\n  const markAsReadBatchesByRoom = new DefaultMap<string, Batch<string, string>>(\n    (roomId) =>\n      new Batch<string, string>(\n        async (batchedInboxNotificationIds) => {\n          const inboxNotificationIds = batchedInboxNotificationIds.flat();\n          // This method (and the following batch handling) isn't the same as the one in\n          // src/notifications.ts, this one is room-based: /v2/c/rooms/<roomId>/inbox-notifications/read.\n          //\n          // The reason for this is that unlike the room-based Comments ones, the Notifications endpoints\n          // don't work with a public key. Since `markThreadAsRead` needs to mark the related inbox notifications\n          // as read, this room-based method is necessary to keep all Comments features working with a public key.\n          await httpClient.post(\n            url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            { inboxNotificationIds }\n          );\n          return inboxNotificationIds;\n        },\n        { delay: 50 }\n      )\n  );\n\n  async function markRoomInboxNotificationAsRead(options: {\n    roomId: string;\n    inboxNotificationId: string;\n  }) {\n    const batch = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch.get(options.inboxNotificationId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Text editor (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function createTextMention(options: {\n    roomId: string;\n    userId: string;\n    mentionId: string;\n  }) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        userId: options.userId,\n        mentionId: options.mentionId,\n      }\n    );\n  }\n\n  async function deleteTextMention(options: {\n    roomId: string;\n    mentionId: string;\n  }) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function getTextVersion(options: {\n    roomId: string;\n    versionId: string;\n  }) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function createTextVersion(options: { roomId: string }) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function reportTextEditor(options: {\n    roomId: string;\n    type: TextEditorType;\n    rootKey: string;\n  }) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey,\n      }\n    );\n  }\n\n  async function listTextVersions(options: { roomId: string }) {\n    const result = await httpClient.get<{\n      versions: DateToString<HistoryVersion>[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version,\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt),\n    };\n  }\n\n  async function listTextVersionsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const result = await httpClient.get<{\n      versions: DateToString<HistoryVersion>[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version,\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt),\n    };\n  }\n\n  async function streamStorage(options: { roomId: string }) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId,\n      })\n    );\n    return (await result.json()) as IdTuple<SerializedCrdt>[];\n  }\n\n  async function sendMessages<P extends JsonObject, E extends Json>(options: {\n    roomId: string;\n    nonce: string | undefined;\n    messages: ClientMsg<P, E>[];\n  }) {\n    return httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/send-message`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId,\n      }),\n      {\n        nonce: options.nonce,\n        messages: options.messages,\n      }\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Inbox notifications (User-level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getInboxNotifications(options?: { cursor?: string }) {\n    const PAGE_SIZE = 50;\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      meta: {\n        requestedAt: string;\n        nextCursor: string | null;\n      };\n    }>(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE,\n      }\n    );\n\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n    };\n  }\n\n  async function getInboxNotificationsSince(options: {\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n    };\n  }\n\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get<{ count: number }>(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n    return count;\n  }\n\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\",\n      }\n    );\n  }\n\n  async function markInboxNotificationsAsRead(inboxNotificationIds: string[]) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds,\n      }\n    );\n  }\n\n  const batchedMarkInboxNotificationsAsRead = new Batch<string, string>(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n\n  async function deleteInboxNotification(inboxNotificationId: string) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n\n  async function getUserThreads_experimental(options?: {\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }) {\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const PAGE_SIZE = 50;\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        nextCursor: string | null;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE,\n      }\n    );\n\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints,\n    };\n  }\n\n  async function getUserThreadsSince_experimental<\n    M extends BaseMetadata,\n  >(options: { since: Date; signal?: AbortSignal }) {\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints,\n    };\n  }\n\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    // Room notifications\n    markRoomInboxNotificationAsRead,\n    updateNotificationSettings,\n    getNotificationSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // Room storage\n    streamStorage,\n    sendMessages,\n    // Notification\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n  };\n}\n\nexport function getBearerTokenFromAuthValue(authValue: AuthValue): string {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\n\n/**\n * @internal\n *\n * Small HTTP client for client-only REST API requests (e.g. /v2/c/* URLs).\n * These URLs all use public key, ID token, or access token authorization. This\n * HTTP client can be shared and used by both the Liveblocks Client and\n * Liveblocks Room instances internally to talk to our client-only REST API\n * backend.\n */\nclass HttpClient {\n  #baseUrl: string;\n  #fetchPolyfill: typeof fetch;\n\n  constructor(baseUrl: string, fetchPolyfill: typeof fetch) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:    👈 This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<Response> {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n\n    const url = urljoin(this.#baseUrl, endpoint, params);\n    return await this.#fetchPolyfill(url, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n\n        // Possible header overrides\n        ...options?.headers,\n\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\",\n      },\n    });\n  }\n\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:   👈 This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails (🤔)\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<T> {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n\n    let body;\n    try {\n      body = (await response.json()) as T;\n    } catch {\n      // TODO This looks wrong 🤔 !\n      // TODO Should we not be throwing this error if something fails to parse?\n      body = {} as T;\n    }\n    return body;\n  }\n\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  public async rawGet(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  public async rawPost(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    body?: JsonObject\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n    });\n  }\n\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  public async rawDelete(\n    endpoint: URLSafeString,\n    authValue: AuthValue\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async get<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<T> {\n    return await this.#fetch<T>(endpoint, authValue, options, params);\n  }\n\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async post<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    body?: JsonObject,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">,\n    params?: QueryParams\n  ): Promise<T> {\n    return await this.#fetch<T>(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: JSON.stringify(body),\n      },\n      params\n    );\n  }\n\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async delete<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue\n  ): Promise<T> {\n    return await this.#fetch<T>(endpoint, authValue, { method: \"DELETE\" });\n  }\n\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async putBlob<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    blob?: Blob,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<T> {\n    return await this.#fetch<T>(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\",\n        },\n        body: blob,\n      },\n      params\n    );\n  }\n}\n","/**\n * Helper function that can be used to implement exhaustive switch statements\n * with TypeScript. Example usage:\n *\n *    type Fruit = \"🍎\" | \"🍌\";\n *\n *    switch (fruit) {\n *      case \"🍎\":\n *      case \"🍌\":\n *        return doSomething();\n *\n *      default:\n *        return assertNever(fruit, \"Unknown fruit\");\n *    }\n *\n * If now the Fruit union is extended (i.e. add \"🍒\"), TypeScript will catch\n * this *statically*, rather than at runtime, and force you to handle the\n * 🍒 case.\n */\n// istanbul ignore next\nexport function assertNever(_value: never, errmsg: string): never {\n  throw new Error(errmsg);\n}\n\n/**\n * Asserts that a certain condition holds. If it does not hold, will throw\n * a runtime error in dev mode.\n *\n * In production, nothing is asserted and this acts as a no-op.\n */\nexport function assert(condition: boolean, errmsg: string): asserts condition {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\n\n/**\n * Asserts that a given value is non-nullable. This is similar to TypeScript's\n * `!` operator, but will throw an error at runtime (dev-mode only) indicating\n * an incorrect assumption.\n *\n * Instead of:\n *\n *     foo!.bar\n *\n * Use:\n *\n *     nn(foo).bar\n *\n */\nexport function nn<T>(\n  value: T,\n  errmsg: string = \"Expected value to be non-nullable\"\n): NonNullable<T> {\n  assert(value !== null && value !== undefined, errmsg);\n  return value as NonNullable<T>;\n}\n","/**\n * A generic Finite State Machine (FSM) implementation.\n *\n * This is a generic implementation that is not Liveblocks specific. We could\n * put this in a separate NPM package if we wanted to make this more reusable.\n */\n\nimport type { EventSource, Observable } from \"./EventSource\";\nimport { makeEventSource } from \"./EventSource\";\n\n/**\n * Built-in event sent by .addTimedTransition().\n */\nexport type TimerEvent = { readonly type: \"TIMER\" };\n\n/**\n * Built-in events sent by .onEnterAsync().\n */\nexport type AsyncOKEvent<T> = {\n  readonly type: \"ASYNC_OK\";\n  readonly data: T;\n};\nexport type AsyncErrorEvent = {\n  readonly type: \"ASYNC_ERROR\";\n  readonly reason: unknown;\n};\n\nexport type BaseEvent = { readonly type: string };\nexport type BuiltinEvent = TimerEvent | AsyncOKEvent<unknown> | AsyncErrorEvent;\n\nexport type Patchable<TContext> = Readonly<TContext> & {\n  patch(patch: Partial<TContext>): void;\n};\n\nexport type CleanupFn<TContext> = (context: Patchable<TContext>) => void;\nexport type EnterFn<TContext> = (\n  context: Patchable<TContext>\n) => void | CleanupFn<TContext>;\n\nexport type TargetFn<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = (\n  event: TEvent,\n  context: Readonly<TContext>\n) => TState | TargetObject<TContext, TEvent, TState> | null;\n\nexport type Effect<TContext, TEvent extends BaseEvent> = (\n  context: Patchable<TContext>,\n  event: TEvent\n) => void;\n\n/**\n * \"Expanded\" object form to specify a target state with.\n */\nexport type TargetObject<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = {\n  target: TState;\n\n  /**\n   * Emit a side effect (other than assigning to the context) when this\n   * transition is taken.\n   */\n  effect: Effect<TContext, TEvent> | Effect<TContext, TEvent>[];\n};\n\nexport type Target<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> =\n  | TState // Static, e.g. 'complete'\n  | TargetObject<TContext, TEvent, TState>\n  | TargetFn<TContext, TEvent, TState>; // Dynamic, e.g. (context) => context.x ? 'complete' : 'other'\n\ntype Groups<T extends string> = T extends `${infer G}.${infer Rest}`\n  ? G | `${G}.${Groups<Rest>}`\n  : never;\nexport type Wildcard<T extends string> = \"*\" | `${Groups<T>}.*`;\n\nfunction distance(state1: string, state2: string): [number, number] {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\n\nfunction patterns<TState extends string>(\n  targetState: TState,\n  levels: number\n): (Wildcard<TState> | TState)[] {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n\n  const result: (Wildcard<TState> | TState)[] = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push((slice.join(\".\") + \".*\") as Wildcard<TState>);\n    }\n  }\n\n  result.push(targetState);\n\n  return result;\n}\n\nclass SafeContext<TContext extends object> {\n  #curr: Readonly<TContext>;\n\n  constructor(initialContext: TContext) {\n    this.#curr = initialContext;\n  }\n\n  get current(): Readonly<TContext> {\n    return this.#curr;\n  }\n\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback: (context: Patchable<TContext>) => void): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    let allowed = true;\n\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch: Partial<TContext>): void {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n\n          // Also patch the temporary mutable context helper itself, in case\n          // there are multiple calls in a succession that need\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair as [\n              keyof TContext,\n              TContext[keyof TContext],\n            ];\n            if (key !== \"patch\") {\n              (this as TContext)[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      },\n    };\n    callback(patchableContext);\n\n    // If ever the patch function is called after this temporary window,\n    // disallow it\n    allowed = false;\n    return;\n  }\n}\n\nenum RunningState {\n  NOT_STARTED_YET, // Machine can be set up during this phase\n  STARTED,\n  STOPPED,\n}\n\nlet nextId = 1;\n\nexport class FSM<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> {\n  public id: number;\n\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState: RunningState;\n\n  readonly #currentContext: SafeContext<TContext>;\n\n  #states: Set<TState>;\n  #currentStateOrNull: TState | null;\n\n  #allowedTransitions: Map<\n    TState,\n    Map<TEvent[\"type\"], TargetFn<TContext, TEvent, TState>>\n  >;\n\n  readonly #eventHub: {\n    readonly didReceiveEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willTransition: EventSource<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willExitState: EventSource<TState>;\n    readonly didEnterState: EventSource<TState>;\n  };\n\n  public readonly events: {\n    readonly didReceiveEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willTransition: Observable<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willExitState: Observable<TState>;\n    readonly didEnterState: Observable<TState>;\n  };\n\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack: (CleanupFn<TContext> | null)[];\n\n  #enterFns: Map<TState | Wildcard<TState>, EnterFn<TContext>>;\n\n  // Used to provide better error messages\n  #knownEventTypes: Set<string>;\n\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState(): TState {\n    // Return the first state ever defined as the initial state\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n\n  public get currentState(): TState {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === RunningState.NOT_STARTED_YET) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  public start(): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"State machine has already started\");\n    }\n\n    this.#runningState = RunningState.STARTED;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  public stop(): void {\n    if (this.#runningState !== RunningState.STARTED) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = RunningState.STOPPED;\n    this.#currentStateOrNull = null;\n  }\n\n  constructor(initialContext: Readonly<TContext>) {\n    this.id = nextId++;\n    this.#runningState = RunningState.NOT_STARTED_YET;\n    this.#currentStateOrNull = null;\n    this.#states = new Set();\n    this.#enterFns = new Map();\n    this.#cleanupStack = [];\n    this.#knownEventTypes = new Set();\n    this.#allowedTransitions = new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource(),\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable,\n    };\n  }\n\n  public get context(): Readonly<TContext> {\n    return this.#currentContext.current;\n  }\n\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  public addState(state: TState): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n\n  public onEnter(\n    nameOrPattern: TState | Wildcard<TState>,\n    enterFn: EnterFn<TContext>\n  ): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  public onEnterAsync<T>(\n    nameOrPattern: TState | Wildcard<TState>,\n    promiseFn: (context: Readonly<TContext>, signal: AbortSignal) => Promise<T>,\n    onOK: Target<TContext, AsyncOKEvent<T>, TState>,\n    onError: Target<TContext, AsyncErrorEvent, TState>,\n    maxTimeout?: number\n  ): this {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      const timeoutId = maxTimeout\n        ? setTimeout(() => {\n            const reason = new Error(\"Timed out\");\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }, maxTimeout)\n        : undefined;\n\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data: T) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n\n        // On Error\n        (reason: unknown) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n\n  #getStatesMatching(nameOrPattern: TState | Wildcard<TState>): TState[] {\n    const matches: TState[] = [];\n\n    // We're trying to match a group pattern here, i.e. `foo.*` (which might\n    // match `foo.bar` and `foo.qux` states)\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1); // Strip only the \"*\", keep the \".\"\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      // Just a single, explicit state name\n      const name = nameOrPattern as TState;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n\n    return matches;\n  }\n\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  public addTransitions(\n    nameOrPattern: TState | Wildcard<TState>,\n    mapping: {\n      [E in TEvent as E[\"type\"]]?: Target<TContext, E, TState> | null;\n    }\n  ): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === undefined) {\n        map = new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n\n        const target = target_ as\n          | Target<TContext, TEvent, TState>\n          | null\n          | undefined;\n        this.#knownEventTypes.add(type);\n\n        if (target !== undefined) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  public addTimedTransition(\n    stateOrPattern: TState | Wildcard<TState>,\n    after: number | ((context: Readonly<TContext>) => number),\n    target: Target<TContext, TimerEvent, TState>\n  ): this {\n    return this.onEnter(stateOrPattern, () => {\n      const ms =\n        typeof after === \"function\"\n          ? after(this.#currentContext.current)\n          : after;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n\n  #getTargetFn(\n    eventName: TEvent[\"type\"]\n  ): TargetFn<TContext, TEvent, TState> | undefined {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels: number | null) {\n    this.#eventHub.willExitState.notify(this.currentState);\n\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels: number | null) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n      }\n    });\n\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  public send(event: TEvent): void {\n    // Throw if the event is unknown, which may likely be a configuration error\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n\n    if (this.#runningState === RunningState.STOPPED) {\n      // Ignore all events sent to the machine after it has stopped. This is\n      // similar to how we ignore events sent to the machine after it\n      // transitioned to a phase in which the event won't be handled: it would\n      // also get ignored.\n      // However, if the machine _hasn't started yet_, we still let it throw an\n      // error, because then it's most likely a usage error.\n      return;\n    }\n\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== undefined) {\n      return this.#transition(event, targetFn);\n    } else {\n      // Ignore the event otherwise\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n\n  #transition<E extends TEvent | BuiltinEvent>(\n    event: E,\n    target: Target<TContext, E, TState>\n  ) {\n    this.#eventHub.didReceiveEvent.notify(event);\n\n    const oldState = this.currentState;\n\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState: TState;\n    let effects: Effect<TContext, E>[] | undefined = undefined;\n    if (nextTarget === null) {\n      // Do not transition\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect)\n        ? nextTarget.effect\n        : [nextTarget.effect];\n    }\n\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n\n    this.#currentStateOrNull = nextState; // NOTE: Could stay the same, but... there could be an action to execute here\n    if (effects !== undefined) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            // May mutate context\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n}\n\n/** @internal - For unit tests only */\nexport { distance, patterns };\n","import type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"./BaseUserMeta\";\nimport type { Op } from \"./Op\";\nimport type { IdTuple, SerializedCrdt } from \"./SerializedCrdt\";\n\nexport enum ServerMsgCode {\n  // For Presence\n  UPDATE_PRESENCE = 100,\n  USER_JOINED = 101,\n  USER_LEFT = 102,\n  BROADCASTED_EVENT = 103,\n  ROOM_STATE = 104,\n\n  // For Storage\n  INITIAL_STORAGE_STATE = 200,\n  UPDATE_STORAGE = 201,\n  REJECT_STORAGE_OP = 299,\n\n  // For Yjs Docs\n  UPDATE_YDOC = 300,\n\n  // For Comments\n  THREAD_CREATED = 400,\n  THREAD_DELETED = 407,\n  THREAD_METADATA_UPDATED = 401,\n  THREAD_UPDATED = 408,\n  COMMENT_CREATED = 402,\n  COMMENT_EDITED = 403,\n  COMMENT_DELETED = 404,\n  COMMENT_REACTION_ADDED = 405,\n  COMMENT_REACTION_REMOVED = 406,\n}\n\n/**\n * Messages that can be sent from the server to the client.\n */\nexport type ServerMsg<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> =\n  // For Presence\n  | UpdatePresenceServerMsg<P> // Broadcasted\n  | UserJoinServerMsg<U> // Broadcasted\n  | UserLeftServerMsg // Broadcasted\n  | BroadcastedEventServerMsg<E> // Broadcasted\n  | RoomStateServerMsg<U> // For a single client\n\n  // For Storage\n  | InitialDocumentStateServerMsg // For a single client\n  | UpdateStorageServerMsg // Broadcasted\n  | RejectedStorageOpServerMsg // For a single client\n  | YDocUpdateServerMsg // For receiving doc from backend\n\n  // Comments\n  | CommentsEventServerMsg;\n\nexport type CommentsEventServerMsg =\n  | ThreadCreatedEvent\n  | ThreadDeletedEvent\n  | ThreadMetadataUpdatedEvent\n  | ThreadUpdatedEvent\n  | CommentCreatedEvent\n  | CommentEditedEvent\n  | CommentDeletedEvent\n  | CommentReactionAdded\n  | CommentReactionRemoved;\n\ntype ThreadCreatedEvent = {\n  type: ServerMsgCode.THREAD_CREATED;\n  threadId: string;\n};\n\ntype ThreadDeletedEvent = {\n  type: ServerMsgCode.THREAD_DELETED;\n  threadId: string;\n};\n\ntype ThreadMetadataUpdatedEvent = {\n  type: ServerMsgCode.THREAD_METADATA_UPDATED;\n  threadId: string;\n};\n\ntype ThreadUpdatedEvent = {\n  type: ServerMsgCode.THREAD_UPDATED;\n  threadId: string;\n};\n\ntype CommentCreatedEvent = {\n  type: ServerMsgCode.COMMENT_CREATED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentEditedEvent = {\n  type: ServerMsgCode.COMMENT_EDITED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentDeletedEvent = {\n  type: ServerMsgCode.COMMENT_DELETED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentReactionAdded = {\n  type: ServerMsgCode.COMMENT_REACTION_ADDED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\ntype CommentReactionRemoved = {\n  type: ServerMsgCode.COMMENT_REACTION_REMOVED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User updated their presence. For example, when a user moves their cursor.\n *\n * In most cases, the data payload will only include the fields from the\n * Presence that have been changed since the last announcement. However, after\n * a new user joins a room, a \"full presence\" will be announced so the newly\n * connected user will get each other's user full presence at least once. In\n * those cases, the `targetActor` field indicates the newly connected client,\n * so all other existing clients can ignore this broadcasted message.\n */\nexport type UpdatePresenceServerMsg<P extends JsonObject> =\n  //\n  // Full Presence™ message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * When set, signifies that this is a Full Presence™ update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      /**\n       * The partial or full Presence of a User. If the `targetActor` field is set,\n       * this will be the full Presence, otherwise it only contain the fields that\n       * have changed since the last broadcast.\n       */\n      readonly data: P;\n    }\n\n  //\n  // Partial Presence™ message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * Not set for partial presence updates.\n       */\n      readonly targetActor?: undefined;\n      /**\n       * A partial Presence patch to apply to the User. It will only contain the\n       * fields that have changed since the last broadcast.\n       */\n      readonly data: Partial<P>;\n    };\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has joined the Room.\n */\nexport type UserJoinServerMsg<U extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.USER_JOINED;\n  readonly actor: number;\n  /**\n   * The id of the User that has been set in the authentication endpoint.\n   * Useful to get additional information about the connected user.\n   */\n  readonly id: U[\"id\"];\n  /**\n   * Additional user information that has been set in the authentication\n   * endpoint.\n   */\n  readonly info: U[\"info\"];\n  /**\n   * Informs the client what (public) permissions this (other) User has.\n   */\n  readonly scopes: string[];\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has left the Room.\n */\nexport type UserLeftServerMsg = {\n  readonly type: ServerMsgCode.USER_LEFT;\n  readonly actor: number;\n};\n\n/**\n * Sent by the WebSocket server when the ydoc is updated or when requested based on stateVector passed.\n * Contains a base64 encoded update\n */\nexport type YDocUpdateServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_YDOC;\n  readonly update: string;\n  readonly isSync: boolean; // dropped after 1.2, we use presence of stateVector instead\n  readonly stateVector: string | null; // server's state vector, sent in response to fetch\n  readonly guid?: string; // an optional guid to identify which subdoc this update to\n  readonly v2?: boolean; // whether this is a v2 update\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User broadcasted an Event to everyone in the Room.\n */\nexport type BroadcastedEventServerMsg<E extends Json> = {\n  readonly type: ServerMsgCode.BROADCASTED_EVENT;\n  /**\n   * The User who broadcast the Event. Absent when this event is broadcast from\n   * the REST API in the backend.\n   */\n  readonly actor: number;\n  /**\n   * The arbitrary payload of the Event. This can be any JSON value. Clients\n   * will have to manually verify/decode this event.\n   */\n  readonly event: E;\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * joining the Room, to provide the initial state of the Room. The payload\n * includes a list of all other Users that already are in the Room.\n */\nexport type RoomStateServerMsg<U extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.ROOM_STATE;\n\n  /**\n   * Informs the client what their actor ID is going to be.\n   * @since v1.2 (WS API v7)\n   */\n  readonly actor: number;\n\n  /**\n   * Secure nonce for the current session.\n   * @since v1.2 (WS API v7)\n   */\n  readonly nonce: string;\n\n  /**\n   * Informs the client what permissions the current User (self) has.\n   * @since v1.2 (WS API v7)\n   */\n  readonly scopes: string[];\n\n  readonly users: {\n    readonly [otherActor: number]: U & { scopes: string[] };\n  };\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * joining the Room, to provide the initial Storage state of the Room. The\n * payload includes the entire Storage document.\n */\nexport type InitialDocumentStateServerMsg = {\n  readonly type: ServerMsgCode.INITIAL_STORAGE_STATE;\n  readonly items: IdTuple<SerializedCrdt>[];\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a change occurred in the Storage document.\n *\n * The payload of this message contains a list of Ops (aka incremental\n * mutations to make to the initially loaded document).\n */\nexport type UpdateStorageServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_STORAGE;\n  readonly ops: Op[];\n};\n\n/**\n * Sent by the WebSocket server to the client to indicate that certain opIds\n * have been received but were rejected because they caused mutations that are\n * incompatible with the Room's schema.\n */\nexport type RejectedStorageOpServerMsg = {\n  readonly type: ServerMsgCode.REJECT_STORAGE_OP;\n  readonly opIds: string[];\n  readonly reason: string;\n};\n","export interface IWebSocketEvent {\n  type: string;\n}\n\nexport interface IWebSocketCloseEvent extends IWebSocketEvent {\n  readonly code: WebsocketCloseCodes;\n  readonly wasClean: boolean;\n  readonly reason: string;\n}\n\nexport interface IWebSocketMessageEvent extends IWebSocketEvent {\n  readonly data: string | Buffer | ArrayBuffer | readonly Buffer[];\n}\n\nexport interface IWebSocketInstance {\n  readonly CONNECTING: number; // 0\n  readonly OPEN: number; // 1\n  readonly CLOSING: number; // 2\n  readonly CLOSED: number; // 3\n\n  readonly readyState: number;\n\n  addEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  removeEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  close(): void;\n  send(data: string): void;\n}\n\n/**\n * Either the browser-based WebSocket API or Node.js' WebSocket API (from the\n * 'ws' package).\n *\n * This type defines the minimal WebSocket API that Liveblocks needs from\n * a WebSocket implementation, and is a minimal subset of the browser-based\n * WebSocket APIs and Node.js' WebSocket API so that both implementations are\n * assignable to this type.\n */\nexport interface IWebSocket {\n  new (address: string): IWebSocketInstance;\n}\n\n/**\n * The following ranges will be respected by the client:\n *\n *   10xx: client will reauthorize (just like 41xx)\n *   40xx: client will disconnect\n *   41xx: client will reauthorize\n *   42xx: client will retry without reauthorizing (currently not used)\n *\n */\nexport enum WebsocketCloseCodes {\n  /** Normal close of connection, the connection fulfilled its purpose. */\n  CLOSE_NORMAL = 1000,\n  /** Unexpected error happened with the network/infra level. In spirit akin to HTTP 503 */\n  CLOSE_ABNORMAL = 1006,\n  /** Unexpected error happened. In spirit akin to HTTP 500 */\n  UNEXPECTED_CONDITION = 1011,\n  /** Please back off for now, but try again in a few moments */\n  TRY_AGAIN_LATER = 1013,\n  /** Message wasn't understood, disconnect */\n  INVALID_MESSAGE_FORMAT = 4000,\n  /** Server refused to allow connection. Re-authorizing won't help. Disconnect. In spirit akin to HTTP 403 */\n  NOT_ALLOWED = 4001,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002,\n  /** Unused */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004,\n  /** Room is full, disconnect */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005,\n  /** The room's ID was updated, disconnect */\n  ROOM_ID_UPDATED = 4006,\n  /** The server kicked the connection from the room. */\n  KICKED = 4100,\n  /** The auth token is expired, reauthorize to get a fresh one. In spirit akin to HTTP 401 */\n  TOKEN_EXPIRED = 4109,\n  /** Disconnect immediately */\n  CLOSE_WITHOUT_RETRY = 4999,\n}\n\nexport function shouldDisconnect(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.CLOSE_WITHOUT_RETRY ||\n    ((code as number) >= 4000 && (code as number) < 4100)\n  );\n}\n\nexport function shouldReauth(code: WebsocketCloseCodes): boolean {\n  return (code as number) >= 4100 && (code as number) < 4200;\n}\n\nexport function shouldRetryWithoutReauth(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.TRY_AGAIN_LATER ||\n    ((code as number) >= 4200 && (code as number) < 4300)\n  );\n}\n","import { assertNever } from \"./lib/assert\";\nimport { controlledPromise } from \"./lib/controlledPromise\";\nimport type { Observable } from \"./lib/EventSource\";\nimport { makeBufferableEventSource, makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { BuiltinEvent, Patchable, Target } from \"./lib/fsm\";\nimport { FSM } from \"./lib/fsm\";\nimport type { Json } from \"./lib/Json\";\nimport { tryParseJson, withTimeout } from \"./lib/utils\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type {\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport {\n  shouldDisconnect,\n  shouldReauth,\n  shouldRetryWithoutReauth,\n  WebsocketCloseCodes,\n} from \"./types/IWebSocket\";\n\n/**\n * Returns a human-readable status indicating the current connection status of\n * a Room, as returned by `room.getStatus()`. Can be used to implement\n * a connection status badge.\n */\nexport type Status =\n  | \"initial\"\n  | \"connecting\"\n  | \"connected\"\n  | \"reconnecting\"\n  | \"disconnected\";\n\n/**\n * Whether or not the status is an \"idle\" state. Here, idle means that nothing\n * will happen until some action is taken. Unsurprisingly, these statuses match\n * the start and end states of the state machine.\n */\nexport function isIdle(status: Status): status is \"initial\" | \"disconnected\" {\n  return status === \"initial\" || status === \"disconnected\";\n}\n\n/**\n * Used to report about app-level reconnection issues.\n *\n * Normal (quick) reconnects won't be reported as a \"lost connection\". Instead,\n * the application will only get an event if the reconnection attempts by the\n * client are taking (much) longer than usual. Definitely a situation you want\n * to inform your users about, for example, by throwing a toast message on\n * screen, or show a \"trying to reconnect\" banner.\n */\nexport type LostConnectionEvent =\n  | \"lost\" // the client is trying to reconnect to Liveblocks, but it's taking (much) longer than usual\n  | \"restored\" // the client did reconnect after all\n  | \"failed\"; // the client was told to stop trying\n\n/**\n * Maps internal machine state to the public Status API.\n */\nfunction toNewConnectionStatus(machine: FSM<Context, Event, State>): Status {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n\n    case \"@idle.initial\":\n      return \"initial\";\n\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n\n    case \"@idle.failed\":\n      return \"disconnected\";\n\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\n\n/**\n * Events that can be sent to the machine externally.\n */\ntype Event =\n  // Public events that can be called on the connection manager\n  | { type: \"CONNECT\" } // e.g. when trying to enter a room\n  | { type: \"RECONNECT\" } // e.g. user asking for an explicit reconnect of the socket\n  | { type: \"DISCONNECT\" } // e.g. leaving the room\n  | { type: \"WINDOW_GOT_FOCUS\" } // e.g. user's browser tab is refocused\n  | { type: \"NAVIGATOR_ONLINE\" } // e.g. browser gets back online\n  | { type: \"NAVIGATOR_OFFLINE\" } // e.g. browser goes offline\n\n  // Events that the connection manager will internally deal with\n  | { type: \"PONG\" }\n  | { type: \"EXPLICIT_SOCKET_ERROR\"; event: IWebSocketEvent }\n  | { type: \"EXPLICIT_SOCKET_CLOSE\"; event: IWebSocketCloseEvent }\n\n  // Only used by the E2E testing app, to simulate a pong timeout :(\n  | { type: \"PONG_TIMEOUT\" };\n\ntype State =\n  | \"@idle.initial\"\n  | \"@idle.failed\"\n  | \"@idle.zombie\"\n  | \"@auth.busy\"\n  | \"@auth.backoff\"\n  | \"@connecting.busy\"\n  | \"@connecting.backoff\"\n  | \"@ok.connected\"\n  | \"@ok.awaiting-pong\";\n\n/**\n * Arbitrary record that will be used as the authentication \"authValue\". It's the\n * value that is returned by calling the authentication delegate, and will get\n * passed to the connection factory delegate. This value will be remembered by\n * the connection manager, but its value will not be interpreted, so it can be\n * any value (except null).\n */\nexport type BaseAuthResult = NonNullable<Json>;\n\ntype Context = {\n  /**\n   * Count the number of times the machine reaches an \"@ok.*\" state. Once the\n   * machine reaches idle state again, this count is reset to 0 again.\n   *\n   * This lets us distinguish:\n   * - If successCount = 0, then it's an initial \"connecting\" state.\n   * - If successCount > 0, then it's an \"reconnecting\" state.\n   */\n  successCount: number;\n\n  /**\n   * Will be populated with the last known auth authValue.\n   */\n  authValue: BaseAuthResult | null;\n\n  /**\n   * The current active WebSocket connection to the room. If this is not null\n   * on the context, then the socket has successfully been opened.\n   */\n  socket: IWebSocketInstance | null;\n\n  /**\n   * The current retry delay when automatically retrying. Will get bumped to\n   * the next \"tier\" every time a connection attempt fails. Reset every time\n   * a connection succeeded.\n   */\n  backoffDelay: number;\n};\n\nconst BACKOFF_DELAYS = [250, 500, 1_000, 2_000, 4_000, 8_000, 10_000] as const;\n\n// Resetting the delay happens upon success. We could reset to 0, but that\n// would risk no delay, which generally isn't wise. Instead, we'll reset it to\n// the lowest safe delay minus 1 millisecond. The reason is that every time\n// a retry happens, the retry delay will first be bumped to the next \"tier\".\nconst RESET_DELAY = BACKOFF_DELAYS[0] - 1;\n\n/**\n * Used to back off from WebSocket reconnection attempts after a known\n * Liveblocks issue, like \"room full\" or a \"rate limit\" error.\n */\nconst BACKOFF_DELAYS_SLOW = [2_000, 30_000, 60_000, 300_000] as const;\n\n/**\n * The client will send a PING to the server every 30 seconds, after which it\n * must receive a PONG back within the next 2 seconds. If that doesn't happen,\n * this is interpreted as an implicit connection loss event.\n */\nconst HEARTBEAT_INTERVAL = 30_000;\nconst PONG_TIMEOUT = 2_000;\n\n/**\n * Maximum amount of time that the authentication delegate take to return an\n * auth authValue, or else we consider authentication timed out.\n */\nconst AUTH_TIMEOUT = 10_000;\n\n/**\n * Maximum amount of time that the socket connect delegate may take to return\n * an opened WebSocket connection, or else we consider the attempt timed out.\n */\nconst SOCKET_CONNECT_TIMEOUT = 10_000;\n\n/**\n * Special error class that can be thrown during authentication to stop the\n * connection manager from retrying.\n */\nexport class StopRetrying extends Error {\n  constructor(reason: string) {\n    super(reason);\n  }\n}\n\nfunction nextBackoffDelay(\n  currentDelay: number,\n  delays: readonly number[]\n): number {\n  return (\n    delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1]\n  );\n}\n\nfunction increaseBackoffDelay(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS),\n  });\n}\n\nfunction increaseBackoffDelayAggressively(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW),\n  });\n}\n\nfunction resetSuccessCount(context: Patchable<Context>) {\n  context.patch({ successCount: 0 });\n}\n\nenum LogLevel {\n  INFO,\n  WARN,\n  ERROR,\n}\n\n/**\n * Generic \"log\" effect. Use it in `effect` handlers of state transitions.\n */\nfunction log(level: LogLevel, message: string) {\n  const logger =\n    level === LogLevel.ERROR\n      ? console.error\n      : level === LogLevel.WARN\n        ? console.warn\n        : /* black hole */ () => {};\n  return () => {\n    logger(message);\n  };\n}\n\nfunction logPrematureErrorOrCloseEvent(e: IWebSocketEvent | Error) {\n  // Produce a useful log message\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx: Readonly<Context>) => {\n    if (e instanceof Error) {\n      console.warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      console.warn(\n        isCloseEvent(e)\n          ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.`\n          : `${conn} could not be established.`\n      );\n    }\n  };\n}\n\nfunction logCloseEvent(event: IWebSocketCloseEvent) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx: Readonly<Context>) => {\n    console.warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\n\nconst logPermanentClose = log(\n  LogLevel.WARN,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\n\nfunction isCloseEvent(\n  error: IWebSocketEvent | Error\n): error is IWebSocketCloseEvent {\n  return !(error instanceof Error) && error.type === \"close\";\n}\n\nexport type Delegates<T extends BaseAuthResult> = {\n  authenticate: () => Promise<T>;\n  createSocket: (authValue: T) => IWebSocketInstance;\n  canZombie: () => boolean;\n};\n\n// istanbul ignore next\nfunction enableTracing(machine: FSM<Context, Event, State>) {\n  const start = new Date().getTime();\n\n  function log(...args: unknown[]) {\n    console.warn(\n      `${((new Date().getTime() - start) / 1000).toFixed(2)} [FSM #${\n        machine.id\n      }]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(({ from, to }) =>\n      log(\"Transitioning\", from, \"→\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe((e) =>\n      log(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    ),\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\n\nfunction defineConnectivityEvents(machine: FSM<Context, Event, State>) {\n  // Emitted whenever a new WebSocket connection attempt succeeds\n  const statusDidChange = makeEventSource<Status>();\n  const didConnect = makeEventSource<void>();\n  const didDisconnect = makeEventSource<void>();\n\n  let lastStatus: Status | null = null;\n\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe,\n  };\n}\n\nconst assign = (patch: Partial<Context>) => (ctx: Patchable<Context>) =>\n  ctx.patch(patch);\n\n/**\n * A ConnectionError is a partial data structure to help build a proper\n * LiveblocksError down the line.\n */\ntype ConnectionError = { message: string; code: number };\n\nfunction createConnectionStateMachine<T extends BaseAuthResult>(\n  delegates: Delegates<T>,\n  options: {\n    enableDebugLogging: boolean;\n    /** In protocol V7, the actor will no longer be available on the token.\n     * Instead, the `actor` will be sent to the client via a ROOM_STATE message\n     * over an established WebSocket connection. If this setting is set to\n     * `true`, the state machine will only jump to \"connected\" state _after_\n     * this message has been received. If this setting is `false`, the machine\n     * won't wait for the actor to be received, and instead jump to \"connected\"\n     * as soon as the WebSocket connection is established. */\n    waitForActorId: boolean;\n  }\n) {\n  // Create observable event sources, which this machine will call into when\n  // specific events happen\n  const onMessage = makeBufferableEventSource<IWebSocketMessageEvent>();\n  onMessage.pause(); // Pause all message delivery until status is OPEN\n\n  // Emitted whenever the server deliberately closes the connection for\n  // a specific Liveblocks reason\n  const onConnectionError = makeEventSource<ConnectionError>();\n\n  function fireErrorEvent(message: string, code: number) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n\n  const initialContext: Context & { authValue: T | null } = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY,\n  };\n\n  // The `machine` is the actual finite state machine instance that will\n  // maintain the WebSocket's connection\n  const machine = new FSM<Context, Event, State>(initialContext)\n    .addState(\"@idle.initial\")\n    .addState(\"@idle.failed\")\n    .addState(\"@idle.zombie\")\n    .addState(\"@auth.busy\")\n    .addState(\"@auth.backoff\")\n    .addState(\"@connecting.busy\")\n    .addState(\"@connecting.backoff\")\n    .addState(\"@ok.connected\")\n    .addState(\"@ok.awaiting-pong\");\n\n  //\n  // Configure events that can happen from anywhere\n  //\n  // It's always possible to explicitly get a .reconnect() or .disconnect()\n  // from the user.\n  //\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount],\n    },\n\n    DISCONNECT: \"@idle.initial\",\n  });\n\n  //\n  // Configure the @idle.* states\n  //\n  machine\n    .onEnter(\"@idle.*\", resetSuccessCount)\n\n    .addTransitions(\"@idle.*\", {\n      CONNECT: (_, ctx) =>\n        // If we still have a known authValue, try to reconnect to the socket directly,\n        // otherwise, try to obtain a new authValue\n        ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\",\n    });\n\n  //\n  // Configure the @auth.* states\n  //\n  machine\n    .addTransitions(\"@auth.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@auth.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@auth.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@auth.busy\"\n    )\n\n    .onEnterAsync(\n      \"@auth.busy\",\n\n      () =>\n        withTimeout(\n          delegates.authenticate(),\n          AUTH_TIMEOUT,\n          \"Timed out during auth\"\n        ),\n\n      // On successful authentication\n      (okEvent) => ({\n        target: \"@connecting.busy\",\n        effect: assign({\n          authValue: okEvent.data,\n        }),\n      }),\n\n      // Auth failed\n      (failedEvent) => {\n        if (failedEvent.reason instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, failedEvent.reason.message),\n              fireErrorEvent(failedEvent.reason.message, -1),\n            ],\n          };\n        }\n\n        return {\n          target: \"@auth.backoff\",\n          effect: [\n            increaseBackoffDelay,\n            log(\n              LogLevel.ERROR,\n              `Authentication failed: ${\n                failedEvent.reason instanceof Error\n                  ? failedEvent.reason.message\n                  : String(failedEvent.reason)\n              }`\n            ),\n          ],\n        };\n      }\n    );\n\n  //\n  // Configure the @connecting.* states\n  //\n\n  // Function references\n  const onSocketError = (event: IWebSocketEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n\n  const onSocketClose = (event: IWebSocketCloseEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n\n  const onSocketMessage = (event: IWebSocketMessageEvent) =>\n    event.data === \"pong\"\n      ? machine.send({ type: \"PONG\" })\n      : onMessage.notify(event);\n\n  function teardownSocket(socket: IWebSocketInstance | null) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n\n  machine\n    .addTransitions(\"@connecting.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@connecting.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@connecting.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@connecting.busy\"\n    )\n\n    .onEnterAsync(\n      \"@connecting.busy\",\n\n      //\n      // Use the \"createSocket\" delegate function (provided to the\n      // ManagedSocket) to create the actual WebSocket connection instance.\n      // Then, set up all the necessary event listeners, and wait for the\n      // \"open\" event to occur.\n      //\n      // When the \"open\" event happens, we're ready to transition to the\n      // OK state. This is done by resolving the Promise.\n      //\n      async (ctx, signal) => {\n        let capturedPrematureEvent: IWebSocketEvent | null = null;\n        let unconfirmedSocket: IWebSocketInstance | null = null;\n\n        const connect$ = new Promise<[IWebSocketInstance, () => void]>(\n          (resolve, rej) => {\n            // istanbul ignore next\n            if (ctx.authValue === null) {\n              throw new Error(\"No auth authValue\"); // This should never happen\n            }\n\n            const socket = delegates.createSocket(ctx.authValue as T);\n            unconfirmedSocket = socket;\n\n            function reject(event: IWebSocketEvent) {\n              capturedPrematureEvent = event;\n              socket.removeEventListener(\"message\", onSocketMessage);\n              rej(event);\n            }\n\n            const [actor$, didReceiveActor] = controlledPromise<void>();\n            if (!options.waitForActorId) {\n              // Mark the promise as \"resolved\" immediately, so we won't wait\n              // for a ROOM_STATE message to happen.\n              didReceiveActor();\n            }\n\n            /** Waits until actor is received (from the ROOM_STATE message) */\n            function waitForActorId(event: IWebSocketMessageEvent) {\n              const serverMsg = tryParseJson(event.data as string) as\n                | Record<string, Json>\n                | undefined;\n              if (serverMsg?.type === ServerMsgCode.ROOM_STATE) {\n                didReceiveActor();\n              }\n            }\n\n            //\n            // Part 1:\n            // The `error` and `close` event handlers marked (*) are installed\n            // here only temporarily, just to handle this promise-based state.\n            // When those get triggered, we reject this promise.\n            //\n            socket.addEventListener(\"message\", onSocketMessage);\n            if (options.waitForActorId) {\n              socket.addEventListener(\"message\", waitForActorId);\n            }\n            socket.addEventListener(\"error\", reject); // (*)\n            socket.addEventListener(\"close\", reject); // (*)\n            socket.addEventListener(\"open\", () => {\n              //\n              // Part 2:\n              // The \"open\" event just fired, so the server accepted our\n              // attempt to connect. We'll go on and resolve() our promise as\n              // a result.\n              //\n              // However, we cannot safely remove our error/close rejection\n              // handlers _just yet_. There is a small, unlikely-but-possible\n              // edge case: if (and only if) any close/error events are\n              // _already_ queued up in the event queue before this handler is\n              // invoked, then those will fire before our promise will be\n              // resolved.\n              //\n              // Scenario:\n              // - Event queue is empty, listeners are installed\n              // - Two events synchronously get scheduled in the event queue: [<open event>, <close event>]\n              // - The open handler is invoked (= this very callback)\n              // - Event queue now looks like: [<close event>]\n              // - We happily continue and resolve the promise\n              // - Event queue now looks like: [<close event>, <our resolved promise>]\n              // - Close event handler fires, but we already resolved promise! 😣\n              //\n              // This is what's called a \"premature\" event here, we'll deal\n              // with it in part 3.\n              //\n              socket.addEventListener(\"error\", onSocketError);\n              socket.addEventListener(\"close\", onSocketClose);\n              const unsub = () => {\n                socket.removeEventListener(\"error\", reject); // Remove (*)\n                socket.removeEventListener(\"close\", reject); // Remove (*)\n                socket.removeEventListener(\"message\", waitForActorId);\n              };\n\n              // Resolve the promise only once we received the actor ID from\n              // the server. This will act like a traffic light, going green\n              // only once the actor is received. If the machine is configured\n              // not to wait for the actor, the traffic light will already be\n              // green.\n              // All messages received in the mean time while waiting for the\n              // green light will be played back to the client after the\n              // transition to \"connected\".\n              void actor$.then(() => {\n                resolve([socket, unsub]);\n              });\n            });\n          }\n        );\n\n        return withTimeout(\n          connect$,\n          SOCKET_CONNECT_TIMEOUT,\n          \"Timed out during websocket connection\"\n        )\n          .then(\n            //\n            // Part 3:\n            // By now, our \"open\" event has fired, and the promise has been\n            // resolved. Two possible scenarios:\n            //\n            // 1. The happy path. Most likely.\n            // 2. Uh-oh. A premature close/error event has been observed. Let's\n            //    reject the promise after all.\n            //\n            // Any close/error event that will get scheduled after this point\n            // onwards, will be caught in the OK state, and dealt with\n            // accordingly.\n            //\n            ([socket, unsub]) => {\n              unsub();\n\n              if (signal.aborted) {\n                // Trigger cleanup logic in .catch() below. At this point, the\n                // promise is already cancelled, so none of the ok/err\n                // transitions will take place.\n                throw new Error(\"Aborted\");\n              }\n\n              if (capturedPrematureEvent) {\n                throw capturedPrematureEvent; // Take failure transition\n              }\n\n              return socket;\n            }\n          )\n          .catch((e) => {\n            teardownSocket(unconfirmedSocket);\n            throw e;\n          });\n      },\n\n      // Only transition to OK state after a successfully opened WebSocket connection\n      (okEvent) => ({\n        target: \"@ok.connected\",\n        effect: assign({\n          socket: okEvent.data,\n          backoffDelay: RESET_DELAY,\n        }),\n      }),\n\n      // If the WebSocket connection cannot be established\n      (failure) => {\n        const err = failure.reason as IWebSocketEvent | StopRetrying | Error;\n\n        // Stop retrying if this promise explicitly tells us so. This should,\n        // in the case of a WebSocket connection attempt only be the case if\n        // there is a configuration error.\n        if (err instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, err.message),\n              fireErrorEvent(err.message, -1),\n            ],\n          };\n        }\n\n        // If the server actively refuses the connection attempt, stop trying.\n        if (isCloseEvent(err)) {\n          // The default fall-through behavior is going to be reauthorizing\n          // with a back-off strategy. If we know the token was expired however\n          // we can reauthorize immediately (without back-off).\n          if (err.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            return \"@auth.busy\";\n          }\n\n          if (shouldRetryWithoutReauth(err.code)) {\n            // Retry after backoff, but don't get a new token\n            return {\n              target: \"@connecting.backoff\",\n              effect: [\n                increaseBackoffDelayAggressively,\n                logPrematureErrorOrCloseEvent(err),\n              ],\n            };\n          }\n\n          // If the token was not allowed we can stop trying because getting\n          // another token for the same user won't help\n          if (shouldDisconnect(err.code)) {\n            return {\n              target: \"@idle.failed\",\n              effect: [\n                log(LogLevel.ERROR, err.reason),\n                fireErrorEvent(err.reason, err.code),\n              ],\n            };\n          }\n        }\n\n        // In all other (unknown) cases, always re-authenticate (but after a back-off)\n        return {\n          target: \"@auth.backoff\",\n          effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)],\n        };\n      }\n    );\n\n  //\n  // Configure the @ok.* states\n  //\n  // Keeps a heartbeat alive with the server whenever in the @ok.* state group.\n  // 30 seconds after entering the \"@ok.connected\" state, it will emit\n  // a heartbeat, and awaits a PONG back that should arrive within 2 seconds.\n  // If this happens, then it transitions back to normal \"connected\" state, and\n  // the cycle repeats. If the PONG is not received timely, then we interpret\n  // it as an implicit connection loss, and transition to reconnect (throw away\n  // this socket, and open a new one).\n  //\n\n  const sendHeartbeat: Target<Context, Event | BuiltinEvent, State> = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    },\n  };\n\n  const maybeHeartbeat: Target<Context, Event | BuiltinEvent, State> = () => {\n    // If the browser tab isn't visible currently, ask the application if going\n    // zombie is fine\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const canZombie =\n      doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n\n  machine\n    .addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat)\n    .addTransitions(\"@ok.connected\", {\n      NAVIGATOR_OFFLINE: maybeHeartbeat, // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n      WINDOW_GOT_FOCUS: sendHeartbeat,\n    });\n\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\", // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n\n  machine\n    .onEnter(\"@ok.*\", (ctx) => {\n      ctx.patch({ successCount: ctx.successCount + 1 });\n\n      const timerID = setTimeout(\n        // On the next tick, start delivering all messages that have already\n        // been received, and continue synchronous delivery of all future\n        // incoming messages.\n        onMessage.unpause,\n        0\n      );\n\n      // ...but when *leaving* OK state, always tear down the old socket. It's\n      // no longer valid.\n      return (ctx) => {\n        teardownSocket(ctx.socket);\n        ctx.patch({ socket: null });\n        clearTimeout(timerID);\n        onMessage.pause();\n      };\n    })\n\n    .addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" })\n    .addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n      target: \"@connecting.busy\",\n      // Log implicit connection loss and drop the current open socket\n      effect: log(\n        LogLevel.WARN,\n        \"Received no pong from server, assume implicit connection loss.\"\n      ),\n    })\n\n    .addTransitions(\"@ok.*\", {\n      // When a socket receives an error, this can cause the closing of the\n      // socket, or not. So always check to see if the socket is still OPEN or\n      // not. When still OPEN, don't transition.\n      EXPLICIT_SOCKET_ERROR: (_, context) => {\n        if (context.socket?.readyState === 1 /* WebSocket.OPEN */) {\n          // TODO Do we need to forward this error to the client?\n          return null; /* Do not leave OK state, socket is still usable */\n        }\n\n        return {\n          target: \"@connecting.backoff\",\n          effect: increaseBackoffDelay,\n        };\n      },\n\n      EXPLICIT_SOCKET_CLOSE: (e) => {\n        // Server instructed us to stop retrying, so move to failed state\n        if (shouldDisconnect(e.event.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              logPermanentClose,\n              fireErrorEvent(e.event.reason, e.event.code),\n            ],\n          };\n        }\n\n        if (shouldReauth(e.event.code)) {\n          if (e.event.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            // Token expiry is a special case, we can reauthorize immediately\n            // (without back-off)\n            return \"@auth.busy\";\n          } else {\n            return {\n              target: \"@auth.backoff\",\n              effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n            };\n          }\n        }\n\n        if (shouldRetryWithoutReauth(e.event.code)) {\n          // If this is a custom Liveblocks server close reason, back off more\n          // aggressively, and emit a Liveblocks error event...\n          return {\n            target: \"@connecting.backoff\",\n            effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)],\n          };\n        }\n\n        // Consider any other close event a temporary network hiccup, and retry\n        // after a normal backoff delay\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n        };\n      },\n    });\n\n  // Lastly, register an event handler to listen for window-focus events as\n  // soon as the machine starts, and use it to send itself \"WINDOW_GOT_FOCUS\"\n  // events.\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const win = typeof window !== \"undefined\" ? window : undefined;\n    const root = win ?? doc;\n\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n\n        // Also tear down the old socket when stopping the machine, if there is one\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n\n  const cleanups = [];\n\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } =\n    defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n\n  // Install debug logging\n  // istanbul ignore next\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n\n  // Start the machine\n  machine.start();\n\n  return {\n    machine,\n    cleanups,\n\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable,\n    },\n  };\n}\n\n/**\n * The ManagedSocket will set up a WebSocket connection to a room, and maintain\n * that connection over time.\n *\n * It's a light wrapper around the actual FSM that implements the logic,\n * exposing just a few safe actions and events that can be called or observed\n * from the outside.\n */\nexport class ManagedSocket<T extends BaseAuthResult> {\n  #machine: FSM<Context, Event, State>;\n  #cleanups: (() => void)[];\n\n  public readonly events: {\n    /**\n     * Emitted when the WebSocket connection goes in or out of \"connected\"\n     * state.\n     */\n    readonly statusDidChange: Observable<Status>;\n    /**\n     * Emitted when the WebSocket connection is first opened.\n     */\n    readonly didConnect: Observable<void>;\n    /**\n     * Emitted when the current WebSocket connection is lost and the socket\n     * becomes useless. A new WebSocket connection must be made after this to\n     * restore connectivity.\n     */\n    readonly didDisconnect: Observable<void>; // Deliberate close, a connection loss, etc.\n\n    /**\n     * Emitted for every incoming message from the currently active WebSocket\n     * connection.\n     */\n    readonly onMessage: Observable<IWebSocketMessageEvent>;\n\n    /**\n     * Emitted whenever a connection gets closed for a known error reason, e.g.\n     * max number of connections, max number of messages, etc.\n     */\n    readonly onConnectionError: Observable<ConnectionError>;\n  };\n\n  constructor(\n    delegates: Delegates<T>,\n    enableDebugLogging: boolean = false,\n    waitForActorId: boolean = true\n  ) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n\n  getStatus(): Status {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue(): T | null {\n    return this.#machine.context.authValue as T | null;\n  }\n\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  public connect(): void {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  public reconnect(): void {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  public disconnect(): void {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  public destroy(): void {\n    this.#machine.stop();\n\n    let cleanup: (() => void) | undefined;\n    while ((cleanup = this.#cleanups.pop())) {\n      cleanup();\n    }\n  }\n\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  public send(data: string): void {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      console.warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1 /* WebSocket.OPEN */) {\n      console.warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  public _privateSendMachineEvent(event: Event): void {\n    this.#machine.send(event);\n  }\n}\n","import { isPlainObject } from \"../lib/guards\";\nimport type { Json } from \"../lib/Json\";\nimport { b64decode, tryParseJson } from \"../lib/utils\";\nimport type { IUserInfo } from \"./BaseUserMeta\";\n\nexport enum Permission {\n  Read = \"room:read\",\n  Write = \"room:write\",\n  PresenceWrite = \"room:presence:write\",\n  CommentsWrite = \"comments:write\",\n  CommentsRead = \"comments:read\",\n}\n\nexport type LiveblocksPermissions = Record<string, Permission[]>;\n\nexport enum TokenKind {\n  SECRET_LEGACY = \"sec-legacy\",\n  ACCESS_TOKEN = \"acc\",\n  ID_TOKEN = \"id\",\n}\n\n/**\n * Infers from the given scopes whether the user can write the document (e.g.\n * Storage and/or YDoc).\n */\nexport function canWriteStorage(scopes: readonly string[]): boolean {\n  return scopes.includes(Permission.Write);\n}\n\nexport function canComment(scopes: readonly string[]): boolean {\n  return (\n    scopes.includes(Permission.CommentsWrite) ||\n    scopes.includes(Permission.Write)\n  );\n}\n\ntype JwtMeta = {\n  iat: number;\n  exp: number;\n};\n\n/**\n * Legacy Secret Token.\n */\nexport type LegacySecretToken = {\n  k: TokenKind.SECRET_LEGACY;\n  roomId: string;\n  scopes: string[];\n\n  // Extra payload as defined by the customer's own authorization\n  id?: string;\n  info?: IUserInfo;\n\n  // IMPORTANT: All other fields on the JWT token are deliberately treated as\n  // opaque, and not relied on by the client.\n  [other: string]: Json | undefined;\n} & JwtMeta;\n\n/**\n * New authorization Access Token.\n */\nexport type AccessToken = {\n  k: TokenKind.ACCESS_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  perms: LiveblocksPermissions; // permissions\n  ui?: IUserInfo; // user info\n} & JwtMeta;\n\n/**\n * New authorization ID Token.\n */\nexport type IDToken = {\n  k: TokenKind.ID_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  gids?: string[]; // group ids\n  ui?: IUserInfo; // user info\n} & JwtMeta;\n\nexport type AuthToken = AccessToken | IDToken | LegacySecretToken;\n\n// The \"rich\" token is data we obtain by parsing the JWT token and making all\n// metadata on it accessible. It's done right after hitting the backend, but\n// before the promise will get returned, so it's an inherent part of the\n// authentication step.\nexport type ParsedAuthToken = {\n  readonly raw: string; // The raw JWT value, unchanged\n  readonly parsed: AuthToken; // Rich data on the JWT value\n};\n\nfunction isValidAuthTokenPayload(\n  data: Json\n): data is AccessToken | IDToken | LegacySecretToken {\n  return (\n    isPlainObject(data) &&\n    (data.k === TokenKind.ACCESS_TOKEN ||\n      data.k === TokenKind.ID_TOKEN ||\n      data.k === TokenKind.SECRET_LEGACY)\n  );\n}\n\n/**\n * Parses a raw JWT token string, which allows reading the metadata/payload of\n * the token.\n *\n * NOTE: Doesn't do any validation, so always treat the metadata as other user\n * input: never trust these values for anything important.\n */\nexport function parseAuthToken(rawTokenString: string): ParsedAuthToken {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n\n  return {\n    raw: rawTokenString,\n    parsed: payload,\n  };\n}\n","import { StopRetrying } from \"./connection\";\nimport { isPlainObject } from \"./lib/guards\";\nimport type { Json } from \"./lib/Json\";\nimport type { Relax } from \"./lib/Relax\";\nimport type {\n  Authentication,\n  CustomAuthenticationResult,\n} from \"./protocol/Authentication\";\nimport type { AuthToken, ParsedAuthToken } from \"./protocol/AuthToken\";\nimport { parseAuthToken, Permission, TokenKind } from \"./protocol/AuthToken\";\nimport type { Polyfills } from \"./room\";\n\nexport type AuthValue =\n  | { type: \"secret\"; token: ParsedAuthToken }\n  | { type: \"public\"; publicApiKey: string };\n\nexport type RequestedScope = \"room:read\" | \"comments:read\";\n\nexport type AuthManager = {\n  reset(): void;\n  getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue>;\n};\n\ntype AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\nexport type AuthenticationOptions = {\n  polyfills?: Polyfills;\n} & Relax<{ publicApiKey: string } | { authEndpoint: AuthEndpoint }>;\n\nexport function createAuthManager(\n  authOptions: AuthenticationOptions,\n  onAuthenticate?: (token: AuthToken) => void\n): AuthManager {\n  const authentication = prepareAuthentication(authOptions);\n\n  const seenTokens: Set<string> = new Set();\n\n  const tokens: ParsedAuthToken[] = [];\n  const expiryTimes: number[] = []; // Supposed to always contain the same number of elements as `tokens`\n\n  const requestPromises = new Map<string, Promise<ParsedAuthToken>>();\n\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n\n  function hasCorrespondingScopes(\n    requestedScope: RequestedScope,\n    scopes: Permission[]\n  ) {\n    if (requestedScope === \"comments:read\") {\n      return (\n        scopes.includes(Permission.CommentsRead) ||\n        scopes.includes(Permission.CommentsWrite) ||\n        scopes.includes(Permission.Read) ||\n        scopes.includes(Permission.Write)\n      );\n    } else if (requestedScope === \"room:read\") {\n      return (\n        scopes.includes(Permission.Read) || scopes.includes(Permission.Write)\n      );\n    }\n\n    return false;\n  }\n\n  function getCachedToken(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): ParsedAuthToken | undefined {\n    const now = Math.ceil(Date.now() / 1000);\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n\n      // If this token is expired, remove it from cache, as if it never existed\n      // in the first place\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n\n      if (token.parsed.k === TokenKind.ID_TOKEN) {\n        // When ID token method is used, only one token per user should be used and cached at the same time.\n        return token;\n      } else if (token.parsed.k === TokenKind.ACCESS_TOKEN) {\n        // In this version, we accept access tokens with zero permission when issuing token for resources outside a room.\n        if (\n          !requestOptions.roomId &&\n          Object.entries(token.parsed.perms).length === 0\n        ) {\n          return token;\n        }\n\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          // If the requester didn't pass a roomId,\n          // it means they need the token to access the user's resources (inbox notifications for example).\n          // We return any access token that contains a wildcard for the requested scope.\n          if (!requestOptions.roomId) {\n            if (\n              resource.includes(\"*\") &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes)\n            ) {\n              return token;\n            }\n          } else if (\n            (resource.includes(\"*\") &&\n              requestOptions.roomId.startsWith(resource.replace(\"*\", \"\"))) ||\n            (requestOptions.roomId === resource &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes))\n          ) {\n            return token;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  async function makeAuthRequest(options: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<ParsedAuthToken> {\n    const fetcher =\n      authOptions.polyfills?.fetch ??\n      (typeof window === \"undefined\" ? undefined : window.fetch);\n\n    if (authentication.type === \"private\") {\n      if (fetcher === undefined) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId,\n      });\n      const parsed = parseAuthToken(response.token);\n\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\n            \"reason\" in response && typeof response.reason === \"string\"\n              ? response.reason\n              : \"Forbidden\"\n          }`;\n\n          // istanbul ignore else\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n\n    // istanbul ignore next\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n\n  async function getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue> {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== undefined) {\n      return { type: \"secret\", token: cachedToken };\n    }\n\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n\n    try {\n      const token = await currentPromise;\n      // Translate \"server timestamps\" to \"local timestamps\" in case clocks aren't in sync\n      const BUFFER = 30; // Expire tokens 30 seconds sooner than they have to\n      const expiresAt =\n        Math.floor(Date.now() / 1000) +\n        (token.parsed.exp - token.parsed.iat) -\n        BUFFER;\n\n      seenTokens.add(token.raw);\n\n      // Legacy tokens should not get cached\n      if (token.parsed.k !== TokenKind.SECRET_LEGACY) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n\n  return {\n    reset,\n    getAuthValue,\n  };\n}\n\nfunction prepareAuthentication(\n  authOptions: AuthenticationOptions\n): Authentication {\n  const { publicApiKey, authEndpoint } = authOptions;\n\n  if (authEndpoint !== undefined && publicApiKey !== undefined) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey,\n    };\n  }\n\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint,\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint,\n    };\n  } else if (authEndpoint !== undefined) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\n\nasync function fetchAuthEndpoint(\n  fetch: typeof window.fetch,\n  endpoint: string,\n  body: {\n    room?: string;\n  }\n): Promise<{ token: string }> {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  });\n  if (!res.ok) {\n    const reason = `${\n      (await res.text()).trim() || \"reason not provided in auth response\"\n    } (${res.status} returned by POST ${endpoint})`;\n\n    if (res.status === 401 || res.status === 403) {\n      // Throw a special error instance, which the connection manager will\n      // recognize and understand that retrying will have no effect\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n\n  let data: Json;\n  try {\n    data = await (res.json() as Promise<Json>);\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n","export const DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n","/**\n * Use this symbol to brand an object property as internal.\n *\n * @example\n * Object.defineProperty(\n *   {\n *     public,\n *     [kInternal]: {\n *       private\n *     },\n *   },\n *   kInternal,\n *   {\n *     enumerable: false,\n *   }\n * );\n */\nexport const kInternal = Symbol();\n","import { makeEventSource } from \"../lib/EventSource\";\nimport type * as DevTools from \"./protocol\";\n\ntype SendToPanelOptions = {\n  /**\n   * We'll only want to send messages from the client to the panel if the panel\n   * has shown interest in this. To allow message passing to the dev panel,\n   * call allowMessagePassing().\n   */\n  force: boolean;\n};\n\nlet _bridgeActive = false;\nexport function activateBridge(allowed: boolean): void {\n  _bridgeActive = allowed;\n}\n\nexport function sendToPanel(\n  message: DevTools.ClientToPanelMessage,\n  options?: SendToPanelOptions\n): void {\n  // DevTools communication only happens on the client side\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\",\n  };\n\n  if (!(options?.force || _bridgeActive)) {\n    /*\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.log(\n      \"%c[client → panel] %c%s\",\n      \"color: green\",\n      \"color: gray; font-weight: bold\",\n      fullMsg.msg,\n      \"[🚫 NOT sent!]\"\n    );\n    */\n    return;\n  }\n  /*\n  // eslint-disable-next-line rulesdir/console-must-be-fancy\n  console.log(\n    \"%c[client → panel] %c%s\",\n    \"color: green\",\n    \"color: green; font-weight: bold\",\n    fullMsg.msg,\n    fullMsg\n  );*/\n  window.postMessage(fullMsg, \"*\");\n}\n\nconst eventSource = makeEventSource<DevTools.FullPanelToClientMessage>();\n\n// Define it as a no-op in production environments or when run outside of a browser context\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event: MessageEvent<unknown>) => {\n    if (\n      event.source === window &&\n      (event.data as Record<string, unknown>)?.source ===\n        \"liveblocks-devtools-panel\"\n    ) {\n      // console.log(\n      //   \"%c[client ← panel] %c%s\",\n      //   \"color: purple\",\n      //   \"color: purple; font-weight: bold\",\n      //   (event.data as Record<string, unknown>).msg,\n      //   event.data\n      // );\n      eventSource.notify(event.data as DevTools.FullPanelToClientMessage);\n    } else {\n      // Message not for us\n    }\n  });\n}\n\nexport const onMessageFromPanel = eventSource.observable;\n","import { kInternal } from \"../internal\";\nimport type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { UpdateYDocClientMsg } from \"../protocol/ClientMsg\";\nimport type { YDocUpdateServerMsg } from \"../protocol/ServerMsg\";\nimport type { OpaqueRoom, RoomEventMessage } from \"../room\";\nimport { PKG_VERSION } from \"../version\";\nimport { activateBridge, onMessageFromPanel, sendToPanel } from \"./bridge\";\n\nconst VERSION = PKG_VERSION || \"dev\";\nlet _devtoolsSetupHasRun = false;\n\n/**\n * Sends a wake up message to the devtools panel, if any such panel exists, and\n * listens for the initial connect message, which would be the trigger to start\n * emitting updates.\n *\n * Must be called before linkDevTools() can be used.\n *\n * Will only run once, even when called multiple times.\n */\nexport function setupDevTools(getAllRooms: () => string[]): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  if (_devtoolsSetupHasRun) {\n    // This setup code should only happen the first time\n    return;\n  }\n\n  _devtoolsSetupHasRun = true;\n\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        // Allows future sendToPanel() messages to go through\n        activateBridge(true);\n\n        // Emit an explicit \"room::available\" message for every known room at\n        // this point. These can be used by the devpanel to subscribe to such\n        // room's updates.\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION,\n          });\n        }\n\n        break;\n      }\n\n      // TODO: Later on, we can support explicit disconnects, too\n      // case \"disconnect\": {\n      //   // Make sendToPanel() no-ops again\n      //   activateBridge(false);\n      //   break;\n      // }\n    }\n  });\n\n  // Send initial wake up message, in case the devtool panel is already open!\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\n\nconst unsubsByRoomId = new Map<string, (() => void)[]>();\n\nfunction stopSyncStream(roomId: string): void {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId); // Pop it off\n\n  for (const unsub of unsubs) {\n    // Cancel all of the subscriptions to room updates that are synchronizing\n    // partial state to the devtools panel\n    unsub();\n  }\n}\n\n/**\n * Starts, or restarts, the stream of sync messages for the given room. A sync\n * stream consists of an initial \"full sync\" message, followed by many\n * \"partial\" messages that happen whenever part of the room changes.\n */\nfunction startSyncStream(room: OpaqueRoom): void {\n  stopSyncStream(room.id);\n\n  // Sync the room ID instantly, as soon as we know it\n  fullSync(room);\n\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe((eventData) =>\n      forwardEvent(room, eventData)\n    ),\n  ]);\n}\n\nfunction syncYdocUpdate(\n  room: OpaqueRoom,\n  update: YDocUpdateServerMsg | UpdateYDocClientMsg\n) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update,\n  });\n}\n\nconst loadedAt = Date.now();\nlet eventCounter = 0;\n\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\n\nfunction forwardEvent(\n  room: OpaqueRoom,\n  eventData: RoomEventMessage<JsonObject, BaseUserMeta, Json>\n) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event,\n    },\n  });\n}\n\nfunction partialSyncConnection(room: OpaqueRoom) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus(),\n  });\n}\n\nfunction partialSyncStorage(room: OpaqueRoom) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload,\n    });\n  }\n}\n\nfunction partialSyncMe(room: OpaqueRoom) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me,\n    });\n  }\n}\n\nfunction partialSyncOthers(room: OpaqueRoom) {\n  // Any time others updates, send the new storage root to the dev panel\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others,\n    });\n  }\n}\n\nfunction fullSync(room: OpaqueRoom) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  // Because the room doesn't have access to the YJS doc, we must tell it to go get the full doc\n  // sending an empty vector will return the whole document and then devtools will be up to date\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others,\n  });\n}\n\n// Currently registered \"channel\" listeners, waiting for \"room::subscribe\" or\n// \"room::unsubscribe\" messages coming from the devtools panel\nconst roomChannelListeners = new Map<string, () => void>();\n\nfunction stopRoomChannelListener(roomId: string) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\n\n/**\n * Publicly announce to the devtool panel that a new room is available.\n */\nexport function linkDevTools(roomId: string, room: OpaqueRoom): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n\n  // Before adding a new listener, stop all active listeners, so there is only\n  // ever going to be one listener per room \"channel\"\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n\n        case \"room::unsubscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\n\nexport function unlinkDevTools(roomId: string): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  // Immediately stop the sync stream of room updates to the dev panel\n  stopSyncStream(roomId);\n\n  stopRoomChannelListener(roomId);\n\n  // Inform dev panel that this room is no longer available\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId,\n  });\n}\n","/**\n * Positions, aka the Pos type, are efficient encodings of \"positions\" in\n * a list, using the following printable subset of the ASCII alphabet:\n *\n *    !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n *   ^                                                                                             ^\n *   Lowest digit                                                                      Highest digit\n *\n * Each Pos is a sequence of characters from the above alphabet, conceptually\n * codifying a floating point number 0 < n < 1. For example, the string \"31007\"\n * would be used to represent the number 0.31007, except that this\n * representation uses base 96.\n *\n *   0 ≃ ' '  (lowest digit)\n *   1 ≃ '!'\n *   2 ≃ '\"'\n *   ...\n *   9 ≃ '~'  (highest digit)\n *\n * So think:\n *   '!'    ≃ 0.1\n *   '\"'    ≃ 0.2\n *   '!\"~'  ≃ 0.129\n *\n * Three rules:\n * - All \"characters\" in the string should be valid digits (from the above\n *   alphabet)\n * - The value 0.0 is not a valid Pos value\n * - A Pos cannot have trailing \"zeroes\"\n *\n * This representation has the following benefits:\n *\n * 1. It's always possible to get a number that lies before, after, or between\n *    two arbitrary Pos values.\n * 2. Pos values can be compared using normal string comparison.\n *\n * Some examples:\n * - '!'  < '\"'   (like how .1  < .2)\n * - '!'  < '~'   (like how .1  < .9)\n * - '!!' < '!~'  (like how .11 < .19)\n * - '~!' < '~~'  (like how .91 < .99)\n * - '~'  < '~!'  (like how .9  < .91)\n * - '!!' < '!O'  (like how .1  < .5)\n * - '!O' < '!~'  (like how .5  < .9)\n *\n */\nimport type { Brand } from \"./utils\";\n\n/**\n * A valid/verified \"position\" string. These values are used as \"parentKey\"s by\n * LiveList children, and define their relative ordering.\n */\nexport type Pos = Brand<string, \"Pos\">;\n\nconst MIN_CODE = 32; // ASCII code of the lowest alphabet char (e.g. ' ')\nconst MAX_CODE = 126; // ASCII code of the highest alphabet char (e.g. '~')\n\nconst NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\n\nconst ZERO: string = nthDigit(0); // \" \"\n\n/**\n * The \"first\" canonical position.\n * In an equivalent decimal number system, think of this as the value .1.\n */\nconst ONE: Pos = nthDigit(1); // \"!\"\n\nconst ZERO_NINE = (ZERO + nthDigit(-1)) as Pos;\n\n/**\n * Returns the Pos value for the nth digit in the alphabet.\n * Value must be between 0 and 94.\n *\n * Just used to generate some static data, and for usage in test cases.\n */\nfunction nthDigit(n: 0): string; // \"0\" is a legal _digit_, but not a legal Pos value\nfunction nthDigit(n: number): Pos;\nfunction nthDigit(n: number): Pos {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code) as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n * When given only a high bound, computes the canonical position \"before\" it.\n * When given only a low bound, computes the canonical position \"after\" it.\n * When given no bounds at all, returns the \"first\" canonical position.\n */\nfunction makePosition(x?: Pos, y?: Pos): Pos {\n  if (x !== undefined && y !== undefined) {\n    return between(x, y);\n  } else if (x !== undefined) {\n    return after(x);\n  } else if (y !== undefined) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\n\n/**\n * Given any position value, computes the canonical position \"before\" it.\n *\n * The equivalent in a decimal number system would be:\n *   before(.1)     // .09\n *   before(.11)    // .1\n *   before(.111)   // .1\n *   before(.2)     // .1\n *   before(.23101) // .2\n *   before(.3)     // .2\n *   ...\n *   before(.8)     // .7\n *   before(.9)     // .8\n *   before(.91)    // .9\n *   before(.92)    // .9\n *   before(.93)    // .9\n *   ...\n *   before(.98)    // .9\n *   before(.99)    // .9\n *\n * Note:\n *   before(.01)    // .009\n *   before(.001)   // .0009\n *   before(.002)   // .001\n *   before(.00283) // .002\n *\n */\nfunction before(pos: Pos): Pos {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n\n    // Scan away all leading zeros, if there are any\n    if (code <= MIN_CODE) {\n      continue;\n    }\n\n    //\n    // Now, i points to the first non-zero digit\n    //\n    // Two options:\n    // 1. It's the last digit.\n    //    a. If it's a 1, it's on the edge. Replace with \"09\".\n    //    b. Otherwise, just lower it.\n    // 2. It's not the last digit, so we can just chop off the remainder.\n    //\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return (pos.substring(0, i) + ZERO_NINE) as Pos;\n      } else {\n        return (pos.substring(0, i) + String.fromCharCode(code - 1)) as Pos;\n      }\n    } else {\n      return pos.substring(0, i + 1) as Pos;\n    }\n  }\n\n  // If we end up here, it means the input consisted of only zeroes, which is\n  // invalid, so return the canonical first value as a best effort\n  return ONE;\n}\n\n/**\n * Given any position value, computes the canonical position \"after\" it.\n *\n * The equivalent in a decimal number system would be:\n *   after(.001)  // .1\n *   after(.1)    // .2\n *   after(.101)  // .2\n *   after(.2)    // .3\n *   after(.3)    // .4\n *   ...\n *   after(.8)    // .9\n *   after(.9)    // .91\n *   after(.91)   // .92\n *   after(.9123) // .92\n *   ...\n *   after(.98)   // .99\n *   after(.99)   // .991\n *   after(.9999) // .99991\n *\n */\nfunction after(pos: Pos): Pos {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n\n    // Scan away all leading \"nines\", if there are any\n    if (code >= MAX_CODE) {\n      continue;\n    }\n\n    // Now, i points to the first non-\"nine\" digit\n    return (pos.substring(0, i) + String.fromCharCode(code + 1)) as Pos;\n  }\n\n  // If we end up here, it means the input consisted of only \"nines\", means we\n  // can just append a ONE digit.\n  return (pos + ONE) as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n *\n * Think:\n *   between('!', '%')  // '#'    (like how between(.1, .5) would be .3)\n *   between('!', '\"')  // '!O'   (like how between(.1, .2) would be .15)\n *\n *   between(.1, .3)      // .2\n *   between(.1, .4)      // also .2\n *   between(.1, .5)      // .3\n *   between(.11, .21)    // .15\n *   between(.1,  .1003)  // .1001\n *   between(.11, .12)    // .115\n *   between(.09, .1)     // .095\n *   between(.19, .21)    // .195\n *\n */\nfunction between(lo: Pos, hi: Pos): Pos {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\n\n/**\n * Like between(), but guaranteed that lo < hi.\n */\nfunction _between(lo: Pos, hi: Pos | \"\"): Pos {\n  let index = 0;\n\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n\n    // Difference of only 1 means we'll have to settle this in the next digit\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size) as Pos;\n      const nines = \"\"; // Will get interpreted like .999999…\n      return (prefix + _between(suffix, nines)) as Pos;\n    } else {\n      // Difference of more than 1 means we take the \"middle\" between these digits\n      return (takeN(lo, index) +\n        String.fromCharCode((hiCode + loCode) >> 1)) as Pos;\n    }\n  }\n}\n\nfunction takeN(pos: string, n: number): string {\n  return n < pos.length\n    ? pos.substring(0, n)\n    : pos + ZERO.repeat(n - pos.length);\n}\n\nconst MIN_NON_ZERO_CODE = MIN_CODE + 1;\n\n/**\n * Checks whether a given string is a valid Pos value. There are three rules:\n *\n *   - The string must not be the empty string\n *   - The string must not have any trailing \"zeroes\" (trailing \" \")\n *   - All characters in the string must be from our alphabet\n *\n */\nfunction isPos(str: string): str is Pos {\n  // May not be empty string\n  if (str === \"\") {\n    return false;\n  }\n\n  // Last digit may not be a \"0\" (no trailing zeroes)\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction convertToPos(str: string): Pos {\n  const codes: number[] = [];\n\n  // All chars in the string must be in the min-max range\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    // Clamp to min-max range\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n\n  // Strip all trailing zeros\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n\n  return codes.length > 0\n    ? (String.fromCharCode(...codes) as Pos)\n    : // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n      ONE;\n}\n\n/**\n * Checks that a str is a valid Pos, and converts it to the nearest valid one\n * if not.\n */\nfunction asPos(str: string): Pos {\n  // Calling convertToPos(str) would suffice here, but since this is a hot code\n  // path, we prefer to just check, which is a lot faster.\n  return isPos(str) ? str : convertToPos(str);\n}\n\nexport { asPos, makePosition };\n\n// For use in unit tests only\nexport {\n  after as __after,\n  before as __before,\n  between as __between,\n  isPos as __isPos,\n  nthDigit as __nthDigit,\n  NUM_DIGITS as __NUM_DIGITS,\n};\n","import type { Json, JsonObject } from \"../lib/Json\";\n\nexport enum OpCode {\n  INIT = 0,\n  SET_PARENT_KEY = 1,\n  CREATE_LIST = 2,\n  UPDATE_OBJECT = 3,\n  CREATE_OBJECT = 4,\n  DELETE_CRDT = 5,\n  DELETE_OBJECT_KEY = 6,\n  CREATE_MAP = 7,\n  CREATE_REGISTER = 8,\n}\n\n/**\n * These operations are the payload for {@link UpdateStorageServerMsg} messages\n * only.\n */\nexport type Op =\n  | AckOp\n  | CreateOp\n  | UpdateObjectOp\n  | DeleteCrdtOp\n  | SetParentKeyOp // Only for lists!\n  | DeleteObjectKeyOp;\n\nexport type CreateOp =\n  | CreateObjectOp\n  | CreateRegisterOp\n  | CreateMapOp\n  | CreateListOp;\n\nexport type UpdateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.UPDATE_OBJECT;\n  readonly data: Partial<JsonObject>;\n};\n\nexport type CreateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type CreateListOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateMapOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateRegisterOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport type DeleteCrdtOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_CRDT;\n};\n\n//\n// HACK:\n// Disguised as a \"DeleteCrdtOp\" for a nonexisting node \"ACK\", this Op that the\n// server may return to senders is effectively sent as a backward-compatible\n// way to trigger an acknowledgement for Ops that were seen by the server, but\n// deliberately ignored.\n//\nexport type AckOp = {\n  readonly type: OpCode.DELETE_CRDT; // Not a typo!\n  readonly id: \"ACK\";\n  readonly opId: string;\n};\n\n/**\n * Create an Op that can be used as an acknowledgement for the given opId, to\n * send back to the originating client in cases where the server decided to\n * ignore the Op and not forward it.\n *\n * Why?\n * It's important for the client to receive an acknowledgement for this, so\n * that it can correctly update its own unacknowledged Ops administration.\n * Otherwise it could get in \"synchronizing\" state indefinitely.\n *\n * CLEVER HACK\n * Introducing a new Op type for this would not be backward-compatible as\n * receiving such Op would crash old clients :(\n * So the clever backward-compatible hack pulled here is that we codify the\n * acknowledgement as a \"deletion Op\" for the non-existing node id \"ACK\". In\n * old clients such Op is accepted, but will effectively be a no-op as that\n * node does not exist, but as a side-effect the Op will get acknowledged.\n */\nexport function ackOp(opId: string): AckOp {\n  return {\n    type: OpCode.DELETE_CRDT,\n    id: \"ACK\", // (H)ACK\n    opId,\n  };\n}\n\nexport function isAckOp(op: Op): op is AckOp {\n  return op.type === OpCode.DELETE_CRDT && op.id === \"ACK\";\n}\n\nexport type SetParentKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.SET_PARENT_KEY;\n  readonly parentKey: string;\n};\n\nexport type DeleteObjectKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_OBJECT_KEY;\n  readonly key: string;\n};\n","import { assertNever } from \"../lib/assert\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos } from \"../lib/position\";\nimport type { CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { SerializedCrdt } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport type ApplyResult =\n  | { reverse: Op[]; modified: StorageUpdate }\n  | { modified: false };\n\n/**\n * The managed pool is a namespace registry (i.e. a context) that \"owns\" all\n * the individual live nodes, ensuring each one has a unique ID, and holding on\n * to live nodes before and after they are inter-connected.\n */\nexport interface ManagedPool {\n  roomId: string;\n  generateId: () => string;\n  generateOpId: () => string;\n\n  getNode: (id: string) => LiveNode | undefined;\n  addNode: (id: string, node: LiveNode) => void;\n  deleteNode: (id: string) => void;\n\n  /**\n   * Dispatching has three responsibilities:\n   * - Sends serialized ops to the WebSocket servers\n   * - Add reverse operations to the undo/redo stack\n   * - Notify room subscribers with updates (in-client, no networking)\n   */\n  dispatch: (\n    ops: Op[],\n    reverseOps: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ) => void;\n\n  /**\n   * Ensures storage can be written to else throws an error.\n   * This is used to prevent writing to storage when the user does not have\n   * permission to do so.\n   * @throws {Error} if storage is not writable\n   * @returns {void}\n   */\n  assertStorageIsWritable: () => void;\n}\n\nexport enum OpSource {\n  UNDOREDO_RECONNECT,\n  REMOTE,\n  ACK,\n}\n\n// TODO Temporary helper to help convert from AbstractCrdt -> LiveNode, only\n// needed for within this module. The reason is that AbstractCrdt is an\n// _abstract_ type, and in our LiveNode union we exhaustively include all\n// concrete types.\n// TODO Remove me later, if we inline the abstract base methods in the concrete\n// classes.\nfunction crdtAsLiveNode(\n  value: AbstractCrdt // eslint-disable-line no-restricted-syntax\n): LiveNode {\n  return value as LiveNode;\n}\n\ntype HasParent = {\n  readonly type: \"HasParent\";\n  readonly node: LiveNode;\n  readonly key: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly pos: Pos;\n};\n\ntype NoParent = {\n  readonly type: \"NoParent\";\n};\n\ntype Orphaned = {\n  readonly type: \"Orphaned\";\n  readonly oldKey: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly oldPos: Pos;\n};\n\nfunction HasParent(\n  node: LiveNode,\n  key: string,\n  pos: Pos = asPos(key)\n): HasParent {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\n\nconst NoParent: NoParent = Object.freeze({ type: \"NoParent\" });\n\nfunction Orphaned(oldKey: string, oldPos: Pos = asPos(oldKey)): Orphaned {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\n\n/**\n * Represents the possible states of the parent field pointers.\n */\ntype ParentInfo =\n  // Both the parent node and the parent key are set. This is a normal child.\n  | HasParent\n\n  // Neither are set. This is either the root node (if attached to a document),\n  // or it's a dangling node that hasn't been attached yet.\n  | NoParent\n\n  // -------------------------------------------------------------------------\n  // TODO Refactor this state away!\n  // -------------------------------------------------------------------------\n  // Tricky case! This state is used after the node is detached from its\n  // parent, but we still need to retain the parent key that it was originally\n  // attached under. For example we rely on this to derive the reverse Op to\n  // add. We should be able to get rid of this case by structuring the code\n  // differently!\n  | Orphaned;\n\nexport abstract class AbstractCrdt {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool?: ManagedPool;\n  #id?: string;\n\n  #parent: ParentInfo = NoParent;\n\n  /** @internal */\n  _getParentKeyOrThrow(): string {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  get _parentPos(): Pos {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldPos;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  protected get _pool(): ManagedPool | undefined {\n    return this.#pool;\n  }\n\n  get roomId(): string | null {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n\n  /** @internal */\n  get _id(): string | undefined {\n    return this.#id;\n  }\n\n  /** @internal */\n  get parent(): ParentInfo {\n    return this.#parent;\n  }\n\n  /** @internal */\n  get _parentKey(): string | null {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        return null;\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, _isLocal: boolean): ApplyResult {\n    switch (op.type) {\n      case OpCode.DELETE_CRDT: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n\n        return { modified: false };\n      }\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  _setParentLink(newParentNode: LiveNode, newParentKey: string): void {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          // Ignore\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n\n    pool.addNode(id, crdtAsLiveNode(this));\n\n    this.#id = id;\n    this.#pool = pool;\n  }\n\n  /** @internal */\n  abstract _attachChild(op: CreateOp, source: OpSource): ApplyResult;\n\n  /** @internal */\n  _detach(): void {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n\n      case \"Orphaned\": {\n        // No change needed\n        break;\n      }\n\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n\n    this.#pool = undefined;\n  }\n\n  /** @internal */\n  abstract _detachChild(crdt: LiveNode): ApplyResult;\n\n  /** @internal */\n  abstract _toOps(\n    parentId: string,\n    parentKey: string,\n    pool?: ManagedPool\n  ): CreateOp[];\n\n  /** @internal */\n  abstract _serialize(): SerializedCrdt;\n\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable?: Immutable;\n\n  #cachedTreeNodeKey?: string | number;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode?: DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate(): void {\n    if (\n      this.#cachedImmutable !== undefined ||\n      this.#cachedTreeNode !== undefined\n    ) {\n      this.#cachedImmutable = undefined;\n      this.#cachedTreeNode = undefined;\n\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n\n  /** @internal */\n  abstract _toTreeNode(key: string): DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key: string): DevTools.LsonTreeNode {\n    if (this.#cachedTreeNode === undefined || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n\n    // Return cached version\n    return this.#cachedTreeNode;\n  }\n\n  /** @internal */\n  abstract _toImmutable(): Immutable;\n\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable(): Immutable {\n    if (this.#cachedImmutable === undefined) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n\n    // Return cached version\n    return this.#cachedImmutable;\n  }\n\n  /**\n   * Returns a deep clone of the current LiveStructure, suitable for insertion\n   * in the tree elsewhere.\n   */\n  abstract clone(): Lson;\n}\n","import type { Json, JsonObject } from \"../lib/Json\";\n\nexport type IdTuple<T> = [id: string, value: T];\n\nexport enum CrdtType {\n  OBJECT = 0,\n  LIST = 1,\n  MAP = 2,\n  REGISTER = 3,\n}\n\nexport type SerializedCrdt = SerializedRootObject | SerializedChild;\n\nexport type SerializedChild =\n  | SerializedObject\n  | SerializedList\n  | SerializedMap\n  | SerializedRegister;\n\nexport type SerializedRootObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly data: JsonObject;\n\n  // Root objects don't have a parent relationship\n  readonly parentId?: never;\n  readonly parentKey?: never;\n};\n\nexport type SerializedObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type SerializedList = {\n  readonly type: CrdtType.LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedMap = {\n  readonly type: CrdtType.MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedRegister = {\n  readonly type: CrdtType.REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport function isRootCrdt(crdt: SerializedCrdt): crdt is SerializedRootObject {\n  return crdt.type === CrdtType.OBJECT && !isChildCrdt(crdt);\n}\n\nexport function isChildCrdt(crdt: SerializedCrdt): crdt is SerializedChild {\n  return crdt.parentId !== undefined && crdt.parentKey !== undefined;\n}\n","import type { LiveNode } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { Json } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport { deepClone } from \"../lib/utils\";\nimport type { CreateOp, CreateRegisterOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedRegister } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt } from \"./AbstractCrdt\";\n\n/**\n * INTERNAL\n */\nexport class LiveRegister<TValue extends Json> extends AbstractCrdt {\n  #data: TValue;\n\n  constructor(data: TValue) {\n    super();\n    this.#data = data;\n  }\n\n  get data(): TValue {\n    return this.#data;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: IdTuple<SerializedRegister>,\n    _parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveRegister<Json> {\n    const register = new LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n\n  /** @internal */\n  _toOps(\n    parentId: string,\n    parentKey: string,\n    pool?: ManagedPool\n  ): CreateRegisterOp[] {\n    if (this._id === undefined) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n\n    return [\n      {\n        type: OpCode.CREATE_REGISTER,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data,\n      },\n    ];\n  }\n\n  /** @internal */\n  _serialize(): SerializedRegister {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.REGISTER,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data,\n    };\n  }\n\n  /** @internal */\n  _attachChild(_op: CreateOp): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _detachChild(_crdt: LiveNode): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data,\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): Immutable {\n    return this.#data;\n  }\n\n  clone(): TValue {\n    return deepClone(this.data);\n  }\n}\n","import { nn } from \"../lib/assert\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos, makePosition } from \"../lib/position\";\nimport type { CreateListOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedList } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveListUpdateDelta =\n  | { type: \"insert\"; index: number; item: Lson }\n  | { type: \"delete\"; index: number; deletedItem: Lson }\n  | { type: \"move\"; index: number; previousIndex: number; item: Lson }\n  | { type: \"set\"; index: number; item: Lson };\n\n/**\n * A LiveList notification that is sent in-client to any subscribers whenever\n * one or more of the items inside the LiveList instance have changed.\n */\nexport type LiveListUpdates<TItem extends Lson> = {\n  type: \"LiveList\";\n  node: LiveList<TItem>;\n  updates: LiveListUpdateDelta[];\n};\n\nfunction compareNodePosition(itemA: LiveNode, itemB: LiveNode) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\n\n/**\n * The LiveList class represents an ordered collection of items that is synchronized across clients.\n */\nexport class LiveList<TItem extends Lson> extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  #items: LiveNode[];\n  #implicitlyDeletedItems: WeakSet<LiveNode>;\n  #unacknowledgedSets: Map<string, string>;\n\n  constructor(items: TItem[]) {\n    super();\n    this.#items = [];\n    this.#implicitlyDeletedItems = new WeakSet();\n    this.#unacknowledgedSets = new Map();\n\n    let position = undefined;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this.#items.push(node);\n      position = newPosition;\n    }\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id]: IdTuple<SerializedList>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveList<Lson> {\n    const list = new LiveList([]);\n    list._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return list;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, pool);\n\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n\n    return list;\n  }\n\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateListOp = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: OpCode.CREATE_LIST,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const item of this.#items) {\n      const parentKey = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey, pool),\n        undefined\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== undefined) {\n        this.#unacknowledgedSets.set(parentKey, childOpId);\n      }\n      ops.push(...childOps);\n    }\n\n    return ops;\n  }\n\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item: LiveNode): void {\n    this.#items.push(item);\n    this._sortItems();\n  }\n\n  /** @internal */\n  _sortItems(): void {\n    this.#items.sort(compareNodePosition);\n    this.invalidate();\n  }\n\n  /** @internal */\n  _indexOfPosition(position: string): number {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n\n  #applySetRemote(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n\n    const deletedId = op.deletedId;\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n\n    // If there is already an item at this position\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];\n\n      // No conflict, the item that is being replaced is the same that was deleted on the sender\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n\n        // Replace the existing item with the newly created item without sorting the list\n        this.#items[indexOfItemWithSamePosition] = child;\n\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child),\n          ]),\n          reverse: [],\n        };\n      } else {\n        // item at position to be replaced is different from server, so we put in a cache\n        // This scenario can happen if an other item has been put at this position\n        // while getting the acknowledgement of the set (move, insert or set)\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n\n        // Replace the existing item with the newly created item without sorting the list\n        this.#items[indexOfItemWithSamePosition] = child;\n\n        const delta: LiveListUpdateDelta[] = [\n          setDelta(indexOfItemWithSamePosition, child),\n        ];\n\n        // Even if we implicitly delete the item at the set position\n        // We still need to delete the item that was orginaly deleted by the set\n        const deleteDelta = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n\n        if (deleteDelta) {\n          delta.push(deleteDelta);\n        }\n\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: [],\n        };\n      }\n    } else {\n      // Item at position to be replaced doesn't exist\n      const updates: LiveListUpdateDelta[] = [];\n      const deleteDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta) {\n        updates.push(deleteDelta);\n      }\n\n      this._insertAndSort(child);\n\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates),\n      };\n    }\n  }\n\n  #applySetAck(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const delta: LiveListUpdateDelta[] = [];\n\n    // Deleted item can be re-inserted by remote undo/redo\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n\n    if (unacknowledgedOpId !== undefined) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0\n          ? { modified: false }\n          : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n\n    const existingItem = this.#items.find((item) => item._id === op.id);\n\n    // If item already exists...\n    if (existingItem !== undefined) {\n      // ...and if it's at the right position\n      if (existingItem._parentKey === op.parentKey) {\n        // ... do nothing\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: [],\n        };\n      }\n\n      // Item exists but not at the right position (local move after set)\n      if (indexOfItemWithSamePosition !== -1) {\n        this.#implicitlyDeletedItems.add(\n          this.#items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n\n      const prevIndex = this.#items.indexOf(existingItem);\n\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n\n      const newIndex = this.#items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: [],\n      };\n    } else {\n      // Item associated to the set ack does not exist either deleted localy or via remote undo/redo\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        // Reattach orphan at the new position\n        orphan._setParentLink(this, op.parentKey);\n        // And delete it from the orphan cache\n        this.#implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const recreatedItemIndex = this.#items.indexOf(orphan);\n\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(recreatedItemIndex, orphan)\n              : setDelta(recreatedItemIndex, orphan),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this.#items.splice(indexOfItemWithSamePosition, 1);\n        }\n\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(newIndex, newItem)\n              : setDelta(newIndex, newItem),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(\n    deletedId?: string\n  ): LiveListUpdateDelta | null {\n    if (deletedId === undefined || this._pool === undefined) {\n      return null;\n    }\n\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === undefined) {\n      return null;\n    }\n\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n\n    return result.modified.updates[0];\n  }\n\n  #applyRemoteInsert(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const key = asPos(op.parentKey);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    if (existingItemIndex !== -1) {\n      // If change is remote => assign a temporary position to existing child until we get the fix from the backend\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n\n    // TODO: add move update?\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: [],\n    };\n  }\n\n  #applyInsertAck(op: CreateOp): ApplyResult {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n\n    const itemIndexAtPosition = this._indexOfPosition(key);\n\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        // Normal case, no modification\n        return {\n          modified: false,\n        };\n      } else {\n        const oldPositionIndex = this.#items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n\n        const newIndex = this._indexOfPosition(key);\n\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem),\n          ]),\n          reverse: [],\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        // Implicit delete after set\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const newIndex = this._indexOfPosition(key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: [],\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  #applyInsertUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    let newKey = key;\n\n    if (existingItemIndex !== -1) {\n      const before = this.#items[existingItemIndex]?._parentPos;\n      const after = this.#items[existingItemIndex + 1]?._parentPos;\n\n      newKey = makePosition(before, after);\n      child._setParentLink(this, newKey);\n    }\n\n    this._insertAndSort(child);\n\n    const newIndex = this._indexOfPosition(newKey);\n\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: OpCode.DELETE_CRDT, id }],\n    };\n  }\n\n  #applySetUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const newKey = key;\n\n    // If there is already an item at this position\n    if (indexOfItemWithSameKey !== -1) {\n      // TODO: Should we add this item to implictly deleted item?\n      const existingItem = this.#items[indexOfItemWithSameKey];\n      existingItem._detach();\n\n      this.#items[indexOfItemWithSameKey] = child;\n\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n\n      return {\n        modified: makeUpdate(this, delta),\n        reverse,\n      };\n    } else {\n      this._insertAndSort(child);\n\n      // TODO: Use delta\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n\n      const newIndex = this._indexOfPosition(newKey);\n\n      return {\n        reverse: [{ type: OpCode.DELETE_CRDT, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      };\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    let result: ApplyResult;\n\n    if (op.intent === \"set\") {\n      if (source === OpSource.REMOTE) {\n        result = this.#applySetRemote(op);\n      } else if (source === OpSource.ACK) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === OpSource.REMOTE) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === OpSource.ACK) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n\n    return result;\n  }\n\n  /** @internal */\n  _detachChild(\n    child: LiveNode\n  ): { reverse: Op[]; modified: LiveListUpdates<TItem> } | { modified: false } {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n\n      const indexToDelete = this.#items.indexOf(child);\n\n      if (indexToDelete === -1) {\n        return {\n          modified: false,\n        };\n      }\n\n      const [previousNode] = this.#items.splice(indexToDelete, 1);\n      this.invalidate();\n\n      child._detach();\n\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse,\n      };\n    }\n\n    return { modified: false };\n  }\n\n  #applySetChildKeyRemote(newKey: Pos, child: LiveNode): ApplyResult {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n\n      const newIndex = this.#items.indexOf(child);\n\n      // TODO: Shift existing item?\n\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: [],\n      };\n    }\n\n    const previousKey = child._parentKey;\n\n    if (newKey === previousKey) {\n      return {\n        modified: false,\n      };\n    }\n\n    // TODO: should we look at orphan\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // Normal case\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    } else {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    }\n  }\n\n  #applySetChildKeyAck(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      this.#implicitlyDeletedItems.delete(child);\n\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n\n      // TODO\n      return {\n        modified: false,\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false,\n        };\n      }\n\n      // At this point, it means that the item has been moved before receiving the ack\n      // so we replace it at the right position\n\n      const previousIndex = this.#items.indexOf(child);\n\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n\n      child._setParentLink(this, newKey);\n      this._sortItems();\n\n      const newIndex = this.#items.indexOf(child);\n\n      if (previousIndex === newIndex) {\n        // parentKey changed but final position in the list didn't\n        return {\n          modified: false,\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child),\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  #applySetChildKeyUndoRedo(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    const previousIndex = this.#items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // Assign a temporary position until we get the fix from the backend\n    if (existingItemIndex !== -1) {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n\n    child._setParentLink(this, newKey);\n\n    this._sortItems();\n\n    const newIndex = this.#items.indexOf(child);\n\n    if (previousIndex === newIndex) {\n      return {\n        modified: false,\n      };\n    }\n\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: OpCode.SET_PARENT_KEY,\n          id: nn(child._id),\n          parentKey: previousKey,\n        },\n      ],\n    };\n  }\n\n  /** @internal */\n  _setChildKey(newKey: Pos, child: LiveNode, source: OpSource): ApplyResult {\n    if (source === OpSource.REMOTE) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === OpSource.ACK) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _serialize(): SerializedList {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.LIST,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns the number of elements.\n   */\n  get length(): number {\n    return this.#items.length;\n  }\n\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element: TItem, index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n\n    const before = this.#items[index - 1]\n      ? this.#items[index - 1]._parentPos\n      : undefined;\n    const after = this.#items[index]\n      ? this.#items[index]._parentPos\n      : undefined;\n\n    const position = makePosition(before, after);\n\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n\n    this._insertAndSort(value);\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: OpCode.DELETE_CRDT, id }],\n        new Map<string, LiveListUpdates<TItem>>([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])],\n        ])\n      );\n    }\n  }\n\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index: number, targetIndex: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n\n    let beforePosition = null;\n    let afterPosition = null;\n\n    if (index < targetIndex) {\n      afterPosition =\n        targetIndex === this.#items.length - 1\n          ? undefined\n          : this.#items[targetIndex + 1]._parentPos;\n      beforePosition = this.#items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this.#items[targetIndex]._parentPos;\n      beforePosition =\n        targetIndex === 0 ? undefined : this.#items[targetIndex - 1]._parentPos;\n    }\n\n    const position = makePosition(beforePosition, afterPosition);\n\n    const item = this.#items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n\n    if (this._pool && this._id) {\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])],\n      ]);\n\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position,\n          },\n        ],\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            parentKey: previousPosition,\n          },\n        ],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${\n          this.#items.length - 1\n        }`\n      );\n    }\n\n    const item = this.#items[index];\n    item._detach();\n    const [prev] = this.#items.splice(index, 1);\n    this.invalidate();\n\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: OpCode.DELETE_CRDT,\n            },\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n\n  clear(): void {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops: Op[] = [];\n      const reverseOps: Op[] = [];\n\n      const updateDelta: LiveListUpdateDelta[] = [];\n\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: OpCode.DELETE_CRDT,\n            id: childId,\n            opId: this._pool.generateOpId(),\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n\n          // Index is always 0 because updates are applied one after another\n          // when applied on an immutable state\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n\n      this.#items = [];\n      this.invalidate();\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items = [];\n      this.invalidate();\n    }\n  }\n\n  set(index: number, item: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${\n          this.#items.length - 1\n        }`\n      );\n    }\n\n    const existingItem = this.#items[index];\n    const position = existingItem._getParentKeyOrThrow();\n\n    const existingId = existingItem._id;\n    existingItem._detach();\n\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items[index] = value;\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, undefined),\n        id\n      );\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray(): TItem[] {\n    return this.#items.map(\n      (entry) => liveNodeToLson(entry) as TItem\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().every(predicate);\n  }\n\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate: (value: TItem, index: number) => unknown): TItem[] {\n    return this.toArray().filter(predicate);\n  }\n\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate: (value: TItem, index: number) => unknown): TItem | undefined {\n    return this.toArray().find(predicate);\n  }\n\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate: (value: TItem, index: number) => unknown): number {\n    return this.toArray().findIndex(predicate);\n  }\n\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn: (value: TItem, index: number) => void): void {\n    return this.toArray().forEach(callbackfn);\n  }\n\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index: number): TItem | undefined {\n    if (index < 0 || index >= this.#items.length) {\n      return undefined;\n    }\n\n    return liveNodeToLson(this.#items[index]) as TItem | undefined;\n    //                                           ^^^^^^^^^^^^^^^^^\n    //                                           FIXME! This isn't safe.\n  }\n\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map<U>(callback: (value: TItem, index: number) => U): U[] {\n    return this.#items.map((entry, i) =>\n      callback(\n        liveNodeToLson(entry) as TItem,\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().some(predicate);\n  }\n\n  [Symbol.iterator](): IterableIterator<TItem> {\n    return new LiveListIterator(this.#items);\n  }\n\n  #createAttachItemAndSort(\n    op: CreateOp,\n    key: string\n  ): {\n    newItem: LiveNode;\n    newIndex: number;\n  } {\n    const newItem = creationOpToLiveNode(op);\n\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n\n    this._insertAndSort(newItem);\n\n    const newIndex = this._indexOfPosition(key);\n\n    return { newItem, newIndex };\n  }\n\n  #shiftItemPosition(index: number, key: Pos) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1\n        ? this.#items[index + 1]?._parentPos\n        : undefined\n    );\n\n    this.#items[index]._setParentLink(this, shiftedPosition);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#items.map((item, index) =>\n        item.toTreeNode(index.toString())\n      ),\n    };\n  }\n\n  toImmutable(): readonly ToImmutable<TItem>[] {\n    // Don't implement actual toJson logic in here. Implement it in ._toImmutable()\n    // instead. This helper merely exists to help TypeScript infer better\n    // return types.\n    return super.toImmutable() as readonly ToImmutable<TItem>[];\n  }\n\n  /** @internal */\n  _toImmutable(): readonly ToImmutable<TItem>[] {\n    const result = this.#items.map((node) => node.toImmutable());\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as readonly ToImmutable<TItem>[];\n  }\n\n  clone(): LiveList<TItem> {\n    return new LiveList(this.#items.map((item) => item.clone() as TItem));\n  }\n}\n\nclass LiveListIterator<T extends Lson> implements IterableIterator<T> {\n  #innerIterator: IterableIterator<LiveNode>;\n\n  constructor(items: Array<LiveNode>) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.#innerIterator.next();\n\n    if (result.done) {\n      return {\n        done: true,\n        value: undefined,\n      };\n    }\n\n    const value = liveNodeToLson(result.value) as T;\n    //                                         ^^^^\n    //                                         FIXME! This isn't safe.\n    return { value };\n  }\n}\n\nfunction makeUpdate<TItem extends Lson>(\n  liveList: LiveList<TItem>,\n  deltaUpdates: LiveListUpdateDelta[]\n): LiveListUpdates<TItem> {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates,\n  };\n}\n\nfunction setDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction deleteDelta(\n  index: number,\n  deletedNode: LiveNode\n): LiveListUpdateDelta {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem:\n      deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode,\n  };\n}\n\nfunction insertDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction moveDelta(\n  previousIndex: number,\n  index: number,\n  item: LiveNode\n): LiveListUpdateDelta {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex,\n  };\n}\n\n/**\n * This function is only temporary.\n * As soon as we refactor the operations structure,\n * serializing a LiveStructure should not know anything about intent\n */\nfunction HACK_addIntentAndDeletedIdToOperation(\n  ops: CreateOp[],\n  deletedId: string | undefined\n): CreateOp[] {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      // NOTE: Only patch the first Op here\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId,\n      };\n    } else {\n      return op;\n    }\n  });\n}\n","import { nn } from \"../lib/assert\";\nimport { freeze } from \"../lib/freeze\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { CreateMapOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedMap } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  isLiveNode,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\n/**\n * A LiveMap notification that is sent in-client to any subscribers whenever\n * one or more of the values inside the LiveMap instance have changed.\n */\nexport type LiveMapUpdates<TKey extends string, TValue extends Lson> = {\n  type: \"LiveMap\";\n  node: LiveMap<TKey, TValue>;\n  updates: { [key: string]: UpdateDelta };\n  //               ^^^^^^\n  //               FIXME: `string` is not specific enough here. See if we can\n  //               improve this type to match TKey!\n};\n\n/**\n * The LiveMap class is similar to a JavaScript Map that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveMap<\n  TKey extends string,\n  TValue extends Lson,\n> extends AbstractCrdt {\n  #map: Map<TKey, LiveNode>;\n  #unacknowledgedSet: Map<TKey, string>;\n\n  constructor(entries?: readonly (readonly [TKey, TValue])[] | undefined) {\n    super();\n    this.#unacknowledgedSet = new Map<TKey, string>();\n\n    if (entries) {\n      const mappedEntries: [TKey, LiveNode][] = [];\n      for (const [key, value] of entries) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = new Map();\n    }\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateMapOp = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: OpCode.CREATE_MAP,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this.#map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n\n    return ops;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, _item]: IdTuple<SerializedMap>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveMap<string, Lson> {\n    const map = new LiveMap();\n    map._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return map;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n\n    return map;\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey, opId } = op;\n\n    const key = parentKey as TKey;\n    //                    ^^^^^^^ TODO: Fix me!\n\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    if (source === OpSource.ACK) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        // Acknowlegment from local operation\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== undefined) {\n        // Another local set has overriden the value, so we do nothing\n        return { modified: false };\n      }\n    } else if (source === OpSource.REMOTE) {\n      // If a remote operation set an item,\n      // delete the unacknowledgedSet associated to the key\n      // to make sure any future ack can override it\n      this.#unacknowledgedSet.delete(key);\n    }\n\n    const previousValue = this.#map.get(key);\n    let reverse: Op[];\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: OpCode.DELETE_CRDT, id }];\n    }\n\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      },\n      reverse,\n    };\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n\n  /** @internal */\n  _detachChild(child: LiveNode): ApplyResult {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n\n    child._detach();\n\n    const storageUpdate: LiveMapUpdates<TKey, TValue> = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } },\n    };\n\n    return { modified: storageUpdate, reverse };\n  }\n\n  /** @internal */\n  _serialize(): SerializedMap {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.MAP,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key: TKey): TValue | undefined {\n    const value = this.#map.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n    return liveNodeToLson(value) as TValue | undefined;\n    //                           ^^^^^^^^^^^^^^^^^^^^^\n    //                           FIXME! This isn't safe.\n  }\n\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key: TKey, value: TValue): void {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n\n    if (oldValue) {\n      oldValue._detach();\n    }\n\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n\n    this.#map.set(key, item);\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      });\n\n      const ops = item._toOps(this._id, key, this._pool);\n\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue\n          ? oldValue._toOps(this._id, key)\n          : [{ type: OpCode.DELETE_CRDT, id }],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size(): number {\n    return this.#map.size;\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key: TKey): boolean {\n    return this.#map.has(key);\n  }\n\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key: TKey): boolean {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n\n    if (item === undefined) {\n      return false;\n    }\n\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } },\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.DELETE_CRDT,\n            id: item._id,\n            opId: this._pool.generateOpId(),\n          },\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries(): IterableIterator<[TKey, TValue]> {\n    const innerIterator = this.#map.entries();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const entry = iteratorValue.value;\n\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]) as TValue;\n        //                                                   ^^^^^^^^^\n        //                                                   FIXME! This isn't safe.\n        return {\n          value: [key, value],\n        };\n      },\n    };\n  }\n\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator](): IterableIterator<[TKey, TValue]> {\n    return this.entries();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys(): IterableIterator<TKey> {\n    return this.#map.keys();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values(): IterableIterator<TValue> {\n    const innerIterator = this.#map.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const value = liveNodeToLson(iteratorValue.value) as TValue;\n        //                                                ^^^^^^^^^\n        //                                                FIXME! This isn't safe.\n\n        return { value };\n      },\n    };\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(\n    callback: (value: TValue, key: TKey, map: LiveMap<TKey, TValue>) => void\n  ): void {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(([key, val]) =>\n        val.toTreeNode(key)\n      ),\n    };\n  }\n\n  toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ReadonlyMap<TKey, ToImmutable<TValue>>;\n  }\n\n  /** @internal */\n  _toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    const result: Map<TKey, ToImmutable<TValue>> = new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable() as ToImmutable<TValue>);\n    }\n    return freeze(result);\n  }\n\n  clone(): LiveMap<TKey, TValue> {\n    return new LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone() as TValue])\n    );\n  }\n}\n","import type { LiveNode, Lson, LsonObject } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { RemoveUndefinedValues } from \"../lib/utils\";\nimport { compactObject, deepClone } from \"../lib/utils\";\nimport type {\n  CreateObjectOp,\n  CreateOp,\n  DeleteObjectKeyOp,\n  Op,\n  UpdateObjectOp,\n} from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type {\n  IdTuple,\n  SerializedChild,\n  SerializedCrdt,\n  SerializedObject,\n  SerializedRootObject,\n} from \"../protocol/SerializedCrdt\";\nimport { CrdtType, isRootCrdt } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLson,\n  deserializeToLson,\n  isLiveNode,\n  isLiveStructure,\n} from \"./liveblocks-helpers\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveObjectUpdateDelta<O extends { [key: string]: unknown }> = {\n  [K in keyof O]?: UpdateDelta | undefined;\n};\n\n/**\n * A LiveObject notification that is sent in-client to any subscribers whenever\n * one or more of the entries inside the LiveObject instance have changed.\n */\nexport type LiveObjectUpdates<TData extends LsonObject> = {\n  type: \"LiveObject\";\n  node: LiveObject<TData>;\n  updates: LiveObjectUpdateDelta<TData>;\n};\n\n/**\n * The LiveObject class is similar to a JavaScript object that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveObject<O extends LsonObject> extends AbstractCrdt {\n  #map: Map<string, Lson>;\n  #propToLastUpdate: Map<string, string>;\n\n  static #buildRootAndParentToChildren(\n    items: IdTuple<SerializedCrdt>[]\n  ): [IdTuple<SerializedRootObject>, ParentToChildNodeMap] {\n    const parentToChildren: ParentToChildNodeMap = new Map();\n    let root: IdTuple<SerializedRootObject> | null = null;\n\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple: IdTuple<SerializedChild> = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== undefined) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n\n    return [root, parentToChildren];\n  }\n\n  /** @internal */\n  static _fromItems<O extends LsonObject>(\n    items: IdTuple<SerializedCrdt>[],\n    pool: ManagedPool\n  ): LiveObject<O> {\n    const [root, parentToChildren] =\n      LiveObject.#buildRootAndParentToChildren(items);\n    return LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    ) as LiveObject<O>;\n  }\n\n  constructor(obj: O = {} as O) {\n    super();\n\n    this.#propToLastUpdate = new Map<string, string>();\n\n    const o: RemoveUndefinedValues<LsonObject> = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n\n    this.#map = new Map(Object.entries(o));\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const opId = pool?.generateOpId();\n\n    const ops: CreateOp[] = [];\n    const op: CreateObjectOp = {\n      type: OpCode.CREATE_OBJECT,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {},\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n\n    return ops;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: IdTuple<SerializedObject | SerializedRootObject>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const liveObj = new LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n\n  /** @internal */\n  static _deserializeChildren(\n    liveObj: LiveObject<JsonObject>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === undefined) {\n      return liveObj;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n\n    return liveObj;\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      if (this.#propToLastUpdate.get(key) === opId) {\n        // Acknowlegment from local operation\n        this.#propToLastUpdate.delete(key);\n      }\n\n      return { modified: false };\n    }\n\n    if (source === OpSource.UNDOREDO_RECONNECT) {\n      this.#propToLastUpdate.set(key, nn(opId));\n    } else if (this.#propToLastUpdate.get(key) === undefined) {\n      // Remote operation with no local change => apply operation\n    } else if (this.#propToLastUpdate.get(key) === opId) {\n      // Acknowlegment from local operation\n      this.#propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      // Conflict, ignore remote operation\n      return { modified: false };\n    }\n\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse: Op[];\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === undefined) {\n      reverse = [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id: thisId,\n          data: { [key]: previousValue },\n        },\n      ];\n    }\n\n    this.#map.set(key, child);\n    this.invalidate();\n\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } },\n      },\n    };\n  }\n\n  /** @internal */\n  _detachChild(child: LiveNode): ApplyResult {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n\n      child._detach();\n\n      const storageUpdate: LiveObjectUpdates<O> = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" },\n        } as { [K in keyof O]: UpdateDelta },\n      };\n\n      return { modified: storageUpdate, reverse };\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    if (op.type === OpCode.UPDATE_OBJECT) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === OpCode.DELETE_OBJECT_KEY) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _serialize(): SerializedObject | SerializedRootObject {\n    const data: JsonObject = {};\n\n    // Add only the static Json data fields into the objects\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: CrdtType.OBJECT,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data,\n      };\n    } else {\n      // Root object has no parent ID/key\n      return {\n        type: CrdtType.OBJECT,\n        data,\n      };\n    }\n  }\n\n  #applyUpdate(op: UpdateObjectOp, isLocal: boolean): ApplyResult {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse: Op[] = [];\n    const reverseUpdate: UpdateObjectOp = {\n      type: OpCode.UPDATE_OBJECT,\n      id,\n      data: {},\n    };\n\n    for (const key in op.data as Partial<O>) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== undefined) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === undefined) {\n        reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id, key });\n      }\n    }\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n    for (const key in op.data as Partial<O>) {\n      const value = op.data[key];\n      if (value === undefined) {\n        continue;\n      }\n\n      if (isLocal) {\n        this.#propToLastUpdate.set(key, nn(op.opId));\n      } else if (this.#propToLastUpdate.get(key) === undefined) {\n        // Not modified localy so we apply update\n        isModified = true;\n      } else if (this.#propToLastUpdate.get(key) === op.opId) {\n        // Acknowlegment from local operation\n        this.#propToLastUpdate.delete(key);\n        continue;\n      } else {\n        // Conflict, ignore remote operation\n        continue;\n      }\n\n      const oldValue = this.#map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n\n    return isModified\n      ? {\n          modified: {\n            node: this,\n            type: \"LiveObject\",\n            updates: updateDelta,\n          },\n          reverse,\n        }\n      : { modified: false };\n  }\n\n  #applyDeleteObjectKey(op: DeleteObjectKeyOp, isLocal: boolean): ApplyResult {\n    const key = op.key;\n\n    // If property does not exist, exit without notifying\n    if (this.#map.has(key) === false) {\n      return { modified: false };\n    }\n\n    // If a local operation exists on the same key and we receive a remote\n    // one prevent flickering by not applying delete op.\n    if (!isLocal && this.#propToLastUpdate.get(key) !== undefined) {\n      return { modified: false };\n    }\n\n    const oldValue = this.#map.get(key);\n\n    const id = nn(this._id);\n    let reverse: Op[] = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== undefined) {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id,\n          data: { [key]: oldValue },\n        },\n      ];\n    }\n\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } },\n      },\n      reverse,\n    };\n  }\n\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject(): O {\n    return Object.fromEntries(this.#map) as O;\n  }\n\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set<TKey extends keyof O>(key: TKey, value: O[TKey]): void {\n    // TODO: Find out why typescript complains\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value } as unknown as Partial<O>);\n  }\n\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get<TKey extends keyof O>(key: TKey): O[TKey] {\n    return this.#map.get(key as string) as O[TKey];\n  }\n\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key: keyof O): void {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key as string;\n    const oldValue = this.#map.get(keyAsString);\n\n    if (oldValue === undefined) {\n      return;\n    }\n\n    if (this._pool === undefined || this._id === undefined) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n\n    let reverse: Op[];\n\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          data: { [keyAsString]: oldValue },\n          id: this._id,\n        },\n      ];\n    }\n\n    this.#map.delete(keyAsString);\n    this.invalidate();\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } } as {\n        [K in keyof O]: UpdateDelta;\n      },\n    });\n\n    this._pool.dispatch(\n      [\n        {\n          type: OpCode.DELETE_OBJECT_KEY,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId(),\n        },\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch: Partial<O>): void {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === undefined || this._id === undefined) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === undefined) {\n          continue;\n        }\n\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n\n      return;\n    }\n\n    const ops: Op[] = [];\n    const reverseOps: Op[] = [];\n\n    const opId = this._pool.generateOpId();\n    const updatedProps: JsonObject = {};\n\n    const reverseUpdateOp: UpdateObjectOp = {\n      id: this._id,\n      type: OpCode.UPDATE_OBJECT,\n      data: {},\n    };\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n\n    for (const key in patch) {\n      const newValue: Lson | undefined = patch[key];\n      if (newValue === undefined) {\n        continue;\n      }\n\n      const oldValue = this.#map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === undefined) {\n        reverseOps.push({ type: OpCode.DELETE_OBJECT_KEY, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n\n        const createCrdtOp = newAttachChildOps.find(\n          (op: Op & { parentId?: string }) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this.#propToLastUpdate.set(key, opId);\n      }\n\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: OpCode.UPDATE_OBJECT,\n        data: updatedProps,\n      });\n    }\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta,\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n\n  toImmutable(): ToImmutable<O> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ToImmutable<O>;\n  }\n\n  /** @internal */\n  toTreeNode(key: string): DevTools.LiveTreeNode<\"LiveObject\"> {\n    // Don't implement actual toTreeNode logic in here. Implement it in\n    // ._toTreeNode() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toTreeNode(key) as DevTools.LiveTreeNode<\"LiveObject\">;\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(([key, value]) =>\n        isLiveNode(value)\n          ? value.toTreeNode(key)\n          : { type: \"Json\", id: `${nodeId}:${key}`, key, payload: value }\n      ),\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): ToImmutable<O> {\n    const result: { [key: string]: unknown } = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as ToImmutable<O>;\n  }\n\n  clone(): LiveObject<O> {\n    return new LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value),\n        ])\n      ) as O\n    );\n  }\n}\n","import { assertNever, nn } from \"../lib/assert\";\nimport { isPlainObject } from \"../lib/guards\";\nimport type { Json } from \"../lib/Json\";\nimport { deepClone, entries } from \"../lib/utils\";\nimport type { CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedCrdt } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type { NodeMap, ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ManagedPool } from \"./AbstractCrdt\";\nimport { LiveList, type LiveListUpdates } from \"./LiveList\";\nimport { LiveMap, type LiveMapUpdates } from \"./LiveMap\";\nimport { LiveObject, type LiveObjectUpdates } from \"./LiveObject\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, LiveStructure, Lson, LsonObject } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport function creationOpToLiveNode(op: CreateOp): LiveNode {\n  return lsonToLiveNode(creationOpToLson(op));\n}\n\nexport function creationOpToLson(op: CreateOp): Lson {\n  switch (op.type) {\n    case OpCode.CREATE_REGISTER:\n      return op.data;\n    case OpCode.CREATE_OBJECT:\n      return new LiveObject(op.data);\n    case OpCode.CREATE_MAP:\n      return new LiveMap();\n    case OpCode.CREATE_LIST:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\n\nexport function isSameNodeOrChildOf(node: LiveNode, parent: LiveNode): boolean {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\n\nexport function deserialize(\n  [id, crdt]: IdTuple<SerializedCrdt>,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): LiveNode {\n  switch (crdt.type) {\n    case CrdtType.OBJECT: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.LIST: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.MAP: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.REGISTER: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\n\nexport function deserializeToLson(\n  [id, crdt]: IdTuple<SerializedCrdt>,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): Lson {\n  switch (crdt.type) {\n    case CrdtType.OBJECT: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.LIST: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.MAP: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.REGISTER: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\n\nexport function isLiveStructure(value: unknown): value is LiveStructure {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\n\nexport function isLiveNode(value: unknown): value is LiveNode {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\n\nexport function isLiveList(value: unknown): value is LiveList<Lson> {\n  return value instanceof LiveList;\n}\n\nexport function isLiveMap(value: unknown): value is LiveMap<string, Lson> {\n  return value instanceof LiveMap;\n}\n\nexport function isLiveObject(value: unknown): value is LiveObject<LsonObject> {\n  return value instanceof LiveObject;\n}\n\nexport function isLiveRegister(value: unknown): value is LiveRegister<Json> {\n  return value instanceof LiveRegister;\n}\n\nexport function cloneLson<L extends Lson | undefined>(value: L): L {\n  return value === undefined\n    ? (undefined as L)\n    : isLiveStructure(value)\n      ? (value.clone() as L)\n      : (deepClone(value) as L);\n}\n\nexport function liveNodeToLson(obj: LiveNode): Lson {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (\n    obj instanceof LiveList ||\n    obj instanceof LiveMap ||\n    obj instanceof LiveObject\n  ) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\n\nexport function lsonToLiveNode(value: Lson): LiveNode {\n  if (\n    value instanceof LiveObject ||\n    value instanceof LiveMap ||\n    value instanceof LiveList\n  ) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\n\nexport function getTreesDiffOperations(\n  currentItems: NodeMap,\n  newItems: NodeMap\n): Op[] {\n  const ops: Op[] = [];\n\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      // Delete crdt\n      ops.push({\n        type: OpCode.DELETE_CRDT,\n        id,\n      });\n    }\n  });\n\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === CrdtType.OBJECT) {\n        if (\n          currentCrdt.type !== CrdtType.OBJECT ||\n          JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)\n        ) {\n          ops.push({\n            type: OpCode.UPDATE_OBJECT,\n            id,\n            data: crdt.data,\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: OpCode.SET_PARENT_KEY,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\"),\n        });\n      }\n    } else {\n      // new Crdt\n      switch (crdt.type) {\n        case CrdtType.REGISTER:\n          ops.push({\n            type: OpCode.CREATE_REGISTER,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.LIST:\n          ops.push({\n            type: OpCode.CREATE_LIST,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n        case CrdtType.OBJECT:\n          if (crdt.parentId === undefined || crdt.parentKey === undefined) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: OpCode.CREATE_OBJECT,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.MAP:\n          ops.push({\n            type: OpCode.CREATE_MAP,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n      }\n    }\n  });\n\n  return ops;\n}\n\nfunction mergeObjectStorageUpdates<A extends LsonObject, B extends LsonObject>(\n  first: LiveObjectUpdates<A>,\n  second: LiveObjectUpdates<B>\n): LiveObjectUpdates<B> {\n  const updates = first.updates as (typeof second)[\"updates\"];\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeMapStorageUpdates<K2 extends string, V2 extends Lson>(\n  first: LiveMapUpdates<string, Lson>,\n  second: LiveMapUpdates<K2, V2>\n): LiveMapUpdates<K2, V2> {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeListStorageUpdates<T extends Lson>(\n  first: LiveListUpdates<Lson>,\n  second: LiveListUpdates<T>\n): LiveListUpdates<T> {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates),\n  };\n}\n\nexport function mergeStorageUpdates(\n  first: StorageUpdate | undefined,\n  second: StorageUpdate\n): StorageUpdate {\n  if (first === undefined) {\n    return second;\n  }\n\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n    /* Mismatching merge types. Throw an error here? */\n  }\n\n  return second;\n}\n\nfunction isPlain(\n  value: unknown\n): value is\n  | undefined\n  | null\n  | string\n  | boolean\n  | number\n  | unknown[]\n  | { [key: string]: unknown } {\n  const type = typeof value;\n  return (\n    value === undefined ||\n    value === null ||\n    type === \"string\" ||\n    type === \"boolean\" ||\n    type === \"number\" ||\n    Array.isArray(value) ||\n    isPlainObject(value)\n  );\n}\n\nexport function findNonSerializableValue(\n  value: unknown,\n  path: string = \"\"\n): { path: string; value: unknown } | false {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value,\n    };\n  }\n\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue,\n      };\n    }\n\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n\n  return false;\n}\n","export function captureStackTrace(\n  msg: string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  traceRoot?: Function\n): string | undefined {\n  // Hack: Normally browsers will add the name of the error before the stack trace (default Error).\n  // To customize this, we set the name of the error to the message we want to display.\n  const errorLike: { name: string; stack?: string } = { name: msg };\n\n  // Error.captureStackTrace is non-standard and only available in certain browsers/runtimes.\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return undefined;\n  }\n\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n","/**\n * Represents an indefinitely deep arbitrary JSON data structure. There are\n * four types that make up the Json family:\n *\n * - Json         any legal JSON value\n * - JsonScalar   any legal JSON leaf value (no lists or objects)\n * - JsonArray    a JSON value whose outer type is an array\n * - JsonObject   a JSON value whose outer type is an object\n *\n */\nexport type Json = JsonScalar | JsonArray | JsonObject;\nexport type JsonScalar = string | number | boolean | null;\nexport type JsonArray = Json[];\n/**\n * Any valid JSON object.\n */\nexport type JsonObject = { [key: string]: Json | undefined };\n\nexport function isJsonScalar(data: Json): data is JsonScalar {\n  return (\n    data === null ||\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\"\n  );\n}\n\nexport function isJsonArray(data: Json): data is JsonArray {\n  return Array.isArray(data);\n}\n\nexport function isJsonObject(data: Json): data is JsonObject {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n","import type { Json, JsonObject } from \"../lib/Json\";\nimport type { Op } from \"./Op\";\n\nexport enum ClientMsgCode {\n  // For Presence\n  UPDATE_PRESENCE = 100,\n  BROADCAST_EVENT = 103,\n\n  // For Storage\n  FETCH_STORAGE = 200,\n  UPDATE_STORAGE = 201,\n\n  // For Yjs support\n  FETCH_YDOC = 300,\n  UPDATE_YDOC = 301,\n}\n\n/**\n * Messages that can be sent from the client to the server.\n */\nexport type ClientMsg<P extends JsonObject, E extends Json> =\n  // For Presence\n  | BroadcastEventClientMsg<E>\n  | UpdatePresenceClientMsg<P>\n\n  // For Storage\n  | UpdateStorageClientMsg\n  | FetchStorageClientMsg\n\n  // For Yjs support\n  | FetchYDocClientMsg\n  | UpdateYDocClientMsg;\n\nexport type BroadcastEventClientMsg<E extends Json> = {\n  type: ClientMsgCode.BROADCAST_EVENT;\n  event: E;\n};\n\nexport type UpdatePresenceClientMsg<P extends JsonObject> =\n  //\n  // Full Presence™ message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Set this to any number to signify that this is a Full Presence™\n       * update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      readonly data: P;\n    }\n\n  //\n  // Partial Presence™ message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Absence of the `targetActor` field signifies that this is a Partial\n       * Presence™ \"patch\".\n       */\n      readonly targetActor?: undefined;\n      readonly data: Partial<P>;\n    };\n\nexport type UpdateStorageClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_STORAGE;\n  readonly ops: Op[];\n};\n\nexport type FetchStorageClientMsg = {\n  readonly type: ClientMsgCode.FETCH_STORAGE;\n};\n\nexport type FetchYDocClientMsg = {\n  readonly type: ClientMsgCode.FETCH_YDOC;\n  readonly vector: string; // base64 encoded stateVector a from yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n  readonly v2?: boolean; // if it's a v2 update\n};\n\nexport type UpdateYDocClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_YDOC;\n  readonly update: string; // base64 encoded update from a yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n  readonly v2?: boolean; // if it's a v2 update\n};\n","import { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { DerivedSignal, merge, MutableSignal } from \"../lib/signals\";\nimport { compact, compactObject } from \"../lib/utils\";\nimport { canComment, canWriteStorage } from \"../protocol/AuthToken\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { User } from \"../types/User\";\n\ntype Connection<U extends BaseUserMeta> = {\n  readonly connectionId: number;\n  readonly scopes: string[];\n  readonly id: U[\"id\"];\n  readonly info: U[\"info\"];\n};\n\nfunction makeUser<P extends JsonObject, U extends BaseUserMeta>(\n  conn: Connection<U>,\n  presence: P\n): User<P, U> {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite, // Deprecated, kept for backward-compatibility\n      presence,\n    })\n  );\n}\n\nexport class ManagedOthers<P extends JsonObject, U extends BaseUserMeta> {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  readonly #internal: MutableSignal<{\n    connections: Map</* connectionId */ number, Connection<U>>;\n    presences: Map</* connectionId */ number, P>;\n  }>;\n  readonly #userCache: Map</* connectionId */ number, User<P, U>>;\n\n  // The \"clean\" signal that is exposed to the outside world\n  public readonly signal: DerivedSignal<readonly User<P, U>[]>;\n\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: new Map</* connectionId */ number, Connection<U>>(),\n      presences: new Map</* connectionId */ number, P>(),\n    });\n\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore): readonly User<P, U>[] =>\n        compact(\n          Array.from(this.#internal.get().presences.keys()).map(\n            (connectionId) => this.getUser(Number(connectionId))\n          )\n        )\n    );\n\n    // Others\n    this.#userCache = new Map();\n  }\n\n  // Shorthand for .signal.get()\n  get(): readonly User<P, U>[] {\n    return this.signal.get();\n  }\n\n  public connectionIds(): IterableIterator<number> {\n    return this.#internal.get().connections.keys();\n  }\n\n  clearOthers(): void {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n\n  #_getUser(connectionId: number): User<P, U> | undefined {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== undefined && presence !== undefined) {\n      return makeUser(conn, presence);\n    }\n    return undefined;\n  }\n\n  getUser(connectionId: number): User<P, U> | undefined {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n\n    return undefined;\n  }\n\n  #invalidateUser(connectionId: number): void {\n    this.#userCache.delete(connectionId);\n  }\n\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(\n    connectionId: number,\n    metaUserId: U[\"id\"],\n    metaUserInfo: U[\"info\"],\n    scopes: string[]\n  ): void {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes,\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId: number): void {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId: number, presence: P): void {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId: number, patch: Partial<P>): void {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === undefined) {\n        return false;\n      }\n\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n}\n","import { assertNever } from \"../lib/assert\";\nimport type { Relax } from \"../lib/Relax\";\nimport type { BaseMetadata, CommentBody } from \"../protocol/Comments\";\nimport type { Patchable } from \"./Patchable\";\n\n// All possible error originating from using Presence, Storage, or Yjs\ntype RoomConnectionErrorContext = {\n  type: \"ROOM_CONNECTION_ERROR\";\n  code: -1 | 4001 | 4005 | 4006 | (number & {}); // eslint-disable-line @typescript-eslint/ban-types\n  roomId: string;\n};\n\n// All possible errors originating from using Comments or Notifications\ntype CommentsOrNotificationsErrorContext =\n  | {\n      type: \"CREATE_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n      metadata: BaseMetadata;\n    }\n  | {\n      type: \"DELETE_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n    }\n  | {\n      type: \"EDIT_THREAD_METADATA_ERROR\";\n      roomId: string;\n      threadId: string;\n      metadata: Patchable<BaseMetadata>;\n    }\n  | {\n      type: \"MARK_THREAD_AS_RESOLVED_ERROR\" | \"MARK_THREAD_AS_UNRESOLVED_ERROR\";\n      roomId: string;\n      threadId: string;\n    }\n  | {\n      type: \"CREATE_COMMENT_ERROR\" | \"EDIT_COMMENT_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  | {\n      type: \"DELETE_COMMENT_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n    }\n  | {\n      type: \"ADD_REACTION_ERROR\" | \"REMOVE_REACTION_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  | {\n      type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\";\n      inboxNotificationId: string;\n      roomId?: string;\n    }\n  | {\n      type: \"DELETE_INBOX_NOTIFICATION_ERROR\";\n      inboxNotificationId: string;\n    }\n  | {\n      type:\n        | \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\"\n        | \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\";\n    }\n  | {\n      type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\";\n      roomId: string;\n    };\n\nexport type LiveblocksErrorContext = Relax<\n  | RoomConnectionErrorContext // from Presence, Storage, or Yjs\n  | CommentsOrNotificationsErrorContext // from Comments or Notifications\n>;\n\nexport class LiveblocksError extends Error {\n  public readonly context: LiveblocksErrorContext;\n\n  constructor(message: string, context: LiveblocksErrorContext, cause?: Error) {\n    // @ts-expect-error This can be removed once we use lib: [\"es2022\"] in tsconfig\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId(): LiveblocksErrorContext[\"roomId\"] {\n    return this.context.roomId;\n  }\n\n  /** @deprecated Prefer using `context.code` instead, to enable type narrowing */\n  get code(): LiveblocksErrorContext[\"code\"] {\n    return this.context.code;\n  }\n\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context: LiveblocksErrorContext, cause?: Error): LiveblocksError {\n    return new LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n}\n\n/**\n * Return a default, human-friendly error message for each possible error.\n */\nfunction defaultMessageFromContext(context: LiveblocksErrorContext): string {\n  // prettier-ignore\n  switch (context.type) {\n    case \"ROOM_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001: return \"Not allowed to connect to the room\";\n        case 4005: return \"Room is already full\";\n        case 4006: return \"Kicked out of the room, because the room ID changed\";\n        default:   return \"Could not connect to the room\";\n      }\n    }\n\n    case \"CREATE_THREAD_ERROR\": return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\": return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\": return \"Could not edit thread metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\": return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\": return \"Could not mark thread as unresolved\";\n    case \"CREATE_COMMENT_ERROR\": return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\": return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\": return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\": return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\": return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\": return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\": return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\": return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\": return \"Could not delete all inbox notifications\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\": return \"Could not update notification settings\";\n\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n","import { getBearerTokenFromAuthValue, type RoomHttpApi } from \"./api-client\";\nimport type { AuthManager, AuthValue } from \"./auth-manager\";\nimport type { InternalSyncStatus } from \"./client\";\nimport type { Delegates, LostConnectionEvent, Status } from \"./connection\";\nimport { ManagedSocket, StopRetrying } from \"./connection\";\nimport type { ApplyResult, ManagedPool } from \"./crdts/AbstractCrdt\";\nimport { OpSource } from \"./crdts/AbstractCrdt\";\nimport {\n  cloneLson,\n  getTreesDiffOperations,\n  isLiveList,\n  isLiveNode,\n  isSameNodeOrChildOf,\n  mergeStorageUpdates,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport type { LiveNode, LiveStructure, LsonObject } from \"./crdts/Lson\";\nimport type { StorageCallback, StorageUpdate } from \"./crdts/StorageUpdates\";\nimport type { DE, DM, DP, DS, DU } from \"./globals/augmentation\";\nimport { kInternal } from \"./internal\";\nimport { assertNever, nn } from \"./lib/assert\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Promise_withResolvers } from \"./lib/controlledPromise\";\nimport { createCommentAttachmentId } from \"./lib/createIds\";\nimport { captureStackTrace } from \"./lib/debug\";\nimport type { Callback, EventSource, Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonArray, isJsonObject } from \"./lib/Json\";\nimport { asPos } from \"./lib/position\";\nimport { DerivedSignal, PatchableSignal, Signal } from \"./lib/signals\";\nimport {\n  compact,\n  deepClone,\n  memoizeOnSuccess,\n  tryParseJson,\n} from \"./lib/utils\";\nimport type { Permission } from \"./protocol/AuthToken\";\nimport { canComment, canWriteStorage, TokenKind } from \"./protocol/AuthToken\";\nimport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nimport type { ClientMsg, UpdateYDocClientMsg } from \"./protocol/ClientMsg\";\nimport { ClientMsgCode } from \"./protocol/ClientMsg\";\nimport type {\n  BaseMetadata,\n  CommentAttachment,\n  CommentBody,\n  CommentData,\n  CommentLocalAttachment,\n  CommentUserReaction,\n  QueryMetadata,\n  ThreadData,\n  ThreadDeleteInfo,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n} from \"./protocol/InboxNotifications\";\nimport type { Op } from \"./protocol/Op\";\nimport { isAckOp, OpCode } from \"./protocol/Op\";\nimport type { IdTuple, SerializedCrdt } from \"./protocol/SerializedCrdt\";\nimport type {\n  CommentsEventServerMsg,\n  InitialDocumentStateServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  UpdatePresenceServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type { HistoryVersion } from \"./protocol/VersionHistory\";\nimport { ManagedOthers } from \"./refs/ManagedOthers\";\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nimport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport { LiveblocksError } from \"./types/LiveblocksError\";\nimport type { NodeMap } from \"./types/NodeMap\";\nimport type {\n  InternalOthersEvent,\n  OthersEvent,\n  TextEditorType,\n} from \"./types/Others\";\nimport type { Patchable } from \"./types/Patchable\";\nimport type { RoomNotificationSettings } from \"./types/RoomNotificationSettings\";\nimport type { User } from \"./types/User\";\nimport { PKG_VERSION } from \"./version\";\n\ntype TimeoutID = ReturnType<typeof setTimeout>;\n\n//\n// NOTE:\n// This type looks an awful lot like InternalOthersEvent, but don't change this\n// type definition or DRY this up!\n// The type LegacyOthersEvent is used in the signature of some public APIs, and\n// as such should remain backward compatible.\n//\ntype LegacyOthersEvent<P extends JsonObject, U extends BaseUserMeta> =\n  | { type: \"leave\"; user: User<P, U> }\n  | { type: \"enter\"; user: User<P, U> }\n  | {\n      type: \"update\";\n      user: User<P, U>;\n      updates: Partial<P>;\n    }\n  | { type: \"reset\" };\n\ntype LegacyOthersEventCallback<P extends JsonObject, U extends BaseUserMeta> = (\n  others: readonly User<P, U>[],\n  event: LegacyOthersEvent<P, U>\n) => void;\n\nexport type RoomEventMessage<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * The connection ID of the client that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be -1.\n   */\n  connectionId: number;\n  /**\n   * The User (from the others list) that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be null.\n   */\n  user: User<P, U> | null;\n  event: E;\n};\n\nexport type SyncStatus =\n  /* Liveblocks is in the process of writing changes */\n  | \"synchronizing\"\n  /* Liveblocks has persisted all pending changes */\n  | \"synchronized\";\n\nexport type StorageStatus =\n  /* The storage is not loaded and has not been requested. */\n  | \"not-loaded\"\n  /* The storage is loading from Liveblocks servers */\n  | \"loading\"\n  /* Some storage modifications has not been acknowledged yet by the server */\n  | \"synchronizing\"\n  /* The storage is sync with Liveblocks servers */\n  | \"synchronized\";\n\ntype RoomEventCallbackMap<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  status: Callback<Status>; // New/recommended API\n  \"lost-connection\": Callback<LostConnectionEvent>;\n  event: Callback<RoomEventMessage<P, U, E>>;\n  \"my-presence\": Callback<P>;\n  //\n  // NOTE: LegacyOthersEventCallback is the only one not taking a Callback<T>\n  // shape, since this API historically has taken _two_ callback arguments\n  // instead of just one.\n  others: LegacyOthersEventCallback<P, U>;\n  error: Callback<Error>;\n  history: Callback<HistoryEvent>;\n  \"storage-status\": Callback<StorageStatus>;\n  comments: Callback<CommentsEventServerMsg>;\n};\n\nexport interface History {\n  /**\n   * Undoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   */\n  undo: () => void;\n\n  /**\n   * Redoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   * room.history.redo();\n   * // room.getPresence() equals { selectedId: \"yy\" }\n   */\n  redo: () => void;\n\n  /**\n   * Returns whether there are any operations to undo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * // room.history.canUndo() is true\n   * room.history.undo();\n   * // room.history.canUndo() is false\n   */\n  canUndo: () => boolean;\n\n  /**\n   * Returns whether there are any operations to redo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.history.canRedo() is true\n   * room.history.redo();\n   * // room.history.canRedo() is false\n   */\n  canRedo: () => boolean;\n\n  /**\n   * Clears the undo and redo stacks. This operation cannot be undone ;)\n   */\n  clear: () => void;\n\n  /**\n   * All future modifications made on the Room will be merged together to create a single history item until resume is called.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  pause: () => void;\n\n  /**\n   * Resumes history. Modifications made on the Room are not merged into a single history item anymore.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  resume: () => void;\n}\n\nexport type HistoryEvent = {\n  canUndo: boolean;\n  canRedo: boolean;\n};\n\nexport type RoomEventName = Extract<\n  keyof RoomEventCallbackMap<never, never, never>,\n  string\n>;\n\nexport type RoomEventCallbackFor<\n  K extends RoomEventName,\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = RoomEventCallbackMap<P, U, E>[K];\n\nexport type RoomEventCallback = RoomEventCallbackFor<\n  RoomEventName,\n  JsonObject,\n  BaseUserMeta,\n  Json\n>;\n\nexport type BroadcastOptions = {\n  /**\n   * Whether or not event is queued if the connection is currently closed.\n   *\n   * ❗ We are not sure if we want to support this option in the future so it might be deprecated to be replaced by something else\n   */\n  shouldQueueEventIfNotReady: boolean;\n};\n\ntype SubscribeFn<\n  P extends JsonObject,\n  _TStorage extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * Subscribes to changes made on any Live structure. Returns an unsubscribe function.\n   *\n   * @internal This legacy API works, but was never documented publicly.\n   */\n  (callback: StorageCallback): () => void;\n\n  /**\n   * Subscribe to the current user presence updates.\n   *\n   * @param listener the callback that is called every time the current user presence is updated with {@link Room.updatePresence}.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"my-presence\", (presence) => {\n   *   // Do something\n   * });\n   */\n  (type: \"my-presence\", listener: Callback<P>): () => void;\n\n  /**\n   * Subscribe to the other users updates.\n   *\n   * @param listener the callback that is called when a user enters or leaves the room or when a user update its presence.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"others\", (others) => {\n   *   // Do something\n   * });\n   *\n   */\n  (type: \"others\", listener: LegacyOthersEventCallback<P, U>): () => void;\n\n  /**\n   * Subscribe to events broadcasted by {@link Room.broadcastEvent}\n   *\n   * @param listener the callback that is called when a user calls {@link Room.broadcastEvent}\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"event\", ({ event, connectionId }) => {\n   *   // Do something\n   * });\n   *\n   */\n  (type: \"event\", listener: Callback<RoomEventMessage<P, U, E>>): () => void;\n\n  /**\n   * Subscribe to errors thrown in the room.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"error\", listener: Callback<LiveblocksError>): () => void;\n\n  /**\n   * Subscribe to connection status updates. The callback will be called any\n   * time the status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"status\", listener: Callback<Status>): () => void;\n\n  /**\n   * Subscribe to the exceptional event where reconnecting to the Liveblocks\n   * servers is taking longer than usual. This typically is a sign of a client\n   * that has lost internet connectivity.\n   *\n   * This isn't problematic (because the Liveblocks client is still trying to\n   * reconnect), but it's typically a good idea to inform users about it if\n   * the connection takes too long to recover.\n   */\n  (\n    type: \"lost-connection\",\n    listener: Callback<LostConnectionEvent>\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure. Returns an unsubscribe function.\n   *\n   * @param callback The callback this called when the Live structure changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (liveMap) => { });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: (node: L) => void\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure and all the nested data\n   * structures. Returns an unsubscribe function. In a future version, we\n   * will also expose what exactly changed in the Live structure.\n   *\n   * @param callback The callback this called when the Live structure, or any\n   * of its nested values, changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (updates) => { }, { isDeep: true });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: StorageCallback,\n    options: { isDeep: true }\n  ): () => void;\n\n  /**\n   * Subscribe to the current user's history changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"history\", ({ canUndo, canRedo }) => {\n   *   // Do something\n   * });\n   */\n  (type: \"history\", listener: Callback<HistoryEvent>): () => void;\n\n  /**\n   * Subscribe to storage status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"storage-status\", (status) => {\n   *   switch(status) {\n   *      case \"not-loaded\":\n   *        break;\n   *      case \"loading\":\n   *        break;\n   *      case \"synchronizing\":\n   *        break;\n   *      case \"synchronized\":\n   *        break;\n   *      default:\n   *        break;\n   *   }\n   * });\n   */\n  (type: \"storage-status\", listener: Callback<StorageStatus>): () => void;\n\n  (type: \"comments\", listener: Callback<CommentsEventServerMsg>): () => void;\n};\n\nexport type GetThreadsOptions<M extends BaseMetadata> = {\n  cursor?: string;\n  query?: {\n    resolved?: boolean;\n    metadata?: Partial<QueryMetadata<M>>;\n  };\n};\n\nexport type GetThreadsSinceOptions = {\n  since: Date;\n  signal?: AbortSignal;\n};\n\nexport type UploadAttachmentOptions = {\n  signal?: AbortSignal;\n};\n\ntype ListTextVersionsSinceOptions = {\n  since: Date;\n  signal?: AbortSignal;\n};\n\ntype GetNotificationSettingsOptions = {\n  signal?: AbortSignal;\n};\n\n/**\n * @private Widest-possible Room type, matching _any_ Room instance. Note that\n * this type is different from `Room`-without-type-arguments. That represents\n * a Room instance using globally augmented types only, which is narrower.\n */\nexport type OpaqueRoom = Room<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  Json,\n  BaseMetadata\n>;\n\nexport type Room<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n> = {\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  readonly [kInternal]: PrivateRoomApi;\n\n  /**\n   * The id of the room.\n   */\n  readonly id: string;\n\n  /**\n   * Return the current connection status for this room. Can be used to display\n   * a status badge for your Liveblocks connection.\n   */\n  getStatus(): Status;\n  readonly subscribe: SubscribeFn<P, S, U, E>;\n\n  /**\n   * Room's history contains functions that let you undo and redo operation made on by the current client on the presence and storage.\n   */\n  readonly history: History;\n\n  /**\n   * Gets the current user.\n   * Returns null if not it is not yet connected to the room.\n   *\n   * @example\n   * const user = room.getSelf();\n   */\n  getSelf(): User<P, U> | null;\n\n  /**\n   * Gets the presence of the current user.\n   *\n   * @example\n   * const presence = room.getPresence();\n   */\n  getPresence(): P;\n\n  /**\n   * Gets all the other users in the room.\n   *\n   * @example\n   * const others = room.getOthers();\n   */\n  getOthers(): readonly User<P, U>[];\n\n  /**\n   * Updates the presence of the current user. Only pass the properties you want to update. No need to send the full presence.\n   * @param patch A partial object that contains the properties you want to update.\n   * @param options Optional object to configure the behavior of updatePresence.\n   *\n   * @example\n   * room.updatePresence({ x: 0 });\n   * room.updatePresence({ y: 0 });\n   *\n   * const presence = room.getPresence();\n   * // presence is equivalent to { x: 0, y: 0 }\n   */\n  updatePresence(\n    patch: Partial<P>,\n    options?: {\n      /**\n       * Whether or not the presence should have an impact on the undo/redo history.\n       */\n      addToHistory: boolean;\n    }\n  ): void;\n\n  /**\n   * Sends Yjs document updates to Liveblocks server.\n   *\n   * @param {string} data the doc update to send to the server, base64 encoded uint8array\n   */\n  updateYDoc(data: string, guid?: string, isV2?: boolean): void;\n\n  /**\n   * Sends a request for the current document from liveblocks server\n   */\n  fetchYDoc(stateVector: string, guid?: string, isV2?: boolean): void;\n\n  /**\n   * Broadcasts an event to other users in the room. Event broadcasted to the room can be listened with {@link Room.subscribe}(\"event\").\n   * @param {any} event the event to broadcast. Should be serializable to JSON\n   *\n   * @example\n   * // On client A\n   * room.broadcastEvent({ type: \"EMOJI\", emoji: \"🔥\" });\n   *\n   * // On client B\n   * room.subscribe(\"event\", ({ event }) => {\n   *   if(event.type === \"EMOJI\") {\n   *     // Do something\n   *   }\n   * });\n   */\n  broadcastEvent(event: E, options?: BroadcastOptions): void;\n\n  /**\n   * Get the room's storage asynchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   */\n  getStorage(): Promise<{\n    root: LiveObject<S>;\n  }>;\n\n  /**\n   * Get the room's storage synchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const root = room.getStorageSnapshot();\n   */\n  getStorageSnapshot(): LiveObject<S> | null;\n\n  /**\n   * All possible room events, subscribable from a single place.\n   *\n   * @private These event sources are private for now, but will become public\n   * once they're stable.\n   */\n  readonly events: {\n    readonly status: Observable<Status>;\n    readonly lostConnection: Observable<LostConnectionEvent>;\n\n    readonly customEvent: Observable<RoomEventMessage<P, U, E>>; // prettier-ignore\n    readonly self: Observable<User<P, U>>;\n    readonly myPresence: Observable<P>;\n    readonly others: Observable<OthersEvent<P, U>>;\n    /**\n     * @deprecated Renamed to `storageBatch`. The `storage` event source will\n     * soon be replaced by another/incompatible API.\n     */\n    readonly storage: Observable<StorageUpdate[]>;\n    readonly storageBatch: Observable<StorageUpdate[]>;\n    readonly history: Observable<HistoryEvent>;\n\n    /**\n     * Subscribe to the storage loaded event. Will fire any time a full Storage\n     * copy is downloaded. (This happens after the initial connect, and on\n     * every reconnect.)\n     */\n    readonly storageDidLoad: Observable<void>;\n\n    readonly storageStatus: Observable<StorageStatus>;\n    readonly ydoc: Observable<YDocUpdateServerMsg | UpdateYDocClientMsg>;\n    readonly comments: Observable<CommentsEventServerMsg>;\n  };\n\n  /**\n   * Batches modifications made during the given function.\n   * All the modifications are sent to other clients in a single message.\n   * All the subscribers are called only after the batch is over.\n   * All the modifications are merged in a single history item (undo/redo).\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   * room.batch(() => {\n   *   root.set(\"x\", 0);\n   *   room.updatePresence({ cursor: { x: 100, y: 100 }});\n   * });\n   */\n  batch<T>(fn: () => T): T;\n\n  /**\n   * Get the storage status.\n   *\n   * - `not-loaded`: Initial state when entering the room.\n   * - `loading`: Once the storage has been requested via room.getStorage().\n   * - `synchronizing`: When some local updates have not been acknowledged by Liveblocks servers.\n   * - `synchronized`: Storage is in sync with Liveblocks servers.\n   */\n  getStorageStatus(): StorageStatus;\n\n  isPresenceReady(): boolean;\n  isStorageReady(): boolean;\n\n  /**\n   * Returns a Promise that resolves as soon as Presence is available, which\n   * happens shortly after the WebSocket connection has been established. Once\n   * this happens, `self` and `others` are known and available to use. After\n   * awaiting this promise, `.isPresenceReady()` will be guaranteed to be true.\n   * Even when calling this function multiple times, it's guaranteed to return\n   * the same Promise instance.\n   */\n  waitUntilPresenceReady(): Promise<void>;\n\n  /**\n   * Returns a Promise that resolves as soon as Storage has been loaded and\n   * available. After awaiting this promise, `.isStorageReady()` will be\n   * guaranteed to be true. Even when calling this function multiple times,\n   * it's guaranteed to return the same Promise instance.\n   */\n  waitUntilStorageReady(): Promise<void>;\n\n  /**\n   * Start an attempt to connect the room (aka \"enter\" it). Calling\n   * `.connect()` only has an effect if the room is still in its idle initial\n   * state, or the room was explicitly disconnected, or reconnection attempts\n   * were stopped (for example, because the user isn't authorized to enter the\n   * room). Will be a no-op otherwise.\n   */\n  connect(): void;\n\n  /**\n   * Disconnect the room's connection to the Liveblocks server, if any. Puts\n   * the room back into an idle state. It will not do anything until either\n   * `.connect()` or `.reconnect()` is called.\n   *\n   * Only use this API if you wish to connect the room again at a later time.\n   * If you want to disconnect the room because you no longer need it, call\n   * `.destroy()` instead.\n   */\n  disconnect(): void;\n\n  /**\n   * @internal (for now)\n   *\n   * Disconnect the room's connection to the Liveblocks server, if any. Runs\n   * cleanup functions. The room instance can no longer be used to (re)connect.\n   */\n  destroy(): void;\n\n  /**\n   * Reconnect the room to the Liveblocks server by re-establishing a fresh\n   * connection. If the room is not connected yet, initiate it.\n   */\n  reconnect(): void;\n\n  /**\n   * Returns the threads within the current room and their associated inbox notifications.\n   * It also returns the request date that can be used for subsequent polling.\n   *\n   * @example\n   * const {\n   *   threads,\n   *   inboxNotifications,\n   *   requestedAt\n   * } = await room.getThreads({ query: { resolved: false }});\n   */\n  getThreads(options?: GetThreadsOptions<M>): Promise<{\n    threads: ThreadData<M>[];\n    inboxNotifications: InboxNotificationData[];\n    requestedAt: Date;\n    nextCursor: string | null;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  /**\n   * Returns the updated and deleted threads and their associated inbox notifications since the requested date.\n   *\n   * @example\n   * const result = await room.getThreads();\n   * // ... //\n   * await room.getThreadsSince({ since: result.requestedAt });\n   */\n  getThreadsSince(options: GetThreadsSinceOptions): Promise<{\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  /**\n   * Returns a thread and the associated inbox notification if it exists.\n   *\n   * @example\n   * const { thread, inboxNotification } = await room.getThread(\"th_xxx\");\n   */\n  getThread(threadId: string): Promise<{\n    thread?: ThreadData<M>;\n    inboxNotification?: InboxNotificationData;\n  }>;\n\n  /**\n   * Creates a thread.\n   *\n   * @example\n   * const thread = await room.createThread({\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * })\n   */\n  createThread(options: {\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<ThreadData<M>>;\n\n  /**\n   * Deletes a thread.\n   *\n   * @example\n   * await room.deleteThread(\"th_xxx\");\n   */\n  deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Edits a thread's metadata.\n   * To delete an existing metadata property, set its value to `null`.\n   *\n   * @example\n   * await room.editThreadMetadata({ threadId: \"th_xxx\", metadata: { x: 100, y: 100 } })\n   */\n  editThreadMetadata(options: {\n    metadata: Patchable<M>;\n    threadId: string;\n  }): Promise<M>;\n\n  /**\n   * Marks a thread as resolved.\n   *\n   * @example\n   * await room.markThreadAsResolved(\"th_xxx\");\n   */\n  markThreadAsResolved(threadId: string): Promise<void>;\n\n  /**\n   * Marks a thread as unresolved.\n   *\n   * @example\n   * await room.markThreadAsUnresolved(\"th_xxx\");\n   */\n  markThreadAsUnresolved(threadId: string): Promise<void>;\n\n  /**\n   * Creates a comment.\n   *\n   * @example\n   * await room.createComment({\n   *   threadId: \"th_xxx\",\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * });\n   */\n  createComment(options: {\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  /**\n   * Edits a comment.\n   *\n   * @example\n   * await room.editComment({\n   *   threadId: \"th_xxx\",\n   *   commentId: \"cm_xxx\"\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * });\n   */\n  editComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  /**\n   * Deletes a comment.\n   * If it is the last non-deleted comment, the thread also gets deleted.\n   *\n   * @example\n   * await room.deleteComment({\n   *   threadId: \"th_xxx\",\n   *   commentId: \"cm_xxx\"\n   * });\n   */\n  deleteComment(options: {\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  /**\n   * Adds a reaction from a comment for the current user.\n   *\n   * @example\n   * await room.addReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n   */\n  addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<CommentUserReaction>;\n\n  /**\n   * Removes a reaction from a comment.\n   *\n   * @example\n   * await room.removeReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n   */\n  removeReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  /**\n   * Creates a local attachment from a file.\n   *\n   * @example\n   * room.prepareAttachment(file);\n   */\n  prepareAttachment(file: File): CommentLocalAttachment;\n\n  /**\n   * Uploads a local attachment.\n   *\n   * @example\n   * const attachment = room.prepareAttachment(file);\n   * await room.uploadAttachment(attachment);\n   */\n  uploadAttachment(\n    attachment: CommentLocalAttachment,\n    options?: UploadAttachmentOptions\n  ): Promise<CommentAttachment>;\n\n  /**\n   * Returns a presigned URL for an attachment by its ID.\n   *\n   * @example\n   * await room.getAttachmentUrl(\"at_xxx\");\n   */\n  getAttachmentUrl(attachmentId: string): Promise<string>;\n\n  /**\n   * Gets the user's notification settings for the current room.\n   *\n   * @example\n   * const settings = await room.getNotificationSettings();\n   */\n  getNotificationSettings(\n    options?: GetNotificationSettingsOptions\n  ): Promise<RoomNotificationSettings>;\n\n  /**\n   * Updates the user's notification settings for the current room.\n   *\n   * @example\n   * await room.updateNotificationSettings({ threads: \"replies_and_mentions\" });\n   */\n  updateNotificationSettings(\n    settings: Partial<RoomNotificationSettings>\n  ): Promise<RoomNotificationSettings>;\n\n  /**\n   * Internal use only. Signature might change in the future.\n   */\n  markInboxNotificationAsRead(notificationId: string): Promise<void>;\n};\n\nexport type YjsSyncStatus = \"loading\" | \"synchronizing\" | \"synchronized\";\n\n/**\n * Interface that @liveblocks/yjs must respect.\n * This interface type is declare in @liveblocks/core, so we don't have to\n * depend on `yjs`. It's only used to determine the API contract between\n * @liveblocks/core and @liveblocks/yjs.\n */\nexport interface IYjsProvider {\n  synced: boolean;\n  getStatus: () => YjsSyncStatus;\n  on(event: \"sync\", listener: (synced: boolean) => void): void;\n  on(event: \"status\", listener: (status: YjsSyncStatus) => void): void;\n  off(event: \"sync\", listener: (synced: boolean) => void): void;\n  off(event: \"status\", listener: (status: YjsSyncStatus) => void): void;\n}\n\n/**\n * A \"Sync Source\" can be a Storage document, a Yjs document, Comments,\n * Notifications, etc.\n * The Client keeps a registry of all active sync sources, and will use it to\n * determine the global \"sync status\" for Liveblocks.\n */\nexport interface SyncSource {\n  setSyncStatus(status: InternalSyncStatus): void;\n  destroy(): void;\n}\n\n/**\n * @private\n *\n * Private methods to directly control the underlying state machine for this\n * room. Used in the core internals and for unit testing, but as a user of\n * Liveblocks, NEVER USE ANY OF THESE METHODS DIRECTLY, because bad things\n * will probably happen if you do.\n */\nexport type PrivateRoomApi = {\n  // For introspection in unit tests only\n  presenceBuffer: Json | undefined;\n  undoStack: readonly (readonly Readonly<HistoryOp<JsonObject>>[])[];\n  nodeCount: number;\n\n  // Get/set the associated Yjs provider on this room\n  getYjsProvider(): IYjsProvider | undefined;\n  setYjsProvider(provider: IYjsProvider | undefined): void;\n  yjsProviderDidChange: Observable<void>;\n\n  // For DevTools support (Liveblocks browser extension)\n  getSelf_forDevTools(): DevTools.UserTreeNode | null;\n  getOthers_forDevTools(): readonly DevTools.UserTreeNode[];\n\n  // For reporting editor metadata\n  reportTextEditor(editor: TextEditorType, rootKey: string): Promise<void>;\n\n  createTextMention(userId: string, mentionId: string): Promise<void>;\n  deleteTextMention(mentionId: string): Promise<void>;\n  listTextVersions(): Promise<{\n    versions: HistoryVersion[];\n    requestedAt: Date;\n  }>;\n  listTextVersionsSince(options: ListTextVersionsSinceOptions): Promise<{\n    versions: HistoryVersion[];\n    requestedAt: Date;\n  }>;\n\n  getTextVersion(versionId: string): Promise<Response>;\n  createTextVersion(): Promise<void>;\n\n  // NOTE: These are only used in our e2e test app!\n  simulate: {\n    explicitClose(event: IWebSocketCloseEvent): void;\n    rawSend(data: string): void;\n  };\n\n  attachmentUrlsStore: BatchStore<string, string>;\n};\n\n// The maximum message size on websockets is 1MB. We'll set the threshold\n// slightly lower (1kB) to trigger sending over HTTP, to account for messaging\n// overhead, so we're not right at the limit.\n// NOTE: this only works with the unstable_fallbackToHTTP option enabled\nconst MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\n\nfunction makeIdFactory(connectionId: number): IdFactory {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\n\ntype HistoryOp<P extends JsonObject> =\n  | Op\n  | {\n      readonly type: \"presence\";\n      readonly data: P;\n    };\n\ntype IdFactory = () => string;\n\ntype StaticSessionInfo = {\n  readonly userId?: string;\n  readonly userInfo?: IUserInfo;\n};\n\ntype DynamicSessionInfo = {\n  readonly actor: number;\n  readonly nonce: string;\n  readonly scopes: string[];\n};\n\ntype RoomState<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * All pending changes that yet need to be synced.\n   */\n  buffer: {\n    flushTimerID: TimeoutID | undefined;\n\n    // When the last flush happened. Together with config.throttleDelay, this\n    // will control whether the next flush will be sent out immediately, or if\n    // a flush will get scheduled for a few milliseconds into the future.\n    readonly lastFlushedAt: number;\n\n    // Queued-up \"my presence\" updates to be flushed at the earliest convenience\n    presenceUpdates:\n      | { type: \"partial\"; data: Partial<P> }\n      | { type: \"full\"; data: P }\n      | null;\n    messages: ClientMsg<P, E>[];\n    storageOperations: Op[];\n  };\n\n  //\n  // The \"self\" User takes assembly of three sources-of-truth:\n  // - The JWT token provides the userId and userInfo metadata (static)\n  // - The server, in its initial ROOM_STATE message, will provide the actor ID\n  //   and the scopes (dynamic)\n  // - The presence is provided by the client's initialPresence configuration (presence)\n  //\n  readonly staticSessionInfoSig: Signal<StaticSessionInfo | null>;\n  readonly dynamicSessionInfoSig: Signal<DynamicSessionInfo | null>;\n  readonly myPresence: PatchableSignal<P>;\n  readonly others: ManagedOthers<P, U>;\n\n  idFactory: IdFactory | null;\n  initialStorage: S;\n\n  yjsProvider: IYjsProvider | undefined;\n  readonly yjsProviderDidChange: EventSource<void>;\n\n  clock: number;\n  opClock: number;\n  readonly nodes: Map<string, LiveNode>;\n  root: LiveObject<S> | undefined;\n\n  readonly undoStack: HistoryOp<P>[][];\n  readonly redoStack: HistoryOp<P>[][];\n\n  /**\n   * When history is paused, all operations will get queued up here. When\n   * history is resumed, these operations get \"committed\" to the undo stack.\n   */\n  pausedHistory: null | HistoryOp<P>[];\n\n  /**\n   * Place to collect all mutations during a batch. Ops will be sent over the\n   * wire after the batch is ended.\n   */\n  activeBatch: {\n    ops: Op[];\n    reverseOps: HistoryOp<P>[];\n    updates: {\n      others: [];\n      presence: boolean;\n      storageUpdates: Map<string, StorageUpdate>;\n    };\n  } | null;\n\n  // A registry of yet-unacknowledged Ops. These Ops have already been\n  // submitted to the server, but have not yet been acknowledged.\n  readonly unacknowledgedOps: Map<string, Op>;\n\n  // Stack traces of all pending Ops. Used for debugging in non-production builds\n  readonly opStackTraces?: Map<string, string>;\n};\n\nexport type Polyfills = {\n  atob?: (data: string) => string;\n  fetch?: typeof fetch;\n  WebSocket?: IWebSocket;\n};\n\n/**\n * Makes all tuple positions optional.\n * Example, turns:\n *   [foo: string; bar: number]\n * into:\n *   [foo?: string; bar?: number]\n */\ntype OptionalTuple<T extends any[]> = { [K in keyof T]?: T[K] };\n\n/**\n * Returns Partial<T> if all fields on C are optional, T otherwise.\n */\nexport type PartialUnless<C, T> =\n  Record<string, never> extends C\n    ? Partial<T>\n    : // Extra test. We'll want to treat \"never\" as if the empty object is\n      // assignable to it, because otherwise it will not\n      [C] extends [never]\n      ? Partial<T>\n      : T;\n\n/**\n * Returns OptionalTupleUnless<T> if all fields on C are optional, T otherwise.\n */\nexport type OptionalTupleUnless<C, T extends any[]> =\n  Record<string, never> extends C\n    ? OptionalTuple<T>\n    : // Extra test. We'll want to treat \"never\" as if the empty object is\n      // assignable to it, because otherwise it will not\n      [C] extends [never]\n      ? OptionalTuple<T>\n      : T;\n\nexport type RoomDelegates = Omit<Delegates<AuthValue>, \"canZombie\">;\n\n/** @internal */\nexport type RoomConfig<M extends BaseMetadata> = {\n  delegates: RoomDelegates;\n\n  roomId: string;\n  throttleDelay: number;\n  lostConnectionTimeout: number;\n  backgroundKeepAliveTimeout?: number;\n\n  unstable_fallbackToHTTP?: boolean;\n  unstable_streamData?: boolean;\n\n  polyfills?: Polyfills;\n\n  roomHttpClient: RoomHttpApi<M>;\n\n  baseUrl: string;\n  enableDebugLogging?: boolean;\n\n  // We would not have to pass this complicated factory/callback functions to\n  // the createRoom() function if we would simply pass the Client instance to\n  // the Room instance, so it can directly call this back on the Client.\n  createSyncSource: () => SyncSource;\n  errorEventSource: EventSource<LiveblocksError>;\n};\n\nfunction userToTreeNode(\n  key: string,\n  user: User<JsonObject, BaseUserMeta>\n): DevTools.UserTreeNode {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite,\n    },\n  };\n}\n\n/**\n * Returns a ref to access if, and if so, how long the current tab is in the\n * background and an unsubscribe function.\n *\n * The `inBackgroundSince` value will either be a JS timestamp indicating the\n * moment the tab was put into the background, or `null` in case the tab isn't\n * currently in the background. In non-DOM environments, this will always\n * return `null`.\n */\nfunction installBackgroundTabSpy(): [\n  inBackgroundSince: { readonly current: number | null },\n  unsub: () => void,\n] {\n  const doc = typeof document !== \"undefined\" ? document : undefined;\n  const inBackgroundSince: { current: number | null } = { current: null };\n\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n\n  return [inBackgroundSince, unsub];\n}\n\n/**\n * @internal\n * Initializes a new Room, and returns its public API.\n */\nexport function createRoom<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(\n  options: { initialPresence: P; initialStorage: S },\n  config: RoomConfig<M>\n): Room<P, S, U, E, M> {\n  const initialPresence = options.initialPresence; // ?? {};\n  const initialStorage = options.initialStorage; // ?? {};\n\n  const httpClient = config.roomHttpClient;\n\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n\n  // Create a delegate pair for (a specific) Live Room socket connection(s)\n  const delegates = {\n    ...config.delegates,\n\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return (\n        config.backgroundKeepAliveTimeout !== undefined &&\n        inBackgroundSince.current !== null &&\n        Date.now() >\n          inBackgroundSince.current + config.backgroundKeepAliveTimeout &&\n        getStorageStatus() !== \"synchronizing\"\n      );\n    },\n  };\n\n  const managedSocket: ManagedSocket<AuthValue> = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n\n  // The room's internal stateful context\n  const context: RoomState<P, S, U, E> = {\n    buffer: {\n      flushTimerID: undefined,\n      lastFlushedAt: 0,\n      presenceUpdates:\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence,\n        },\n      messages: [],\n      storageOperations: [],\n    },\n\n    staticSessionInfoSig: new Signal<StaticSessionInfo | null>(null),\n    dynamicSessionInfoSig: new Signal<DynamicSessionInfo | null>(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers<P, U>(),\n\n    initialStorage,\n    idFactory: null,\n\n    // The Yjs provider associated to this room\n    yjsProvider: undefined,\n    yjsProviderDidChange: makeEventSource(),\n\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: new Map<string, LiveNode>(),\n    root: undefined,\n\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n\n    activeBatch: null,\n    unacknowledgedOps: new Map<string, Op>(),\n\n    // Debug\n    opStackTraces:\n      process.env.NODE_ENV !== \"production\"\n        ? new Map<string, string>()\n        : undefined,\n  };\n\n  let lastTokenKey: string | undefined;\n  function onStatusDidChange(newStatus: Status) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === TokenKind.SECRET_LEGACY ? token.id : token.uid,\n            userInfo:\n              token.k === TokenKind.SECRET_LEGACY ? token.info : token.ui,\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: undefined,\n            userInfo: undefined,\n          });\n        }\n      }\n    }\n\n    // Forward to the outside world\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n\n  let _connectionLossTimerId: TimeoutID | undefined;\n  let _hasLostConnection = false;\n\n  function handleConnectionLossEvent(newStatus: Status) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n\n        // Clear the others\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          // Typically the case when going back to \"connected\", but really take\n          // *any* other state change as a recovery sign\n          eventHub.lostConnection.notify(\"restored\");\n        }\n\n        _hasLostConnection = false;\n      }\n    }\n  }\n\n  function onDidConnect() {\n    // Re-broadcast the full user presence as soon as we (re)connect\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data:\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() },\n    };\n\n    // NOTE: There was a flush here before, but I don't think it's really\n    // needed anymore. We're now combining this flush with the one below, to\n    // combine them in a single batch.\n    // tryFlushing();\n\n    // If a storage fetch has ever been initiated, we assume the client is\n    // interested in storage, so we will refresh it after a reconnection.\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n\n  // Register events handlers for events coming from the socket\n  // We never have to unsubscribe, because the Room and the Connection Manager\n  // will have the same life-time.\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n\n  const pool: ManagedPool = {\n    roomId: config.roomId,\n\n    getNode: (id: string) => context.nodes.get(id),\n    addNode: (id: string, node: LiveNode) => void context.nodes.set(id, node),\n    deleteNode: (id: string) => void context.nodes.delete(id),\n\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n\n    dispatch(\n      ops: Op[],\n      reverse: Op[],\n      storageUpdates: Map<string, StorageUpdate>\n    ) {\n      const activeBatch = context.activeBatch;\n\n      if (process.env.NODE_ENV !== \"production\") {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        addToUndoStack(reverse);\n        context.redoStack.length = 0;\n        dispatchOps(ops);\n        notify({ storageUpdates });\n      }\n    },\n\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n      if (scopes === undefined) {\n        // If we aren't connected yet, assume we can write\n        return;\n      }\n\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    },\n  };\n\n  const eventHub = {\n    status: makeEventSource<Status>(), // New/recommended API\n    lostConnection: makeEventSource<LostConnectionEvent>(),\n\n    customEvent: makeEventSource<RoomEventMessage<P, U, E>>(),\n    self: makeEventSource<User<P, U>>(),\n    myPresence: makeEventSource<P>(),\n    others: makeEventSource<OthersEvent<P, U>>(),\n    storageBatch: makeEventSource<StorageUpdate[]>(),\n    history: makeEventSource<HistoryEvent>(),\n    storageDidLoad: makeEventSource<void>(),\n    storageStatus: makeEventSource<StorageStatus>(),\n    ydoc: makeEventSource<YDocUpdateServerMsg | UpdateYDocClientMsg>(),\n\n    comments: makeEventSource<CommentsEventServerMsg>(),\n  };\n\n  const roomId = config.roomId;\n\n  async function createTextMention(userId: string, mentionId: string) {\n    return httpClient.createTextMention({ roomId, userId, mentionId });\n  }\n\n  async function deleteTextMention(mentionId: string) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n\n  async function reportTextEditor(type: TextEditorType, rootKey: string) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n\n  async function listTextVersionsSince(options: ListTextVersionsSinceOptions) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options.since,\n      signal: options.signal,\n    });\n  }\n\n  async function getTextVersion(versionId: string) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n\n  function sendMessages(messages: ClientMsg<P, E>[]) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfoSig.get()?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      // if our message contains UTF-8, we can't simply use length. See: https://stackoverflow.com/questions/23318037/size-of-json-object-in-kbs-mbs\n      // if this turns out to be expensive, we could just guess with a lower value.\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpClient\n          .sendMessages<P, E>({ roomId, nonce, messages })\n          .then((resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          });\n        console.warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence): User<P, U> | null => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n        };\n      }\n    }\n  );\n\n  let _lastSelf: Readonly<User<P, U>> | undefined;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n\n  // For use in DevTools\n  const selfAsTreeNode = DerivedSignal.from(self, (me) =>\n    me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n\n  function createOrUpdateRootFromMessage(\n    message: InitialDocumentStateServerMsg\n  ) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n\n    if (context.root !== undefined) {\n      updateRoot(message.items);\n    } else {\n      context.root = LiveObject._fromItems<S>(message.items, pool);\n    }\n\n    const canWrite = self.get()?.canWrite ?? true;\n\n    // Populate missing top-level keys using `initialStorage`\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === undefined) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          console.warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n\n    // Initial storage is populated using normal \"set\" operations in the loop\n    // above, those updates can end up in the undo stack, so let's prune it.\n    context.undoStack.length = stackSizeBefore;\n  }\n\n  function updateRoot(items: IdTuple<SerializedCrdt>[]) {\n    if (context.root === undefined) {\n      return;\n    }\n\n    const currentItems: NodeMap = new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n\n    // Get operations that represent the diff between 2 states.\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n\n    const result = applyOps(ops, false);\n\n    notify(result.updates);\n  }\n\n  function _addToRealUndoStack(historyOps: HistoryOp<P>[]) {\n    // If undo stack is too large, we remove the older item\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n\n    context.undoStack.push(historyOps);\n    onHistoryChange();\n  }\n\n  function addToUndoStack(historyOps: HistoryOp<P>[]) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n\n  type NotifyUpdates = {\n    storageUpdates?: Map<string, StorageUpdate>;\n    presence?: boolean;\n    others?: InternalOthersEvent<P, U>[];\n  };\n\n  function notify(updates: NotifyUpdates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n\n    if (othersUpdates !== undefined && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n\n    if (storageUpdates !== undefined && storageUpdates.size > 0) {\n      const updates = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates);\n    }\n    notifyStorageStatus();\n  }\n\n  function getConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n\n  function applyOps<O extends HistoryOp<P>>(\n    rawOps: readonly O[],\n    isLocal: boolean\n  ): {\n    // Input Ops can get opIds assigned during application.\n    ops: O[];\n    reverse: O[];\n    updates: {\n      storageUpdates: Map<string, StorageUpdate>;\n      presence: boolean;\n    };\n  } {\n    const output = {\n      reverse: [] as O[],\n      storageUpdates: new Map<string, StorageUpdate>(),\n      presence: false,\n    };\n\n    const createdNodeIds = new Set<string>();\n\n    // Ops applied after undo/redo won't have opIds assigned, yet. Let's do\n    // that right now first.\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\" as const,\n          data: {} as P,\n        };\n\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.get()[key];\n        }\n\n        context.myPresence.patch(op.data);\n\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          // Merge the new fields with whatever is already queued up (doesn't\n          // matter whether its a partial or full update)\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n\n        output.reverse.unshift(reverse as O);\n        output.presence = true;\n      } else {\n        let source: OpSource;\n\n        if (isLocal) {\n          source = OpSource.UNDOREDO_RECONNECT;\n        } else {\n          const opId = nn(op.opId);\n          if (process.env.NODE_ENV !== \"production\") {\n            nn(context.opStackTraces).delete(opId);\n          }\n\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? OpSource.ACK : OpSource.REMOTE;\n        }\n\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n\n          // If the modified node is not the root (undefined) and was created in the same batch, we don't want to notify\n          // storage updates for the children.\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...(applyOpResult.reverse as O[]));\n          }\n\n          if (\n            op.type === OpCode.CREATE_LIST ||\n            op.type === OpCode.CREATE_MAP ||\n            op.type === OpCode.CREATE_OBJECT\n          ) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence,\n      },\n    };\n  }\n\n  function applyOp(op: Op, source: OpSource): ApplyResult {\n    // Explicit case to handle incoming \"AckOp\"s, which are supposed to be\n    // no-ops.\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n\n    switch (op.type) {\n      case OpCode.DELETE_OBJECT_KEY:\n      case OpCode.UPDATE_OBJECT:\n      case OpCode.DELETE_CRDT: {\n        const node = context.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        return node._apply(op, source === OpSource.UNDOREDO_RECONNECT);\n      }\n\n      case OpCode.SET_PARENT_KEY: {\n        const node = context.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case OpCode.CREATE_OBJECT:\n      case OpCode.CREATE_LIST:\n      case OpCode.CREATE_MAP:\n      case OpCode.CREATE_REGISTER: {\n        if (op.parentId === undefined) {\n          return { modified: false };\n        }\n\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === undefined) {\n          return { modified: false };\n        }\n\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n\n  function updatePresence(\n    patch: Partial<P>,\n    options?: { addToHistory: boolean }\n  ) {\n    const oldValues = {} as P;\n\n    if (context.buffer.presenceUpdates === null) {\n      // try {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {},\n      };\n      // } catch (err) {\n      //   window.console.log({ context, patch, err });\n      //   throw err;\n      // }\n    }\n\n    for (const key in patch) {\n      type K = typeof key;\n      const overrideValue: P[K] | undefined = patch[key];\n      if (overrideValue === undefined) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n\n    context.myPresence.patch(patch);\n\n    if (context.activeBatch) {\n      if (options?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues,\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n\n  function onUpdatePresenceMessage(\n    message: UpdatePresenceServerMsg<P>\n  ): InternalOthersEvent<P, U> | undefined {\n    if (message.targetActor !== undefined) {\n      // The incoming message is a full presence update. We are obliged to\n      // handle it if `targetActor` matches our own connection ID, but we can\n      // use the opportunity to effectively reset the known presence as\n      // a \"keyframe\" update, while we have free access to it.\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === undefined && newUser !== undefined) {\n        // The user just became \"visible\" due to this update, so fire the\n        // \"enter\" event\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      // The incoming message is a partial presence update\n      context.others.patchOther(message.actor, message.data), message;\n    }\n\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  function onUserLeftMessage(\n    message: UserLeftServerMsg\n  ): InternalOthersEvent<P, U> | null {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n\n  function onRoomStateMessage(\n    message: RoomStateServerMsg<U>\n  ): InternalOthersEvent<P, U> {\n    // The server will inform the client about its assigned actor ID and scopes\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes,\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === undefined) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n\n    // NOTE: We could be notifying the \"others\" event here, but the reality is\n    // that ROOM_STATE is often the first message to be received from the\n    // server, and it won't contain all the information needed to update the\n    // other views yet. Instead, we'll let the others' presences trickle in,\n    // and notify each time that happens.\n    return { type: \"reset\" };\n  }\n\n  function canUndo() { return context.undoStack.length > 0; } // prettier-ignore\n  function canRedo() { return context.redoStack.length > 0; } // prettier-ignore\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n\n  function onUserJoinedMessage(\n    message: UserJoinServerMsg<U>\n  ): InternalOthersEvent<P, U> | undefined {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    // Send current presence to new user\n    // TODO: Consider storing it on the backend\n    context.buffer.messages.push({\n      type: ClientMsgCode.UPDATE_PRESENCE,\n      data: context.myPresence.get(),\n      targetActor: message.actor,\n    });\n    flushNowOrSoon();\n\n    // We recorded the connection, but we won't make the new user visible\n    // unless we also know their initial presence data at this point.\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : undefined;\n  }\n\n  function parseServerMessage(data: Json): ServerMsg<P, U, E> | null {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n\n    return data as ServerMsg<P, U, E>;\n    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ FIXME: Properly validate incoming external data instead!\n  }\n\n  function parseServerMessages(text: string): ServerMsg<P, U, E>[] | null {\n    const data: Json | undefined = tryParseJson(text);\n    if (data === undefined) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n\n  function applyAndSendOps(offlineOps: Map<string, Op>) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n\n    const messages: ClientMsg<P, E>[] = [];\n\n    const ops = Array.from(offlineOps.values());\n\n    const result = applyOps(ops, true);\n\n    messages.push({\n      type: ClientMsgCode.UPDATE_STORAGE,\n      ops: result.ops,\n    });\n\n    notify(result.updates);\n\n    sendMessages(messages);\n  }\n\n  /**\n   * Handles a message received on the WebSocket. Will never be a \"pong\". The\n   * \"pong\" is handled at the connection manager level.\n   */\n  function handleServerMessage(event: IWebSocketMessageEvent) {\n    if (typeof event.data !== \"string\") {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const updates = {\n      storageUpdates: new Map<string, StorageUpdate>(),\n      others: [] as InternalOthersEvent<P, U>[],\n    };\n\n    for (const message of messages) {\n      switch (message.type) {\n        case ServerMsgCode.USER_JOINED: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n\n        case ServerMsgCode.UPDATE_PRESENCE: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n\n        case ServerMsgCode.BROADCASTED_EVENT: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user:\n              message.actor < 0\n                ? null\n                : (others.find((u) => u.connectionId === message.actor) ??\n                  null),\n            event: message.event,\n          });\n          break;\n        }\n\n        case ServerMsgCode.USER_LEFT: {\n          const event = onUserLeftMessage(message);\n          if (event) {\n            updates.others.push(event);\n          }\n          break;\n        }\n\n        case ServerMsgCode.UPDATE_YDOC: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n\n        case ServerMsgCode.ROOM_STATE: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n\n        case ServerMsgCode.INITIAL_STORAGE_STATE: {\n          // createOrUpdateRootFromMessage function could add ops to offlineOperations.\n          // Client shouldn't resend these ops as part of the offline ops sending after reconnect.\n          processInitialStorage(message);\n          break;\n        }\n        // Write event\n        case ServerMsgCode.UPDATE_STORAGE: {\n          const applyResult = applyOps(message.ops, false);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error. We look at this kind of bug\n        // as a developer-owned bug. In production, these errors are not expected to happen.\n        case ServerMsgCode.REJECT_STORAGE_OP: {\n          console.errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n\n          if (process.env.NODE_ENV !== \"production\") {\n            const traces: Set<string> = new Set();\n            for (const opId of message.opIds) {\n              const trace = context.opStackTraces?.get(opId);\n              if (trace) {\n                traces.add(trace);\n              }\n            }\n\n            if (traces.size > 0) {\n              console.warnWithTitle(\n                \"The following function calls caused the rejected storage mutations:\",\n                `\\n\\n${Array.from(traces).join(\"\\n\\n\")}`\n              );\n            }\n\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n\n          break;\n        }\n\n        case ServerMsgCode.THREAD_CREATED:\n        case ServerMsgCode.THREAD_DELETED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.THREAD_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_CREATED:\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.COMMENT_DELETED: {\n          eventHub.comments.notify(message);\n          break;\n        }\n      }\n    }\n\n    notify(updates);\n  }\n\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n\n    if (elapsedMillis >= config.throttleDelay) {\n      // Flush the buffer right now\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: undefined,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null,\n      };\n    } else {\n      // Or schedule the flush a few millis into the future\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n\n  /**\n   * Returns a list of ClientMsgs to flush to the network, computed from all\n   * pending changes in the buffer. Has no side effects.\n   */\n  function serializeBuffer() {\n    const messages: ClientMsg<P, E>[] = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\"\n          ? {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              // Populating the `targetActor` field turns this message into\n              // a Full Presence™ update message (not a patch), which will get\n              // interpreted by other clients as such.\n              targetActor: -1,\n              data: context.buffer.presenceUpdates.data,\n            }\n          : {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              data: context.buffer.presenceUpdates.data,\n            }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: ClientMsgCode.UPDATE_STORAGE,\n        ops: context.buffer.storageOperations,\n      });\n    }\n    return messages;\n  }\n\n  function updateYDoc(update: string, guid?: string, isV2?: boolean) {\n    const clientMsg: UpdateYDocClientMsg = {\n      type: ClientMsgCode.UPDATE_YDOC,\n      update,\n      guid,\n      v2: isV2,\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n\n  function broadcastEvent(\n    event: E,\n    options: BroadcastOptions = {\n      shouldQueueEventIfNotReady: false,\n    }\n  ) {\n    if (\n      managedSocket.getStatus() !== \"connected\" &&\n      !options.shouldQueueEventIfNotReady\n    ) {\n      return;\n    }\n\n    context.buffer.messages.push({\n      type: ClientMsgCode.BROADCAST_EVENT,\n      event,\n    });\n    flushNowOrSoon();\n  }\n\n  function dispatchOps(ops: Op[]) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n\n  let _getStorage$: Promise<void> | null = null;\n  let _resolveStoragePromise: (() => void) | null = null;\n\n  function processInitialStorage(message: InitialDocumentStateServerMsg) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message);\n    applyAndSendOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n\n  async function streamStorage() {\n    // TODO: Handle potential race conditions where the room get disconnected while the request is pending\n    if (!managedSocket.authValue) return;\n    const items = await httpClient.streamStorage({ roomId });\n    processInitialStorage({ type: ServerMsgCode.INITIAL_STORAGE_STATE, items });\n  }\n\n  function refreshStorage(options: { flush: boolean }) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      // instead of sending a fetch message over WS, stream over HTTP\n      void streamStorage();\n    } else if (\n      !messages.some((msg) => msg.type === ClientMsgCode.FETCH_STORAGE)\n    ) {\n      // Only add the fetch message to the outgoing message queue if it isn't\n      // already there\n      messages.push({ type: ClientMsgCode.FETCH_STORAGE });\n    }\n\n    if (options.flush) {\n      flushNowOrSoon();\n    }\n  }\n\n  function startLoadingStorage(): Promise<void> {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n\n  /**\n   * Closely related to .getStorage(), but synchronously. Will be `null`\n   * initially. When requested for the first time, will kick off the loading of\n   * Storage if it hasn't happened yet.\n   *\n   * Once Storage is loaded, will return a stable reference to the storage\n   * root.\n   */\n  function getStorageSnapshot(): LiveObject<S> | null {\n    const root = context.root;\n    if (root !== undefined) {\n      // Done loading\n      return root;\n    } else {\n      // Not done loading, kick off the loading (will not do anything if already kicked off)\n      void startLoadingStorage();\n      return null;\n    }\n  }\n\n  async function getStorage(): Promise<{\n    root: LiveObject<S>;\n  }> {\n    if (context.root !== undefined) {\n      // Store has already loaded, so we can resolve it directly\n      return Promise.resolve({\n        root: context.root,\n      });\n    }\n\n    await startLoadingStorage();\n    return {\n      root: nn(context.root) as LiveObject<S>,\n    };\n  }\n\n  function fetchYDoc(vector: string, guid?: string, isV2?: boolean): void {\n    // don't allow multiple fetches in the same buffer with the same vector\n    // dev tools may also call with a different vector (if its opened later), and that's okay\n    // because the updates will be ignored by the provider\n    if (\n      !context.buffer.messages.find((m) => {\n        return (\n          m.type === ClientMsgCode.FETCH_YDOC &&\n          m.vector === vector &&\n          m.guid === guid &&\n          m.v2 === isV2\n        );\n      })\n    ) {\n      context.buffer.messages.push({\n        type: ClientMsgCode.FETCH_YDOC,\n        vector,\n        guid,\n        v2: isV2,\n      });\n    }\n\n    flushNowOrSoon();\n  }\n\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n\n    const historyOps = context.redoStack.pop();\n    if (historyOps === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n\n  function batch<T>(callback: () => T): T {\n    if (context.activeBatch) {\n      // If there already is an active batch, we don't have to handle this in\n      // any special way. That outer active batch will handle the batch. This\n      // nested call can be a no-op.\n      return callback();\n    }\n\n    let returnValue: T = undefined as unknown as T;\n\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: new Map(),\n        presence: false,\n        others: [],\n      },\n      reverseOps: [],\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      // \"Pop\" the current batch of the state, closing the active batch, but\n      // handling it separately here\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(currentBatch.reverseOps);\n      }\n\n      if (currentBatch.ops.length > 0) {\n        // Only clear the redo stack if something has changed during a batch\n        // Clear the redo stack because batch is always called from a local operation\n        context.redoStack.length = 0;\n      }\n\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n\n    return returnValue;\n  }\n\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n\n  // Register a global source of pending changes for Storage™, so that the\n  // useSyncStatus() hook will be able to report this to end users\n  const syncSourceForStorage = config.createSyncSource();\n\n  function getStorageStatus(): StorageStatus {\n    if (context.root === undefined) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0\n        ? \"synchronized\"\n        : \"synchronizing\";\n    }\n  }\n\n  /**\n   * Storage status is a computed value based other internal states so we need to keep a reference to the previous computed value to avoid triggering events when it does not change\n   * This is far from ideal because we need to call this function whenever we update our internal states.\n   *\n   * TODO: Encapsulate our internal state differently to make sure this event is triggered whenever necessary.\n   * Currently okay because we only have 4 callers and shielded by tests.\n   */\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n\n  async function waitUntilPresenceReady(): Promise<void> {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      // Return whenever one of these returns, whichever is first\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n\n  async function waitUntilStorageReady(): Promise<void> {\n    while (!isStorageReady()) {\n      // Trigger a load of Storage and wait until it finished\n      await getStorage();\n    }\n  }\n\n  // Derived cached state for use in DevTools\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) =>\n      others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n\n    comments: eventHub.comments.observable,\n  };\n\n  async function getThreadsSince(options: GetThreadsSinceOptions) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options.since,\n      signal: options.signal,\n    });\n  }\n\n  async function getThreads(options?: GetThreadsOptions<M>) {\n    return httpClient.getThreads({\n      roomId,\n      query: options?.query,\n      cursor: options?.cursor,\n    });\n  }\n\n  async function getThread(threadId: string) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n\n  async function createThread(options: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      metadata: options.metadata,\n      body: options.body,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function deleteThread(threadId: string) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n\n  async function editThreadMetadata({\n    metadata,\n    threadId,\n  }: {\n    roomId: string;\n    metadata: Patchable<M>;\n    threadId: string;\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n\n  async function markThreadAsResolved(threadId: string) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n\n  async function markThreadAsUnresolved(threadId: string) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId,\n    });\n  }\n\n  async function createComment(options: {\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      body: options.body,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function editComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      body: options.body,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function deleteComment({\n    threadId,\n    commentId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji,\n    });\n  }\n\n  function prepareAttachment(file: File): CommentLocalAttachment {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file,\n    };\n  }\n\n  async function uploadAttachment(\n    attachment: CommentLocalAttachment,\n    options: UploadAttachmentOptions = {}\n  ): Promise<CommentAttachment> {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options.signal,\n    });\n  }\n\n  function getAttachmentUrl(attachmentId: string) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n\n  function getNotificationSettings(\n    options?: GetNotificationSettingsOptions\n  ): Promise<RoomNotificationSettings> {\n    return httpClient.getNotificationSettings({\n      roomId,\n      signal: options?.signal,\n    });\n  }\n\n  function updateNotificationSettings(\n    settings: Partial<RoomNotificationSettings>\n  ): Promise<RoomNotificationSettings> {\n    return httpClient.updateNotificationSettings({ roomId, settings });\n  }\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId,\n    });\n  }\n\n  // Register a global source of pending changes for Storage™, so that the\n  // useSyncStatus() hook will be able to report this to end users\n  const syncSourceForYjs = config.createSyncSource();\n\n  function yjsStatusDidChange(status: YjsSyncStatus) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() { return deepClone(context.buffer.presenceUpdates?.data ?? null) }, // prettier-ignore\n        get undoStack() { return deepClone(context.undoStack) }, // prettier-ignore\n        get nodeCount() { return context.nodes.size }, // prettier-ignore\n\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n\n        setYjsProvider(newProvider: IYjsProvider | undefined) {\n          // Deregister status change listener for the old Yjs provider\n          // Register status change listener for the new Yjs provider\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: (): readonly DevTools.UserTreeNode[] =>\n          others_forDevTools.get(),\n\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data),\n        },\n\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId),\n      },\n\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(\n        config.roomId,\n        events,\n        config.errorEventSource\n      ),\n\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        syncSourceForStorage.destroy();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory,\n      },\n\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n\n      events,\n\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead,\n    },\n\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\n\n/**\n * @internal\n * This recreates the classic single `.subscribe()` method for the Room API, as\n * documented here https://liveblocks.io/docs/api-reference/liveblocks-client#Room.subscribe(storageItem)\n */\nfunction makeClassicSubscribeFn<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(\n  roomId: string,\n  events: Room<P, S, U, E, M>[\"events\"],\n  errorEvents: EventSource<LiveblocksError>\n): SubscribeFn<P, S, U, E> {\n  // Set up the \"subscribe\" wrapper API\n  function subscribeToLiveStructureDeeply<L extends LiveStructure>(\n    node: L,\n    callback: (updates: StorageUpdate[]) => void\n  ): () => void {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter((update) =>\n        isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n\n  function subscribeToLiveStructureShallowly<L extends LiveStructure>(\n    node: L,\n    callback: (node: L) => void\n  ): () => void {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node as L);\n        }\n      }\n    });\n  }\n\n  // Generic storage callbacks\n  function subscribe(callback: StorageCallback): () => void; // prettier-ignore\n  // Storage callbacks filtered by Live structure\n  function subscribe<L extends LiveStructure>(liveStructure: L, callback: (node: L) => void): () => void; // prettier-ignore\n  function subscribe(node: LiveStructure, callback: StorageCallback, options: { isDeep: true }): () => void; // prettier-ignore\n  // Room event callbacks\n  function subscribe<K extends RoomEventName>(type: K, listener: RoomEventCallbackFor<K, P, U, E>): () => void; // prettier-ignore\n\n  function subscribe<L extends LiveStructure, K extends RoomEventName>(\n    first: StorageCallback | L | K,\n    second?: ((node: L) => void) | StorageCallback | RoomEventCallback,\n    options?: { isDeep: boolean }\n  ): () => void {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback as Callback<RoomEventMessage<P, U, E>>\n          );\n\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback as Callback<P>);\n\n        case \"others\": {\n          // NOTE: Others have a different callback structure, where the API\n          // exposed on the outside takes _two_ callback arguments!\n          const cb = callback as LegacyOthersEventCallback<P, U>;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return (callback as Callback<Error>)(err);\n            }\n          });\n        }\n\n        case \"status\":\n          return events.status.subscribe(callback as Callback<Status>);\n\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback as Callback<LostConnectionEvent>\n          );\n\n        case \"history\":\n          return events.history.subscribe(callback as Callback<HistoryEvent>);\n\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback as Callback<StorageStatus>\n          );\n\n        case \"comments\":\n          return events.comments.subscribe(\n            callback as Callback<CommentsEventServerMsg>\n          );\n\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n\n    if (second === undefined || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        // istanbul ignore next\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second as StorageCallback;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second as (node: L) => void;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n\n  return subscribe;\n}\n\nfunction isRoomEventName(value: string) {\n  return (\n    value === \"my-presence\" ||\n    value === \"others\" ||\n    value === \"event\" ||\n    value === \"error\" ||\n    value === \"history\" ||\n    value === \"status\" ||\n    value === \"storage-status\" ||\n    value === \"lost-connection\" ||\n    value === \"connection\" ||\n    value === \"comments\"\n  );\n}\n\nexport function makeAuthDelegateForRoom(\n  roomId: string,\n  authManager: AuthManager\n): () => Promise<AuthValue> {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\n\nexport function makeCreateSocketDelegateForRoom(\n  roomId: string,\n  baseUrl: string,\n  WebSocketPolyfill?: IWebSocket\n) {\n  return (authValue: AuthValue): IWebSocketInstance => {\n    const ws: IWebSocket | undefined =\n      WebSocketPolyfill ??\n      (typeof WebSocket === \"undefined\" ? undefined : WebSocket);\n\n    if (ws === undefined) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n","import type { LiveblocksHttpApi } from \"./api-client\";\nimport { createApiClient } from \"./api-client\";\nimport { createAuthManager } from \"./auth-manager\";\nimport { isIdle } from \"./connection\";\nimport { DEFAULT_BASE_URL } from \"./constants\";\nimport type { LsonObject } from \"./crdts/Lson\";\nimport { linkDevTools, setupDevTools, unlinkDevTools } from \"./devtools\";\nimport type { DE, DM, DP, DRI, DS, DU } from \"./globals/augmentation\";\nimport { kInternal } from \"./internal\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Batch, createBatchStore } from \"./lib/batch\";\nimport type { Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport type { NoInfr } from \"./lib/NoInfer\";\nimport type { Relax } from \"./lib/Relax\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport { Signal } from \"./lib/signals\";\nimport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nimport { TokenKind } from \"./protocol/AuthToken\";\nimport type { BaseUserMeta } from \"./protocol/BaseUserMeta\";\nimport type {\n  BaseMetadata,\n  ThreadData,\n  ThreadDeleteInfo,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n} from \"./protocol/InboxNotifications\";\nimport type {\n  OpaqueRoom,\n  OptionalTupleUnless,\n  PartialUnless,\n  Polyfills,\n  Room,\n  RoomDelegates,\n  SyncSource,\n} from \"./room\";\nimport {\n  createRoom,\n  makeAuthDelegateForRoom,\n  makeCreateSocketDelegateForRoom,\n} from \"./room\";\nimport type { LiveblocksErrorContext } from \"./types/LiveblocksError\";\nimport { LiveblocksError } from \"./types/LiveblocksError\";\nimport type { OptionalPromise } from \"./types/OptionalPromise\";\n\nconst MIN_THROTTLE = 16;\nconst MAX_THROTTLE = 1_000;\nconst DEFAULT_THROTTLE = 100;\n\nconst MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15_000;\nconst MIN_LOST_CONNECTION_TIMEOUT = 200;\nconst RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1_000;\nconst MAX_LOST_CONNECTION_TIMEOUT = 30_000;\nconst DEFAULT_LOST_CONNECTION_TIMEOUT = 5_000;\n\nconst RESOLVE_USERS_BATCH_DELAY = 50;\nconst RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\n\nexport type ResolveMentionSuggestionsArgs = {\n  /**\n   * The ID of the current room.\n   */\n  roomId: string;\n\n  /**\n   * The text to search for.\n   */\n  text: string;\n};\n\nexport type ResolveUsersArgs = {\n  /**\n   * The IDs of the users to resolve.\n   */\n  userIds: string[];\n};\n\nexport type ResolveRoomsInfoArgs = {\n  /**\n   * The IDs of the rooms to resolve.\n   */\n  roomIds: string[];\n};\n\nexport type EnterOptions<P extends JsonObject = DP, S extends LsonObject = DS> =\n  // prettier-ignore\n  Resolve<\n  {\n    /**\n     * Whether or not the room automatically connects to Liveblock servers.\n     * Default is true.\n     *\n     * Usually set to false when the client is used from the server to not call\n     * the authentication endpoint or connect via WebSocket.\n     */\n    autoConnect?: boolean;\n  }\n\n  // Initial presence is only mandatory if the custom type requires it to be\n  & PartialUnless<\n    P,\n    {\n      /**\n       * The initial Presence to use and announce when you enter the Room. The\n       * Presence is available on all users in the Room (me & others).\n       */\n      initialPresence: P | ((roomId: string) => P);\n    }\n  >\n  \n  // Initial storage is only mandatory if the custom type requires it to be\n  & PartialUnless<\n    S,\n    {\n      /**\n       * The initial Storage to use when entering a new Room.\n       */\n      initialStorage: S | ((roomId: string) => S);\n    }\n  >\n>;\n\nexport type SyncStatus =\n  /* Liveblocks is in the process of writing changes */\n  | \"synchronizing\"\n  /* Liveblocks has persisted all pending changes */\n  | \"synchronized\";\n\n/**\n * \"synchronizing\"     - Liveblocks is in the process of writing changes\n * \"synchronized\"      - Liveblocks has persisted all pending changes\n * \"has-local-changes\" - There is local pending state inputted by the user, but\n *                       we're not yet \"synchronizing\" it until a user\n *                       interaction, like the draft text in a comment box.\n */\nexport type InternalSyncStatus = SyncStatus | \"has-local-changes\";\n\n/**\n * @private\n *\n * Private methods and variables used in the core internals, but as a user\n * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n * will probably happen if you do.\n */\nexport type PrivateClientApi<U extends BaseUserMeta, M extends BaseMetadata> = {\n  readonly currentUserId: Signal<string | undefined>;\n  readonly mentionSuggestionsCache: Map<string, string[]>;\n  readonly resolveMentionSuggestions: ClientOptions<U>[\"resolveMentionSuggestions\"];\n  readonly usersStore: BatchStore<U[\"info\"] | undefined, string>;\n  readonly roomsInfoStore: BatchStore<DRI | undefined, string>;\n  readonly getRoomIds: () => string[];\n  readonly httpClient: LiveblocksHttpApi<M>;\n  // Type-level helper\n  as<M2 extends BaseMetadata>(): Client<U, M2>;\n  // Tracking pending changes globally\n  createSyncSource(): SyncSource;\n  emitError(context: LiveblocksErrorContext, cause?: Error): void;\n};\n\nexport type NotificationsApi<M extends BaseMetadata> = {\n  /**\n   * Gets a page (or the initial page) for user inbox notifications and their\n   * associated threads.\n   *\n   * This function should NOT be used for delta updates, only for pagination\n   * (including the first page fetch). For delta updates (done during the\n   * periodic polling), use the `getInboxNotificationsSince` function.\n   *\n   * @example\n   * const {\n   *   inboxNotifications,\n   *   threads,\n   *   nextCursor,\n   * } = await client.getInboxNotifications();\n   * const data = await client.getInboxNotifications();  // Fetch initial page (of 20 inbox notifications)\n   * const data = await client.getInboxNotifications({ cursor: nextCursor });  // Fetch next page (= next 20 inbox notifications)\n   */\n  getInboxNotifications(options?: { cursor?: string }): Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<M>[];\n    nextCursor: string | null;\n    requestedAt: Date;\n  }>;\n\n  /**\n   * Fetches a \"delta update\" since the last time we updated.\n   *\n   * This function should NOT be used for pagination, for that, see the\n   * `getInboxNotifications` function.\n   *\n   * @example\n   * const {\n   *   inboxNotifications: {\n   *     updated,\n   *     deleted,\n   *   },\n   *   threads: {\n   *     updated,\n   *     deleted,\n   *    },\n   *   requestedAt,\n   * } = await client.getInboxNotificationsSince({ since: result.requestedAt }});\n   */\n  getInboxNotificationsSince(options: {\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    requestedAt: Date;\n  }>;\n\n  /**\n   * Gets the number of unread inbox notifications for the current user.\n   *\n   * @example\n   * const count = await client.getUnreadInboxNotificationsCount();\n   */\n  getUnreadInboxNotificationsCount(): Promise<number>;\n\n  /**\n   * Marks all inbox notifications as read.\n   *\n   * @example\n   * await client.markAllInboxNotificationsAsRead();\n   */\n  markAllInboxNotificationsAsRead(): Promise<void>;\n\n  /**\n   * Marks an inbox notification as read.\n   *\n   * @example\n   * await client.markInboxNotificationAsRead(\"in_xxx\");\n   */\n  markInboxNotificationAsRead(inboxNotificationId: string): Promise<void>;\n\n  /**\n   * Deletes all inbox notifications for the current user.\n   *\n   * @example\n   * await client.deleteAllInboxNotifications();\n   */\n  deleteAllInboxNotifications(): Promise<void>;\n\n  /**\n   * Deletes an inbox notification for the current user.\n   *\n   * @example\n   * await client.deleteInboxNotification(\"in_xxx\");\n   */\n  deleteInboxNotification(inboxNotificationId: string): Promise<void>;\n};\n\n/**\n * @private Widest-possible Client type, matching _any_ Client instance. Note\n * that this type is different from `Client`-without-type-arguments. That\n * represents a Client instance using globally augmented types only, which is\n * narrower.\n */\nexport type OpaqueClient = Client<BaseUserMeta>;\n\nexport type Client<U extends BaseUserMeta = DU, M extends BaseMetadata = DM> = {\n  /**\n   * Gets a room. Returns null if {@link Client.enter} has not been called previously.\n   *\n   * @param roomId The id of the room\n   */\n  getRoom<\n    P extends JsonObject = DP,\n    S extends LsonObject = DS,\n    E extends Json = DE,\n    M2 extends BaseMetadata = M,\n  >(\n    roomId: string\n  ): Room<P, S, U, E, M2> | null;\n\n  /**\n   * Enter a room.\n   * @param roomId The id of the room\n   * @param options Optional. You can provide initializers for the Presence or Storage when entering the Room.\n   * @returns The room and a leave function. Call the returned leave() function when you no longer need the room.\n   */\n  enterRoom<\n    P extends JsonObject = DP,\n    S extends LsonObject = DS,\n    E extends Json = DE,\n    M2 extends BaseMetadata = M,\n  >(\n    roomId: string,\n    ...args: OptionalTupleUnless<\n      P & S,\n      [options: EnterOptions<NoInfr<P>, NoInfr<S>>]\n    >\n  ): {\n    room: Room<P, S, U, E, M2>;\n    leave: () => void;\n  };\n\n  /**\n   * Purges all cached auth tokens and reconnects all rooms that are still\n   * connected, if any.\n   *\n   * Call this whenever you log out a user in your application.\n   */\n  logout(): void;\n\n  /**\n   * Advanced APIs related to the resolvers.\n   */\n  resolvers: {\n    /**\n     * Invalidate some or all users that were previously cached by `resolveUsers`.\n     *\n     * @example\n     * // Invalidate all users\n     * client.resolvers.invalidateUsers();\n     *\n     * @example\n     * // Invalidate specific users\n     * client.resolvers.invalidateUsers([\"user-1\", \"user-2\"]);\n     */\n    invalidateUsers(userIds?: string[]): void;\n\n    /**\n     * Invalidate some or all rooms info that were previously cached by `resolveRoomsInfo`.\n     *\n     * @example\n     * // Invalidate all rooms\n     * client.resolvers.invalidateRoomsInfo();\n     *\n     * @example\n     * // Invalidate specific rooms\n     * client.resolvers.invalidateRoomsInfo([\"room-1\", \"room-2\"]);\n     */\n    invalidateRoomsInfo(roomIds?: string[]): void;\n\n    /**\n     * Invalidate all mention suggestions cached by `resolveMentionSuggestions`.\n     *\n     * @example\n     * // Invalidate all mention suggestions\n     * client.resolvers.invalidateMentionSuggestions();\n     */\n    invalidateMentionSuggestions(): void;\n  };\n\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  // TODO Make this a getter, so we can provide M\n  readonly [kInternal]: PrivateClientApi<U, M>;\n\n  /**\n   * Returns the current global sync status of the Liveblocks client. If any\n   * part of Liveblocks has any local pending changes that haven't been\n   * confirmed by or persisted by the server yet, this will be \"synchronizing\",\n   * otherwise \"synchronized\".\n   *\n   * This is a combined status for all of the below parts of Liveblocks:\n   * - Storage (realtime APIs)\n   * - Text Editors\n   * - Comments\n   * - Notifications\n   *\n   * @example\n   * const status = client.getSyncStatus();  // \"synchronizing\" | \"synchronized\"\n   */\n  getSyncStatus(): SyncStatus;\n\n  /**\n   * All possible client events, subscribable from a single place.\n   */\n  readonly events: {\n    readonly error: Observable<LiveblocksError>;\n    readonly syncStatus: Observable<void>;\n  };\n} & NotificationsApi<M>;\n\nexport type AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\n/**\n * The authentication endpoint that is called to ensure that the current user has access to a room.\n * Can be an url or a callback if you need to add additional headers.\n */\nexport type ClientOptions<U extends BaseUserMeta = DU> = {\n  throttle?: number; // in milliseconds\n  lostConnectionTimeout?: number; // in milliseconds\n  backgroundKeepAliveTimeout?: number; // in milliseconds\n  polyfills?: Polyfills;\n  unstable_fallbackToHTTP?: boolean;\n  unstable_streamData?: boolean;\n\n  /**\n   * A function that returns a list of user IDs matching a string.\n   */\n  resolveMentionSuggestions?: (\n    args: ResolveMentionSuggestionsArgs\n  ) => OptionalPromise<string[]>;\n\n  /**\n   * A function that returns user info from user IDs.\n   * You should return a list of user objects of the same size, in the same order.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => OptionalPromise<(U[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * A function that returns room info from room IDs.\n   * You should return a list of room info objects of the same size, in the same order.\n   */\n  resolveRoomsInfo?: (\n    args: ResolveRoomsInfoArgs\n  ) => OptionalPromise<(DRI | undefined)[] | undefined>;\n\n  /**\n   * Prevent the current browser tab from being closed if there are any locally\n   * pending Liveblocks changes that haven't been submitted to or confirmed by\n   * the server yet.\n   */\n  preventUnsavedChanges?: boolean;\n\n  /**\n   * @internal To point the client to a different Liveblocks server. Only\n   * useful for Liveblocks developers. Not for end users.\n   */\n  baseUrl?: string;\n\n  /** @internal */\n  mockedDelegates?: RoomDelegates;\n\n  /** @internal */\n  enableDebugLogging?: boolean;\n} & Relax<{ publicApiKey: string } | { authEndpoint: AuthEndpoint }>;\n\nfunction getBaseUrl(baseUrl?: string | undefined): string {\n  if (\n    typeof baseUrl === \"string\" &&\n    baseUrl.startsWith(\"http\") // Must be http or https URL\n  ) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\n\n/**\n * Create a client that will be responsible to communicate with liveblocks servers.\n *\n * @example\n * const client = createClient({\n *   authEndpoint: \"/api/auth\"\n * });\n *\n * // It's also possible to use a function to call your authentication endpoint.\n * // Useful to add additional headers or use an API wrapper (like Firebase functions)\n * const client = createClient({\n *   authEndpoint: async (room?) => {\n *     const response = await fetch(\"/api/auth\", {\n *       method: \"POST\",\n *       headers: {\n *          Authentication: \"token\",\n *          \"Content-Type\": \"application/json\"\n *       },\n *       body: JSON.stringify({ room })\n *     });\n *\n *     return await response.json(); // should be: { token: \"...\" }\n *   }\n * });\n */\nexport function createClient<U extends BaseUserMeta = DU>(\n  options: ClientOptions<U>\n): Client<U> {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n\n  const currentUserId = new Signal<string | undefined>(undefined);\n\n  const authManager = createAuthManager(options, (token) => {\n    const userId = token.k === TokenKind.SECRET_LEGACY ? token.id : token.uid;\n    currentUserId.set(() => userId);\n  });\n\n  const fetchPolyfill =\n    clientOptions.polyfills?.fetch ||\n    /* istanbul ignore next */ globalThis.fetch?.bind(globalThis);\n\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    authManager,\n  });\n\n  type RoomDetails = {\n    room: OpaqueRoom;\n    unsubs: Set<() => void>;\n  };\n\n  const roomsById = new Map<string, RoomDetails>();\n\n  function teardownRoom(room: OpaqueRoom) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n\n  function leaseRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    M extends BaseMetadata,\n  >(\n    details: RoomDetails\n  ): {\n    room: Room<P, S, U, E, M>;\n    leave: () => void;\n  } {\n    // Create a new self-destructing leave function\n    const leave = () => {\n      const self = leave; // A reference to the currently executing function itself\n\n      if (!details.unsubs.delete(self)) {\n        console.warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        // Was this the last room lease? If so, tear down the room\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n\n    details.unsubs.add(leave);\n    return {\n      room: details.room as Room<P, S, U, E, M>,\n      leave,\n    };\n  }\n\n  function enterRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    M extends BaseMetadata,\n  >(\n    roomId: string,\n    ...args: OptionalTupleUnless<\n      P & S,\n      [options: EnterOptions<NoInfr<P>, NoInfr<S>>]\n    >\n  ): {\n    room: Room<P, S, U, E, M>;\n    leave: () => void;\n  } {\n    const existing = roomsById.get(roomId);\n    if (existing !== undefined) {\n      return leaseRoom(existing);\n    }\n\n    const options = args[0] ?? ({} as EnterOptions<P, S>);\n    const initialPresence =\n      (typeof options.initialPresence === \"function\"\n        ? options.initialPresence(roomId)\n        : options.initialPresence) ?? ({} as P);\n\n    const initialStorage =\n      (typeof options.initialStorage === \"function\"\n        ? options.initialStorage(roomId)\n        : options.initialStorage) ?? ({} as S);\n\n    const newRoom = createRoom<P, S, U, E, M>(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager),\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient as LiveblocksHttpApi<M>,\n        createSyncSource,\n      }\n    );\n\n    const newRoomDetails: RoomDetails = {\n      room: newRoom,\n      unsubs: new Set(),\n    };\n    roomsById.set(roomId, newRoomDetails);\n\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n\n    const shouldConnect = options.autoConnect ?? true;\n    if (shouldConnect) {\n      // we need to check here because nextjs would fail earlier with Node < 16\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === undefined) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        // At this point, atob does not exist so we are either on React Native or on Node < 16, hence global is available.\n        global.atob = clientOptions.polyfills.atob;\n      }\n\n      newRoom.connect();\n    }\n\n    return leaseRoom(newRoomDetails);\n  }\n\n  function getRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    M extends BaseMetadata,\n  >(roomId: string): Room<P, S, U, E, M> | null {\n    const room = roomsById.get(roomId)?.room;\n    return room ? (room as Room<P, S, U, E, M>) : null;\n  }\n\n  function logout() {\n    authManager.reset();\n\n    // Reset the current user id store when the client is logged out\n    currentUserId.set(() => undefined);\n\n    // Reconnect all rooms that aren't idle, if any. This ensures that those\n    // rooms will get reauthorized now that the auth cache is reset. If that\n    // fails, they might disconnect.\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds: string[]) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n\n      warnIfNoResolveUsers();\n\n      return users ?? userIds.map(() => undefined);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n\n  function invalidateResolvedUsers(userIds?: string[]) {\n    usersStore.invalidate(userIds);\n  }\n\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds: string[]) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n\n      warnIfNoResolveRoomsInfo();\n\n      return roomsInfo ?? roomIds.map(() => undefined);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n\n  function invalidateResolvedRoomsInfo(roomIds?: string[]) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n\n  const mentionSuggestionsCache = new Map<string, string[]>();\n\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n\n  // ----------------------------------------------------------------\n\n  const syncStatusSources: Signal<InternalSyncStatus>[] = [];\n  const syncStatusSignal = new Signal<InternalSyncStatus>(\"synchronized\");\n\n  const liveblocksErrorSource = makeEventSource<LiveblocksError>();\n\n  function getSyncStatus(): SyncStatus {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\")\n        ? \"synchronizing\"\n        : syncStatusSources.some((src) => src.get() === \"has-local-changes\")\n          ? \"has-local-changes\"\n          : \"synchronized\"\n    );\n  }\n\n  function createSyncSource(): SyncSource {\n    const source = new Signal<InternalSyncStatus>(\"synchronized\");\n    syncStatusSources.push(source);\n\n    const unsub = source.subscribe(() => recompute());\n\n    function setSyncStatus(status: InternalSyncStatus) {\n      source.set(status);\n    }\n\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          // We only have to recompute if it was still pending. Otherwise it\n          // could not have an effect on the global state anyway.\n          recompute();\n        }\n      }\n    }\n\n    return { setSyncStatus, destroy };\n  }\n\n  // ----------------------------------------------------------------\n\n  // Set up event handler that will prevent the browser tab from being closed\n  // if there are locally pending changes to any part of Liveblocks (Storage,\n  // text editors, Threads, Notifications, etc)\n  {\n    const maybePreventClose = (e: BeforeUnloadEvent) => {\n      if (\n        clientOptions.preventUnsavedChanges &&\n        syncStatusSignal.get() !== \"synchronized\"\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    // A Liveblocks client is currently never destroyed.\n    // TODO Call win.removeEventListener(\"beforeunload\", maybePreventClose)\n    // once we have a client.destroy() method\n    const win = typeof window !== \"undefined\" ? window : undefined;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n\n  const client: Client<U> = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n\n      logout,\n\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount:\n        httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead:\n        httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions,\n      },\n\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal,\n      },\n\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: <M2 extends BaseMetadata>() => client as Client<U, M2>,\n        createSyncSource,\n        emitError: (context: LiveblocksErrorContext, cause?: Error) => {\n          const error = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error);\n          if (!didNotify) {\n            console.error(error.message);\n          }\n        },\n      },\n    },\n    kInternal,\n    {\n      enumerable: false,\n    }\n  );\n\n  return client;\n}\n\nfunction checkBounds(\n  option: string,\n  value: unknown,\n  min: number,\n  max?: number,\n  recommendedMin?: number\n): number {\n  if (\n    typeof value !== \"number\" ||\n    value < min ||\n    (max !== undefined && value > max)\n  ) {\n    throw new Error(\n      max !== undefined\n        ? `${option} should be between ${recommendedMin ?? min} and ${max}.`\n        : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\n\nfunction getBackgroundKeepAliveTimeout(\n  value: number | undefined\n): number | undefined {\n  if (value === undefined) return undefined;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\n\nfunction getThrottle(value: number): number {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\n\nfunction getLostConnectionTimeout(value: number): number {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\n\n/**\n * Emit a warning only once if a condition is met, in development only.\n */\nfunction createDevelopmentWarning(\n  condition: boolean | (() => boolean),\n  ...args: Parameters<typeof console.warn>\n) {\n  let hasWarned = false;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    return () => {\n      if (\n        !hasWarned &&\n        (typeof condition === \"function\" ? condition() : condition)\n      ) {\n        console.warn(...args);\n\n        hasWarned = true;\n      }\n    };\n  } else {\n    return () => {};\n  }\n}\n","import type { ResolveUsersArgs } from \"../client\";\nimport type { DU } from \"../globals/augmentation\";\nimport { nn } from \"../lib/assert\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"../protocol/Comments\";\nimport type { OptionalPromise } from \"../types/OptionalPromise\";\n\ntype CommentBodyBlockElementName = Exclude<\n  CommentBodyBlockElement,\n  CommentBodyText\n>[\"type\"];\n\ntype CommentBodyInlineElementName =\n  | Exclude<CommentBodyInlineElement, CommentBodyText>[\"type\"]\n  | \"text\";\n\ntype CommentBodyElementName =\n  | CommentBodyBlockElementName\n  | CommentBodyInlineElementName;\n\ntype CommentBodyBlockElements = {\n  paragraph: CommentBodyParagraph;\n};\n\ntype CommentBodyInlineElements = {\n  text: CommentBodyText;\n  link: CommentBodyLink;\n  mention: CommentBodyMention;\n};\n\ntype CommentBodyElements = CommentBodyBlockElements & CommentBodyInlineElements;\n\ntype CommentBodyVisitor<T extends CommentBodyElement = CommentBodyElement> = (\n  element: T\n) => void;\n\nexport type CommentBodyParagraphElementArgs = {\n  /**\n   * The paragraph element.\n   */\n  element: CommentBodyParagraph;\n\n  /**\n   * The text content of the paragraph.\n   */\n  children: string;\n};\n\nexport type CommentBodyTextElementArgs = {\n  /**\n   * The text element.\n   */\n  element: CommentBodyText;\n};\n\nexport type CommentBodyLinkElementArgs = {\n  /**\n   * The link element.\n   */\n  element: CommentBodyLink;\n\n  /**\n   * The absolute URL of the link.\n   */\n  href: string;\n};\n\nexport type CommentBodyMentionElementArgs<U extends BaseUserMeta = DU> = {\n  /**\n   * The mention element.\n   */\n  element: CommentBodyMention;\n\n  /**\n   * The mention's user info, if the `resolvedUsers` option was provided.\n   */\n  user?: U[\"info\"];\n};\n\nexport type StringifyCommentBodyElements<U extends BaseUserMeta = DU> = {\n  /**\n   * The element used to display paragraphs.\n   */\n  paragraph: (args: CommentBodyParagraphElementArgs, index: number) => string;\n\n  /**\n   * The element used to display text elements.\n   */\n  text: (args: CommentBodyTextElementArgs, index: number) => string;\n\n  /**\n   * The element used to display links.\n   */\n  link: (args: CommentBodyLinkElementArgs, index: number) => string;\n\n  /**\n   * The element used to display mentions.\n   */\n  mention: (args: CommentBodyMentionElementArgs<U>, index: number) => string;\n};\n\nexport type StringifyCommentBodyOptions<U extends BaseUserMeta = DU> = {\n  /**\n   * Which format to convert the comment to.\n   */\n  format?: \"plain\" | \"html\" | \"markdown\";\n\n  /**\n   * The elements used to customize the resulting string. Each element has\n   * priority over the defaults inherited from the `format` option.\n   */\n  elements?: Partial<StringifyCommentBodyElements<U>>;\n\n  /**\n   * The separator used between paragraphs.\n   */\n  separator?: string;\n\n  /**\n   * A function that returns user info from user IDs.\n   * You should return a list of user objects of the same size, in the same order.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => OptionalPromise<(U[\"info\"] | undefined)[] | undefined>;\n};\n\nexport function isCommentBodyParagraph(\n  element: CommentBodyElement\n): element is CommentBodyParagraph {\n  return \"type\" in element && element.type === \"paragraph\";\n}\n\nexport function isCommentBodyText(\n  element: CommentBodyElement\n): element is CommentBodyText {\n  return (\n    !(\"type\" in element) &&\n    \"text\" in element &&\n    typeof element.text === \"string\"\n  );\n}\n\nexport function isCommentBodyMention(\n  element: CommentBodyElement\n): element is CommentBodyMention {\n  return \"type\" in element && element.type === \"mention\";\n}\n\nexport function isCommentBodyLink(\n  element: CommentBodyElement\n): element is CommentBodyLink {\n  return \"type\" in element && element.type === \"link\";\n}\n\nconst commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention,\n};\n\nconst commentBodyElementsTypes: Record<\n  CommentBodyElementName,\n  \"block\" | \"inline\"\n> = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\",\n};\n\nfunction traverseCommentBody(\n  body: CommentBody,\n  visitor: CommentBodyVisitor\n): void;\nfunction traverseCommentBody<T extends CommentBodyElementName>(\n  body: CommentBody,\n  element: T,\n  visitor: CommentBodyVisitor<CommentBodyElements[T]>\n): void;\nfunction traverseCommentBody(\n  body: CommentBody,\n  elementOrVisitor: CommentBodyElementName | CommentBodyVisitor,\n  possiblyVisitor?: CommentBodyVisitor\n): void {\n  if (!body || !body?.content) {\n    return;\n  }\n\n  const element =\n    typeof elementOrVisitor === \"string\" ? elementOrVisitor : undefined;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor =\n    typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get an array of each user's ID that has been mentioned in a `CommentBody`.\n */\nexport function getMentionedIdsFromCommentBody(body: CommentBody): string[] {\n  const mentionedIds = new Set<string>();\n\n  traverseCommentBody(body, \"mention\", (mention) =>\n    mentionedIds.add(mention.id)\n  );\n\n  return Array.from(mentionedIds);\n}\n\nexport async function resolveUsersInCommentBody<U extends BaseUserMeta>(\n  body: CommentBody,\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => OptionalPromise<(U[\"info\"] | undefined)[] | undefined>\n): Promise<Map<string, U[\"info\"]>> {\n  const resolvedUsers = new Map<string, U[\"info\"]>();\n\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds,\n  });\n\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n\n  return resolvedUsers;\n}\n\nconst htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nconst htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nexport function htmlSafe(value: string): HtmlSafeString {\n  return new HtmlSafeString([String(value)], []);\n}\n\nfunction joinHtml(strings: (string | HtmlSafeString)[]) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n\n  return new HtmlSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeHtml(\n  value: string | string[] | HtmlSafeString | HtmlSafeString[]\n) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character as keyof typeof htmlEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class HtmlSafeString {\n  #strings: readonly string[];\n  #values: readonly (string | string[] | HtmlSafeString | HtmlSafeString[])[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n  ) {\n    this.#strings = strings;\n    this.#values = values;\n  }\n\n  toString(): string {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build an HTML string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nexport function html(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n): string {\n  return new HtmlSafeString(strings, values) as unknown as string;\n}\n\nconst markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\",\n};\n\nconst markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nfunction joinMarkdown(strings: (string | MarkdownSafeString)[]) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n\n  return new MarkdownSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeMarkdown(\n  value: string | string[] | MarkdownSafeString | MarkdownSafeString[]\n) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) =>\n      markdownEscapables[character as keyof typeof markdownEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class MarkdownSafeString {\n  #strings: readonly string[];\n  #values: readonly (\n    | string\n    | string[]\n    | MarkdownSafeString\n    | MarkdownSafeString[]\n  )[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (\n      | string\n      | string[]\n      | MarkdownSafeString\n      | MarkdownSafeString[]\n    )[]\n  ) {\n    this.#strings = strings;\n    this.#values = values;\n  }\n\n  toString(): string {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build a Markdown string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nfunction markdown(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | MarkdownSafeString | MarkdownSafeString[])[]\n) {\n  return new MarkdownSafeString(strings, values) as unknown as string;\n}\n\n/**\n * Helper function to convert a URL (relative or absolute) to an absolute URL.\n *\n * @param url The URL to convert to an absolute URL (relative or absolute).\n * @returns The absolute URL or undefined if the URL is invalid.\n */\nexport function toAbsoluteUrl(url: string): string | undefined {\n  // Check if the URL already contains a scheme\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    // If the URL starts with \"www.\", prepend \"https://\"\n    return \"https://\" + url;\n  }\n\n  return;\n}\n\nconst stringifyCommentBodyPlainElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => children,\n    text: ({ element }) => element.text,\n    link: ({ element }) => element.text ?? element.url,\n    mention: ({ element, user }) => {\n      return `@${user?.name ?? element.id}`;\n    },\n  };\n\nconst stringifyCommentBodyHtmlElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => {\n      // prettier-ignore\n      return children ? html`<p>${htmlSafe(children)}</p>` : children;\n    },\n    text: ({ element }) => {\n      // <code><s><em><strong>text</strong></s></em></code>\n      let children = element.text;\n\n      if (!children) {\n        return children;\n      }\n\n      if (element.bold) {\n        // prettier-ignore\n        children = html`<strong>${children}</strong>`;\n      }\n\n      if (element.italic) {\n        // prettier-ignore\n        children = html`<em>${children}</em>`;\n      }\n\n      if (element.strikethrough) {\n        // prettier-ignore\n        children = html`<s>${children}</s>`;\n      }\n\n      if (element.code) {\n        // prettier-ignore\n        children = html`<code>${children}</code>`;\n      }\n\n      return children;\n    },\n    link: ({ element, href }) => {\n      // prettier-ignore\n      return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ?? element.url}</a>`;\n    },\n    mention: ({ element, user }) => {\n      // prettier-ignore\n      return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n    },\n  };\n\nconst stringifyCommentBodyMarkdownElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => {\n      return children;\n    },\n    text: ({ element }) => {\n      // <code><s><em><strong>text</strong></s></em></code>\n      let children = element.text;\n\n      if (!children) {\n        return children;\n      }\n\n      if (element.bold) {\n        // prettier-ignore\n        children = markdown`**${children}**`;\n      }\n\n      if (element.italic) {\n        // prettier-ignore\n        children = markdown`_${children}_`;\n      }\n\n      if (element.strikethrough) {\n        // prettier-ignore\n        children = markdown`~~${children}~~`;\n      }\n\n      if (element.code) {\n        // prettier-ignore\n        children = markdown`\\`${children}\\``;\n      }\n\n      return children;\n    },\n    link: ({ element, href }) => {\n      // prettier-ignore\n      return markdown`[${element.text ?? element.url}](${href})`;\n    },\n    mention: ({ element, user }) => {\n      // prettier-ignore\n      return markdown`@${user?.name ?? element.id}`;\n    },\n  };\n\n/**\n * Convert a `CommentBody` into either a plain string,\n * Markdown, HTML, or a custom format.\n */\nexport async function stringifyCommentBody(\n  body: CommentBody,\n  options?: StringifyCommentBodyOptions<BaseUserMeta>\n): Promise<string> {\n  const format = options?.format ?? \"plain\";\n  const separator =\n    options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...(format === \"html\"\n      ? stringifyCommentBodyHtmlElements\n      : format === \"markdown\"\n        ? stringifyCommentBodyMarkdownElements\n        : stringifyCommentBodyPlainElements),\n    ...options?.elements,\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id\n              ? [\n                  elements.mention(\n                    {\n                      element: inline,\n                      user: resolvedUsers.get(inline.id),\n                    },\n                    inlineIndex\n                  ),\n                ]\n              : [];\n          }\n\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url,\n                },\n                inlineIndex\n              ),\n            ];\n          }\n\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n\n          return [];\n        });\n\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          ),\n        ];\n      }\n\n      default:\n        return [];\n    }\n  });\n\n  return blocks.join(separator);\n}\n","const PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\n\nexport function generateCommentUrl({\n  roomUrl,\n  commentId,\n}: {\n  roomUrl: string;\n  commentId: string;\n}): string {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(roomUrl);\n  const urlObject = new URL(\n    roomUrl,\n    isAbsolute ? undefined : PLACEHOLDER_BASE_URL\n  );\n\n  urlObject.hash = `#${commentId}`;\n\n  return isAbsolute\n    ? urlObject.href\n    : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n","import type { Json } from \"../lib/Json\";\nimport type { PlainLson } from \"../types/PlainLson\";\nimport { LiveList } from \"./LiveList\";\nimport { LiveMap } from \"./LiveMap\";\nimport { LiveObject } from \"./LiveObject\";\nimport type { Lson, LsonObject } from \"./Lson\";\n\n/**\n * Helper type to convert any valid Lson type to the equivalent Json type.\n *\n * Examples:\n *\n *   ToImmutable<42>                         // 42\n *   ToImmutable<'hi'>                       // 'hi'\n *   ToImmutable<number>                     // number\n *   ToImmutable<string>                     // string\n *   ToImmutable<string | LiveList<number>>  // string | readonly number[]\n *   ToImmutable<LiveMap<string, LiveList<number>>>\n *                                           // ReadonlyMap<string, readonly number[]>\n *   ToImmutable<LiveObject<{ a: number, b: LiveList<string>, c?: number }>>\n *                                           // { readonly a: null, readonly b: readonly string[], readonly c?: number }\n *\n */\n// prettier-ignore\nexport type ToImmutable<L extends Lson | LsonObject> =\n  // A LiveList serializes to an equivalent JSON array\n  L extends LiveList<infer I> ? readonly ToImmutable<I>[] :\n\n  // A LiveObject serializes to an equivalent JSON object\n  L extends LiveObject<infer O> ? ToImmutable<O> :\n\n  // A LiveMap serializes to a JSON object with string-V pairs\n  L extends LiveMap<infer K, infer V> ? ReadonlyMap<K, ToImmutable<V>> :\n\n  // Any LsonObject recursively becomes a JsonObject\n  L extends LsonObject ?\n    { readonly [K in keyof L]: ToImmutable<Exclude<L[K], undefined>>\n                                 | (undefined extends L[K] ? undefined : never) } :\n\n  // Any Json value already is a legal Json value\n  L extends Json ? L :\n\n  // Otherwise, this is not possible\n  never;\n\n/**\n * Returns PlainLson for a given Json or LiveStructure, suitable for calling the storage init api\n */\nexport function toPlainLson(lson: Lson): PlainLson {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(([key, value]) =>\n          value !== undefined ? [[key, toPlainLson(value)]] : []\n        )\n      ),\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      ),\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item)),\n    };\n  } else {\n    return lson;\n  }\n}\n","import {\n  findNonSerializableValue,\n  isLiveList,\n  isLiveObject,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveList } from \"./crdts/LiveList\";\nimport { LiveMap } from \"./crdts/LiveMap\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport { LiveRegister } from \"./crdts/LiveRegister\";\nimport type { LiveNode, Lson, LsonObject, ToJson } from \"./crdts/Lson\";\nimport type { StorageUpdate } from \"./crdts/StorageUpdates\";\nimport * as console from \"./lib/fancy-console\";\nimport { isPlainObject } from \"./lib/guards\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonObject } from \"./lib/Json\";\n\nfunction lsonObjectToJson<O extends LsonObject>(\n  obj: O\n): { [K in keyof O]: Json } {\n  const result = {} as { [K in keyof O]: Json };\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== undefined) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\n\nexport function liveObjectToJson<O extends LsonObject>(\n  liveObject: LiveObject<O>\n): { [K in keyof O]: Json } {\n  return lsonObjectToJson(liveObject.toObject());\n}\n\nfunction liveMapToJson<TKey extends string>(\n  map: LiveMap<TKey, Lson>\n): { [K in TKey]: Json } {\n  const result = {} as { [K in TKey]: Json };\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\n\nfunction lsonListToJson(value: Lson[]): Json[] {\n  return value.map(lsonToJson);\n}\n\nfunction liveListToJson(value: LiveList<Lson>): Json[] {\n  return lsonListToJson(value.toArray());\n}\n\nexport function lsonToJson(value: Lson): Json {\n  // Check for LiveStructure datastructures first\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    // NOTE: This branch should never be taken, because LiveRegister isn't a valid Lson value\n    return value.data as Json;\n  }\n\n  // Then for composite Lson values\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n\n  // Finally, if value is an LsonScalar, then it's also a valid JsonScalar\n  return value;\n}\n\n/**\n * Deeply converts all nested lists to LiveLists, and all nested objects to\n * LiveObjects.\n *\n * As such, the returned result will not contain any Json arrays or Json\n * objects anymore.\n */\nfunction deepLiveify(value: Lson | LsonObject): Lson {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init: LsonObject = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === undefined) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\n\nexport function patchLiveList<T extends Lson>(\n  liveList: LiveList<T>,\n  prev: Array<T>,\n  next: Array<T>\n): void {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n\n  let prevNode = prev[0];\n  let nextNode = next[0];\n\n  /**\n   * For A,B,C => A,B,C,D\n   * i = 3, prevEnd = 2, nextEnd = 3\n   *\n   * For A,B,C => B,C\n   * i = 2, prevEnd = 2, nextEnd = 1\n   *\n   * For B,C => A,B,C\n   * i = 0, pre\n   */\n\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]) as T, i);\n        //                                   ^^^^ FIXME Not entirely true\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n\n      if (\n        isLiveObject(liveListNode) &&\n        isPlainObject(prevNode) &&\n        isPlainObject(nextNode)\n      ) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode) as T);\n        //                                    ^^^^ FIXME Not entirely true\n      }\n\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]) as T, i);\n      //                                   ^^^^ FIXME Not entirely true\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\n\nexport function patchLiveObjectKey<\n  O extends LsonObject,\n  K extends keyof O,\n  V extends Json,\n>(liveObject: LiveObject<O>, key: K, prev?: V, next?: V): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      console.error(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n\n  const value = liveObject.get(key);\n\n  if (next === undefined) {\n    liveObject.delete(key);\n  } else if (value === undefined) {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (\n    isLiveObject(value) &&\n    isPlainObject(prev) &&\n    isPlainObject(next)\n  ) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  }\n}\n\nexport function patchLiveObject<O extends LsonObject>(\n  root: LiveObject<O>,\n  prev: ToJson<O>,\n  next: ToJson<O>\n): void {\n  const updates: Partial<O> = {};\n\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key] as Json, next[key] as Json);\n  }\n\n  for (const key in prev) {\n    if (next[key] === undefined) {\n      root.delete(key);\n    }\n  }\n\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\n\nfunction getParentsPath(node: LiveNode): Array<string | number> {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\n\n//\n// TODO: Remove `patchImmutableObject`!\n//\n// This helper is now only used internally, to support our Zustand and\n// Redux packages. We should be able to reimplement those using the new\n// `.toImmutable()` APIs.\n//\nexport function legacy_patchImmutableObject<TState extends JsonObject>(\n  state: TState,\n  updates: StorageUpdate[]\n): TState {\n  return updates.reduce(\n    (state, update) => legacy_patchImmutableObjectWithUpdate(state, update),\n    state\n  );\n}\n\nfunction legacy_patchImmutableObjectWithUpdate<TState extends JsonObject>(\n  state: TState,\n  update: StorageUpdate\n): TState {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\n\nfunction legacy_patchImmutableNode<S extends Json>(\n  state: S,\n  path: Array<string | number>,\n  update: StorageUpdate\n): S {\n  // FIXME: Split this function up into a few smaller ones! In each of them,\n  // the types can be define much more narrowly and correctly, and there will\n  // be less type shoehorning necessary.\n\n  const pathItem = path.pop();\n  if (pathItem === undefined) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== undefined) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n\n        let newState: Json[] = state.map((x: Json) => x);\n\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map((item, index) =>\n              index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index),\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1),\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1),\n              ];\n            }\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== undefined) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n    }\n  }\n\n  if (Array.isArray(state)) {\n    const newArray: Json[] = [...state];\n    newArray[pathItem as number] = legacy_patchImmutableNode(\n      state[pathItem as number],\n      path,\n      update\n    );\n    return newArray as S;\n    //              ^^^^\n    //              FIXME Not completely true, because we could have been\n    //              updating indexes from StorageUpdate here that aren't in S,\n    //              technically.\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === undefined) {\n      return state;\n    } else {\n      const stateAsObj: JsonObject = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update),\n      } as S;\n      //   ^\n      //   FIXME Not completely true, because we could have been updating\n      //   indexes from StorageUpdate here that aren't in S, technically.\n    }\n  } else {\n    return state;\n  }\n}\n","import * as console from \"./fancy-console\";\n\n/**\n * Tools to help with the controlled deprecation of public APIs.\n *\n * First warn, then error, then remove eventually.\n */\n\n// Keeps a set of deprecation messages in memory that it has warned about\n// already. There will be only one deprecation message in the console, no\n// matter how often it gets called.\nconst _emittedDeprecationWarnings: Set<string> = new Set();\n\n/**\n * Displays a deprecation warning in the dev console. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecate(message: string, key = message): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      console.errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\n\n/**\n * Conditionally displays a deprecation warning in the dev\n * console if the first argument is truthy. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecateIf(\n  condition: unknown,\n  message: string,\n  key = message\n): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\n\n/**\n * Throws a deprecation error in the dev console.\n *\n * Only triggers in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function throwUsageError(message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    console.errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\n\n/**\n * Conditionally throws a usage error in the dev console if the first argument\n * is truthy. Use this to \"escalate\" usage patterns that in previous versions\n * we already warned about with deprecation warnings.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function errorIf(condition: unknown, message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n","import { FSM } from \"./fsm\";\n\nexport type Poller = {\n  /**\n   * Increments the subscriber count for this poller. If it becomes > 0, the\n   * poller will be enabled.\n   */\n  inc(): void;\n  /**\n   * Decrements the subscriber count for this poller. If it becomes = 0, the\n   * poller will be disabled.\n   */\n  dec(): void;\n\n  /**\n   * Polls immediately only if it has been more than `maxStaleTimeMs` milliseconds since\n   * the last poll and no poll is currently in progress. After polling, schedules\n   * the next poll at the regular interval.\n   */\n  pollNowIfStale(): void;\n\n  /**\n   * Used in unit tests only.\n   * @internal\n   */\n  setInForeground(condition: boolean): void;\n};\n\ntype Context = {\n  inForeground: boolean; // Whether the visibility state is visible\n  lastSuccessfulPollAt: number; // The timestamp of the last successful poll (or when the poller was initialized)\n  count: number; // Subscriber count\n  backoff: number; // Backoff delay in ms\n};\n\ntype State =\n  | \"@idle\" //\n  | \"@enabled\" //\n  | \"@polling\";\n\ntype Event =\n  | { type: \"START\" } //\n  | { type: \"STOP\" } //\n  | { type: \"POLL\" };\n\nconst BACKOFF_DELAYS = [1_000, 2_000, 4_000, 8_000, 10_000] as const;\n\n/**\n * Makes a poller that will call `await callback()` at the desired interval (in\n * millis).\n *\n * The poller has only three public APIs, all side effects:\n * - .inc(): void\n * - .dec(): void\n * - .pollNowIfStale(): void\n *\n * It has the following behaviors/guarantees:\n * - Performing a \"poll\" literally means calling the provided callback (and\n *   awaiting it)\n * - It will only ever start polling if .inc() was called (more often than .dec())\n * - It will not _immediately_ poll if .inc() is called. The first poll\n *   can be expected no earlier than the specified interval.\n * - If .dec() is called as many times as .inc(), it stops the poller. This\n *   means that any next poll will get unscheduled. If .dev() is called while\n *   a poll is ongoing, it will still finish that poll, but after that stop\n *   further polling.\n * - If the document's visibility state changes to hidden (tab is moved to the\n *   background), polling will be paused until the document's made visible again\n * - If the document becomes visible again, the poller will:\n *   - Still do nothing if the poller isn't enabled\n *   - Still do nothing if the poller is enabled, but the last time a poll\n *     happened recently enough (= less than the maxStaleTimeMs, which defaults\n *     to infinity)\n *   - Trigger a poll right away otherwise. If an existing poll was already\n *     scheduled, think of it as if this future poll is \"earlied\" and just\n *     happening right now instead\n */\nexport function makePoller(\n  callback: (signal: AbortSignal) => Promise<void> | void,\n  intervalMs: number,\n  options?: {\n    maxStaleTimeMs?: number;\n  }\n): Poller {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : undefined;\n  const win = typeof window !== \"undefined\" ? window : undefined;\n\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context: Context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0,\n  };\n\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n\n  /**\n   *                                    +----------+\n   *        +-------------------------> |  @idle   |\n   *        |   else                    +----------+\n   *        |                             |      ^\n   *        |                     on STOP |      | on START\n   *        |                             v      |\n   *   +--------+   if mayPoll()        +----------+      on POLL             +----------+\n   *   | decide |---------------------> | @enabled | -----------------------> | @polling |\n   *   +--------+                       +----------+   after POLL_INTERVAL    +----------+\n   *        ^                                                                      |\n   *        |                                                                      |\n   *        +----------------------------------------------------------------------+\n   */\n  const fsm = new FSM<object, Event, State>({})\n    .addState(\"@idle\")\n    .addState(\"@enabled\")\n    .addState(\"@polling\");\n\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          // Reset backoff delay to 0 if the callback was successful\n          context.backoff = 0;\n        },\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          // Increase the backoff delay if an error occured\n          context.backoff =\n            BACKOFF_DELAYS.find((delay) => delay > context.backoff) ??\n            BACKOFF_DELAYS[BACKOFF_DELAYS.length - 1];\n        },\n      };\n    },\n    30_000 // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n\n  function setInForeground(inForeground: boolean) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale(); // Won't do anything if in @idle\n  }\n\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n\n  // NOTE: Currently, poller instances are only ever created and never\n  // destroyed. If we add a destroy() method in the future, then we should also\n  // unregister these event handlers.\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground,\n  };\n}\n","import { isPlainObject } from \"./guards\";\n\nfunction shallowArray(xs: unknown[], ys: unknown[]): boolean {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction shallowObj(objA: unknown, objB: unknown): boolean {\n  // Only try to compare keys/values if these objects are both \"pojos\" (plain\n  // old JavaScript objects)\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(objB, key) &&\n      Object.is(objA[key], objB[key])\n  );\n}\n\n/**\n * Shallowly compares two given values.\n *\n * - Two simple values are considered equal if they're strictly equal\n * - Two arrays are considered equal if their members are strictly equal\n * - Two objects are considered equal if their values are strictly equal\n *\n * Testing goes one level deep.\n */\nexport function shallow(a: unknown, b: unknown): boolean {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n\n    return shallowArray(a, b);\n  }\n\n  return shallowObj(a, b);\n}\n","/**\n * Returns the insertion index for the given item.\n */\nfunction bisectRight<T>(arr: readonly T[], x: T, lt: (a: T, b: T) => boolean) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + ((hi - lo) >> 1); // equiv of Math.floor((lo + hi) / 2)\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n\n/**\n * A datastructure to keep elements in ascending order, as defined by the \"less\n * than\" function you provide. The elements will be ordered according to\n * whatever you define as the \"less than\" for this element type, so that every\n * element is less than its successor in the list.\n *\n * const sorted = SortedList.from(\n *   [{ id: 4 }, { id: 1 }, { id: 9 }, { id: 4 }],\n *   (a, b) => a.id < b.id)\n * )\n * sorted.add({ id: 5 })\n * sorted.remove({ id: 4 })  // Assuming it's the same obj ref!\n *\n * Array.from(sorted)\n * [{ id: 1 }, { id: 4 }, { id: 5 }, { id: 9 }])\n */\nexport class SortedList<T> {\n  #data: T[];\n  #lt: (a: T, b: T) => boolean;\n\n  private constructor(alreadySortedList: T[], lt: (a: T, b: T) => boolean) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n\n  public static from<T>(arr: T[], lt: (a: T, b: T) => boolean): SortedList<T> {\n    const sorted = new SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n\n  public static fromAlreadySorted<T>(\n    alreadySorted: T[],\n    lt: (a: T, b: T) => boolean\n  ): SortedList<T> {\n    return new SortedList(alreadySorted, lt);\n  }\n\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  public clone(): SortedList<T> {\n    return new SortedList(this.#data.slice(), this.#lt);\n  }\n\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value: T): void {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n  }\n\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   */\n  remove(value: T): boolean {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  get length(): number {\n    return this.#data.length;\n  }\n\n  *filter(predicate: (value: T) => boolean): IterableIterator<T> {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.#data[Symbol.iterator]();\n  }\n}\n","import type { DP, DU } from \"../globals/augmentation\";\nimport type { JsonObject } from \"../lib/Json\";\nimport type { Relax } from \"../lib/Relax\";\nimport type { Resolve } from \"../lib/Resolve\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { User } from \"./User\";\n\nexport type InternalOthersEvent<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n> = Relax<\n  | { type: \"leave\"; user: User<P, U> }\n  | { type: \"enter\"; user: User<P, U> }\n  | {\n      type: \"update\";\n      user: User<P, U>;\n      updates: Partial<P>;\n    }\n  | { type: \"reset\" }\n>;\n\nexport type OthersEvent<\n  P extends JsonObject = DP,\n  U extends BaseUserMeta = DU,\n> = Resolve<\n  InternalOthersEvent<P, U> & {\n    others: readonly User<P, U>[];\n  }\n>;\n\nexport enum TextEditorType {\n  Lexical = \"lexical\",\n  TipTap = \"tiptap\",\n}\n","import { detectDupes } from \"./dupe-detection\";\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n/**\n * PRIVATE / INTERNAL APIS\n * -----------------------\n *\n * This module is intended for internal use only, PLEASE DO NOT RELY ON ANY OF\n * THE EXPORTS IN HERE. These are implementation details that can change at any\n * time and without announcement. This module purely exists to share code\n * between the several Liveblocks packages.\n *\n * But since you're so deep inside Liveblocks code... we're hiring!\n * https://join.team/liveblocks ;)\n */\n\nexport type {\n  Client,\n  ClientOptions,\n  EnterOptions,\n  OpaqueClient,\n  PrivateClientApi,\n  ResolveMentionSuggestionsArgs,\n  ResolveRoomsInfoArgs,\n  ResolveUsersArgs,\n  SyncStatus,\n} from \"./client\";\nexport { createClient } from \"./client\";\nexport type {\n  CommentBodyLinkElementArgs,\n  CommentBodyMentionElementArgs,\n  CommentBodyParagraphElementArgs,\n  CommentBodyTextElementArgs,\n  StringifyCommentBodyElements,\n  StringifyCommentBodyOptions,\n} from \"./comments/comment-body\";\nexport {\n  getMentionedIdsFromCommentBody,\n  html,\n  htmlSafe,\n  isCommentBodyLink,\n  isCommentBodyMention,\n  isCommentBodyText,\n  resolveUsersInCommentBody,\n  stringifyCommentBody,\n  toAbsoluteUrl,\n} from \"./comments/comment-body\";\nexport { generateCommentUrl } from \"./comments/comment-url\";\nexport type { BaseAuthResult, Delegates } from \"./connection\";\nexport type { LostConnectionEvent, Status } from \"./connection\";\nexport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToInboxNotificationData,\n  convertToThreadData,\n} from \"./convert-plain-data\";\nexport { cloneLson, isLiveNode } from \"./crdts/liveblocks-helpers\";\nexport { LiveList } from \"./crdts/LiveList\";\nexport { LiveMap } from \"./crdts/LiveMap\";\nexport { LiveObject } from \"./crdts/LiveObject\";\nexport type {\n  LiveNode,\n  LiveStructure,\n  Lson,\n  LsonObject,\n  ToJson,\n} from \"./crdts/Lson\";\nexport type {\n  LiveListUpdate,\n  LiveMapUpdate,\n  LiveObjectUpdate,\n  StorageUpdate,\n} from \"./crdts/StorageUpdates\";\nexport type { ToImmutable } from \"./crdts/utils\";\nexport { toPlainLson } from \"./crdts/utils\";\nexport type {\n  DAD,\n  DE,\n  DM,\n  DP,\n  DRI,\n  DS,\n  DU,\n  KDAD,\n} from \"./globals/augmentation\";\nexport {\n  legacy_patchImmutableObject,\n  lsonToJson,\n  patchLiveObjectKey,\n} from \"./immutable\";\nexport { kInternal } from \"./internal\";\nexport { assert, assertNever, nn } from \"./lib/assert\";\nexport type {\n  AsyncError,\n  AsyncLoading,\n  AsyncResult,\n  AsyncSuccess,\n} from \"./lib/AsyncResult\";\nexport { autoRetry, HttpError } from \"./lib/autoRetry\";\nexport { chunk } from \"./lib/chunk\";\nexport { Promise_withResolvers } from \"./lib/controlledPromise\";\nexport {\n  createCommentAttachmentId,\n  createCommentId,\n  createInboxNotificationId,\n  createThreadId,\n} from \"./lib/createIds\";\nexport { DefaultMap } from \"./lib/DefaultMap\";\nexport {\n  deprecate,\n  deprecateIf,\n  errorIf,\n  throwUsageError,\n} from \"./lib/deprecation\";\nexport type {\n  EventSource,\n  Observable,\n  UnsubscribeCallback,\n} from \"./lib/EventSource\";\nexport { makeEventSource } from \"./lib/EventSource\";\nexport * as console from \"./lib/fancy-console\";\nexport { freeze } from \"./lib/freeze\";\nexport { isPlainObject, isStartsWithOperator } from \"./lib/guards\";\nexport type { Json, JsonArray, JsonObject, JsonScalar } from \"./lib/Json\";\nexport { isJsonArray, isJsonObject, isJsonScalar } from \"./lib/Json\";\nexport { nanoid } from \"./lib/nanoid\";\nexport type { NoInfr } from \"./lib/NoInfer\";\nexport { objectToQuery } from \"./lib/objectToQuery\";\nexport type { Poller } from \"./lib/Poller\";\nexport { makePoller } from \"./lib/Poller\";\nexport { asPos, makePosition } from \"./lib/position\";\nexport type { Relax } from \"./lib/Relax\";\nexport type { Resolve } from \"./lib/Resolve\";\nexport { shallow } from \"./lib/shallow\";\nexport type { ISignal, SignalType } from \"./lib/signals\";\nexport { batch, DerivedSignal, MutableSignal, Signal } from \"./lib/signals\";\nexport { SortedList } from \"./lib/SortedList\";\nexport { stringify } from \"./lib/stringify\";\nexport type { QueryParams, URLSafeString } from \"./lib/url\";\nexport { url, urljoin } from \"./lib/url\";\nexport type { Brand, DistributiveOmit } from \"./lib/utils\";\nexport {\n  b64decode,\n  compactObject,\n  mapValues,\n  memoizeOnSuccess,\n  raise,\n  tryParseJson,\n  wait,\n  withTimeout,\n} from \"./lib/utils\";\nexport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nexport { Permission } from \"./protocol/AuthToken\";\nexport type { BaseActivitiesData } from \"./protocol/BaseActivitiesData\";\nexport type { BaseRoomInfo } from \"./protocol/BaseRoomInfo\";\nexport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nexport type {\n  BroadcastEventClientMsg,\n  ClientMsg,\n  FetchStorageClientMsg,\n  FetchYDocClientMsg,\n  UpdatePresenceClientMsg,\n  UpdateStorageClientMsg,\n  UpdateYDocClientMsg,\n} from \"./protocol/ClientMsg\";\nexport { ClientMsgCode } from \"./protocol/ClientMsg\";\nexport type { BaseMetadata } from \"./protocol/Comments\";\nexport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"./protocol/Comments\";\nexport type {\n  CommentAttachment,\n  CommentData,\n  CommentDataPlain,\n  CommentLocalAttachment,\n  CommentMixedAttachment,\n  CommentReaction,\n} from \"./protocol/Comments\";\nexport type {\n  CommentUserReaction,\n  CommentUserReactionPlain,\n} from \"./protocol/Comments\";\nexport type { QueryMetadata } from \"./protocol/Comments\";\nexport type {\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDataWithDeleteInfo,\n} from \"./protocol/Comments\";\nexport type { ThreadDeleteInfo } from \"./protocol/Comments\";\nexport type {\n  ActivityData,\n  InboxNotificationCustomData,\n  InboxNotificationCustomDataPlain,\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationTextMentionData,\n  InboxNotificationTextMentionDataPlain,\n  InboxNotificationThreadData,\n  InboxNotificationThreadDataPlain,\n} from \"./protocol/InboxNotifications\";\nexport type { InboxNotificationDeleteInfo } from \"./protocol/InboxNotifications\";\nexport type {\n  AckOp,\n  CreateListOp,\n  CreateMapOp,\n  CreateObjectOp,\n  CreateOp,\n  CreateRegisterOp,\n  DeleteCrdtOp,\n  DeleteObjectKeyOp,\n  Op,\n  SetParentKeyOp,\n  UpdateObjectOp,\n} from \"./protocol/Op\";\nexport { ackOp, OpCode } from \"./protocol/Op\";\nexport type {\n  IdTuple,\n  SerializedChild,\n  SerializedCrdt,\n  SerializedList,\n  SerializedMap,\n  SerializedObject,\n  SerializedRegister,\n  SerializedRootObject,\n} from \"./protocol/SerializedCrdt\";\nexport { CrdtType } from \"./protocol/SerializedCrdt\";\nexport { isChildCrdt, isRootCrdt } from \"./protocol/SerializedCrdt\";\nexport type {\n  BroadcastedEventServerMsg,\n  CommentsEventServerMsg,\n  InitialDocumentStateServerMsg,\n  RejectedStorageOpServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  UpdatePresenceServerMsg,\n  UpdateStorageServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nexport { ServerMsgCode } from \"./protocol/ServerMsg\";\nexport type { HistoryVersion } from \"./protocol/VersionHistory\";\nexport type { IYjsProvider, PrivateRoomApi, YjsSyncStatus } from \"./room\";\nexport type {\n  BroadcastOptions,\n  History,\n  OpaqueRoom,\n  OptionalTupleUnless,\n  PartialUnless,\n  Room,\n  RoomEventMessage,\n  StorageStatus,\n  SyncSource,\n} from \"./room\";\nexport type { GetThreadsOptions, UploadAttachmentOptions } from \"./room\";\nexport type { Immutable } from \"./types/Immutable\";\nexport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nexport { WebsocketCloseCodes } from \"./types/IWebSocket\";\nexport type { LiveblocksErrorContext } from \"./types/LiveblocksError\";\nexport { LiveblocksError } from \"./types/LiveblocksError\";\nexport type { NodeMap, ParentToChildNodeMap } from \"./types/NodeMap\";\nexport type { OptionalPromise } from \"./types/OptionalPromise\";\nexport type { OthersEvent } from \"./types/Others\";\nexport { TextEditorType } from \"./types/Others\";\nexport type { Patchable } from \"./types/Patchable\";\nexport type {\n  PlainLson,\n  PlainLsonFields,\n  PlainLsonList,\n  PlainLsonMap,\n  PlainLsonObject,\n} from \"./types/PlainLson\";\nexport type { RoomNotificationSettings } from \"./types/RoomNotificationSettings\";\nexport type { User } from \"./types/User\";\nexport { detectDupes };\n\n/**\n * Helper type to help users adopt to Lson types from interface definitions.\n * You should only use this to wrap interfaces you don't control. For more\n * information, see\n * https://liveblocks.io/docs/guides/limits#lson-constraint-and-interfaces\n */\n// prettier-ignore\nexport type EnsureJson<T> =\n  // Retain all valid `JSON` fields\n  T extends Json ? T :\n  // Retain all valid arrays\n  T extends Array<infer I> ? (EnsureJson<I>)[] :\n  // Retain `unknown` fields, but just treat them as if they're Json | undefined\n  [unknown] extends [T] ? Json | undefined :\n  // Dates become strings when serialized to JSON\n  T extends Date ? string :\n  // Remove functions\n  T extends (...args: any[]) => any ? never :\n  // Resolve all other values explicitly\n  { [K in keyof T as EnsureJson<T[K]> extends never ? never : K]: EnsureJson<T[K]> };\n\n// Support for DevTools\nimport type * as DevToolsMsg from \"./devtools/protocol\";\nexport type { DevToolsMsg };\nimport { HttpError } from \"./lib/autoRetry\";\nimport type { Json } from \"./lib/Json\";\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nexport type { DevTools };\n\n// Deprecated APIs\n/** @deprecated Use HttpError instead. */\nexport const CommentsApiError = HttpError;\n/** @deprecated Use HttpError instead. */\nexport const NotificationsApiError = HttpError;\n"],"names":["error","eventSource","error","call","batch","t","entries","entries","url","parts","error","batch","url","after","ServerMsgCode","WebsocketCloseCodes","error","log","ctx","Permission","OpCode","CrdtType","id","parentKey","deleteDelta","before","after","entries","id","key","key","ClientMsgCode","error","options","updates","event","batch","url","options","error","url","error","state","BACKOFF_DELAYS","TextEditorType"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]}},
    {"offset": {"line": 8781, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}